<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Number-Theory]]></title>
    <url>%2Fnumber-theory.html</url>
    <content type="text"><![CDATA[0.1. gcd, co-primes 0.1.1. Bezout’s identity 0.2. primality_test 0.2.1. Prime Sieve 0.2.2. Miller-Rabin 0.3. Factorization 0.3.1. Pollard’s rho algorithm 0.4. Euler function 0.5. Modulo equation 0.1. gcd, co-primesgcd is short for greatest common divisorIf a,b are co-primes, we denote as $(a,b)=1, \text{which means } gcd(a,b)=1 $We can use Euclid algorithm to calculate gcd of two numbers.1234def gcd(a,b): while b!=0: a,b=b,a%b return a 0.1.1. Bezout’s identity Let a and b be integers with greatest common divisor d. Then, there exist integers x and y such that ax + by = d. More generally, the integers of the form ax + by are exactly the multiples of d. we can use extended euclid algorithm to calculate x,y,gcd(a,b)gcd.py12345def xgcd(a,b): '''return gcd(a,b), x,y where ax+by=gcd(a,b)''' if b==0:return a,1,0 g,x,y = xgcd(b,a%b) return g,y,x-a//b*y 0.2. primality_test 0.2.1. Prime Sieve12345678910111213141516171819202122232425class primeSieve: '''sieve of Eratosthenes, It will be more efficient when judging many times''' primes = [2,3,5,7,11,13] def isPrime(self,x): if x&lt;=primes[-1]: return twoDivideFind(x,self.primes) while x&gt;self.primes[-1]: left = self.primes[-1] right = (left+1)**2 lst = [] for i in range(left,right): for j in self.primes: if i%j==0:break else:lst.append(i) self.primes+=lst return twoDivideFind(x,lst)def twoDivideFind(x,li): a,b = 0, len(li) while a&lt;=b: mid = (a+b)//2 if li[mid]&lt;x:a=mid+1 elif li[mid]&gt;x: b= mid-1 else:return mid return -1 0.2.2. Miller-Rabin Excerpted from wikipedia:Miller_Rabin_primality_test Just like the Fermat and Solovay–Strassen tests, the Miller–Rabin test relies on an equality or set of equalities that hold true for prime values, then checks whether or not they hold for a number that we want to test for primality. First, a lemma “Lemma (mathematics)”) about square roots of unity in the finite field Z/p**Z*, where p is prime and p &gt; 2. Certainly 1 and −1 always yield 1 when squared modulo p; call these trivial “Trivial (mathematics)”) square roots of 1. There are no nontrivial square roots of 1 modulo p (a special case of the result that, in a field, a polynomial has no more zeroes than its degree). To show this, suppose that x is a square root of 1 modulo p*. Then: x^2\equiv1\ (mod\ p)(x-1)(x+1) \equiv 0\ (mod\ p)In other words, prime p divides the product (x − 1)(x + 1). By Euclid’s lemma it divides one of the factors x − 1 or x + 1, implying that x is congruent to either 1 or −1 modulo p. Now, let n be prime, and odd, with n &gt; 2. It follows that n − 1 is even and we can write it as 2s·d, where s and d are positive integers and d is odd. For each a in (Z/n**Z*), either a^d\equiv 1\ (mod\ n)or a^{2^r*d}\equiv -1\ (mod\ n), \text{where } 0\le r]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String-Mathching-Algorithm]]></title>
    <url>%2Fstring-matching.html</url>
    <content type="text"><![CDATA[See more on github In this article, I will show you some kinds of popular string matching algorithm and dynamic programming algorithm for wildcard matching. String Matching algorithm Rabin-KarpWe can view a string of k characters (digits) as a length-k decimal number. E.g., the string “31425” corresponds to the decimal number 31,425. Given a pattern P [1..m], let p denote the corresponding decimal value. Given a text T [1..n], let $t_s$ denote the decimal value of the length-m substring T [(s+1)..(s+m)] for s=0,1,…,(n-m). let d be the radix of num, thus $d = len(set(s))$ $t_s$ = p iff T [(s+1)..(s+m)] = P [1..m]. p can be computed in O(m) time. p = P[m] + d*(P[m-1] + d*(P[m-2]+…)). $t_0$ can similarly be computed in O(m) time. Other $t_1,\ldots,t_{n-m}$ can be computed in O(n-m) time since $t_{s+1} can be computed from ts in constant time. Namely, t_{s+1} = d*(t_s-d^{m-1} * T[s+1])+T[s+m+1]However, it’s no need to calculate $t_{s+1}$ directly. We can use modulus operation to reduce the work of caculation. We choose a small prime number. Eg 13 for radix( denoted as d) 10.Generally, $d*q$ should fit within one computer word. We firstly caculate $t_0$ mod q.Then, for every $t_i (i&gt;1)$assume t_{i-1} = T[i+m-1] + d*T[i+m-2]+\ldots+d^{m-1}*T[i-1]denote $ d’ = d^{m-1}\ mod\ q$thus, \begin{aligned} t_i &= (t_{i-1} - d^{m-1}*T[i-1]) * d + T[i+m]\\ &\equiv (t_{i-1} - d^{m-1}*T[i-1]) * d + T[i+m] (mod\ q)\\ &\equiv (t_{i-1}- ( d^{m-1} mod \ q) *T[i-1]) * d + T[i+m] (mod\ q)\\ &\equiv (t_{i-1}- d'*T[i-1]) * d + T[i+m] (mod\ q) \end{aligned}So we can compare the modular value of each $t_i$ with p’s.Only if they are the same, then we compare the origin chracters, namely T[i],T[i+1],\ldots,T[i+m-1]and the pattern characters.Gernerally, this algorithm’s time approximation is O(n+m), and the worst case is O((n-m+1)*m) Problem: this is assuming p and $t_s$ are small numbers. They may be too large to work with easily. python implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#coding: utf-8''' mbinary########################################################################## File : rabin_karp.py# Author: mbinary# Mail: zhuheqin1@gmail.com# Blog: https://mbinary.github.io# Github: https://github.com/mbinary# Created Time: 2018-12-11 00:01# Description: rabin-karp algorithm#########################################################################'''def isPrime(x): for i in range(2,int(x**0.5)+1): if x%i==0:return False return Truedef getPrime(x): '''return a prime which is bigger than x''' for i in range(x,2*x): if isPrime(i):return idef findAll(s,p): '''s: string p: pattern''' dic=&#123;&#125; n,m = len(s),len(p) d=0 #radix for c in s: if c not in dic: dic[c]=d d+=1 sm = 0 for c in p: if c not in dic:return [] sm = sm*d+dic[c] ret = [] cur = 0 for i in range(m): cur=cur*d + dic[s[i]] if cur==sm:ret.append(0) tmp = n-m q = getPrime(m) cur = cur%q sm = sm%q exp = d**(m-1) % q for i in range(m,n): cur = ((cur-dic[s[i-m]]*exp)*d+dic[s[i]]) % q if cur == sm and p==s[i-m+1:i+1]: ret.append(i-m+1) return retdef randStr(n=3): return [randint(ord('a'),ord('z')) for i in range(n)]if __name__ =='__main__': from random import randint s = randStr(50) p = randStr(1) print(s) print(p) print(findAll(s,p)) FSMA FSM can be represented as $(Q,q_0,A,S,C)$, where Q is the set of all states $q_0$ is the start state $A\in Q$ is a set of accepting states. S is a finite input alphabet. C is the set of transition functions: namely $q_j = c(s,q_i)$. Given a pattern string S, we can build a FSM for string matching.Assume S has m chars, and there should be m+1 states. One is for the begin state, and the others are for matching state of each position of S. Once we have built the FSM, we can run it on any input string. KMP Knuth-Morris-Pratt method The idea is inspired by FSM. We can avoid computing the transition functions. Instead, we compute a prefix function P in O(m) time, which has only m entries. Prefix funtion stores info about how the pattern matches against shifts of itself. String w is a prefix of string x, if x=wy for some string y String w is a suffix of string x, if x=yw for some string y The k-character prefix of the pattern P [1..m] denoted by Pk. Given that pattern prefix P [1..q] matches text characters T [(s+1)..(s+q)], what is the least shift s’&gt; s such that P [1..k] = T [(s’+1)..(s’+k)] where s’+k=s+q? At the new shift s’, no need to compare the first k characters of P with corresponding characters of T.Method: For prefix $p_i$, find the longest proper prefix of $p_i$ that is also a suffix of $p_i$. pre[q] = max\{k|k]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串匹配</tag>
        <tag>KMP</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图算法]]></title>
    <url>%2Fgraph.html</url>
    <content type="text"><![CDATA[1. 图 1.1. 概念 1.1.1. 性质 1.2. 图的表示 1.3. 树 2. 图的搜索 2.1. BFS 2.2. DFS 2.2.1. DFS 的性质 2.3. 拓扑排序 2.4. 强连通分量 3. 最小生成树 3.1. Kruskal 算法 3.2. Prim 算法 4. 单源最短路 4.1. 最短路的子路径也是最短路径 4.2. 负权重的边 4.3. 初始化 4.4. 松弛操作 4.5. 有向无环图的单源最短路问题 4.6. Bellman-Ford 算法 4.7. Dijkstra 算法 5. 所有结点对的最短路问题 5.1. 矩阵乘法 5.2. Floyd-Warshall 算法 5.3. Johnson 算法 6. 最大流 6.1. 最大流最小截定理 6.2. 多个源,汇 6.3. Ford-Fulkerson 方法 6.3.1. 残存网络 6.3.2. 增广路径 6.3.3. 割 6.4. 基本的 Ford-Fulkerson算法 6.5. TBD 7. 参考资料 1. 图 1.1. 概念 顶 顶点的度 d 边 相邻 重边 环 完全图: 所有顶都相邻 二分图: $V(G) = X \cup Y, X\cap Y = \varnothing$, X中, Y 中任两顶不相邻 轨道 圈 1.1.1. 性质 $\sum_{v\in V} d(v) = 2|E|$ G是二分图 $\Leftrightarrow$ G无奇圈 树是无圈连通图 树中, $|E| = |V| -1$ 1.2. 图的表示 邻接矩阵 邻接链表 1.3. 树无圈连通图, $E = V-1$, 详细见树, 2. 图的搜索Introduction to algorithm1 2.1. BFS123456789101112131415for v in V: v.d = MAX v.pre = None v.isFind = Falseroot. isFind = Trueroot.d = 0que = [root]while que !=[]: nd = que.pop(0) for v in Adj(nd): if not v.isFind : v.d = nd.d+1 v.pre = nd v.isFind = True que.append(v) 时间复杂度 $O(V+E)$ 2.2. DFS$\Theta(V+E)$123456789101112131415161718def dfs(G): time = 0 for v in V: v.pre = None v.isFind = False for v in V : # note this, if not v.isFind: dfsVisit(v) def dfsVisit(G,u): time =time+1 u.begin = time u.isFind = True for v in Adj(u): if not v.isFind: v.pre = u dfsVisit(G,v) time +=1 u.end = time begin, end 分别是结点的发现时间与完成时间 2.2.1. DFS 的性质 其生成的前驱子图$G_{pre}$ 形成一个由多棵树构成的森林, 这是因为其与 dfsVisit 的递归调用树相对应 括号化结构 括号化定理: 考察两个结点的发现时间与结束时间的区间 [u,begin,u.end] 与 [v.begin,v.end] 如果两者没有交集, 则两个结点在两个不同的子树上(递归树) 如果 u 的区间包含在 v 的区间, 则 u 是v 的后代 2.3. 拓扑排序利用 DFS, 结点的完成时间的逆序就是拓扑排序 同一个图可能有不同的拓扑排序 2.4. 强连通分量在有向图中, 强连通分量中的结点互达定义 $Grev$ 为 $G$ 中所有边反向后的图 将图分解成强连通分量的算法在 Grev 上根据 G 中结点的拓扑排序来 dfsVisit, 即1234compute Grevinitalizationfor v in topo-sort(G.V): if not v.isFind: dfsVisit(Grev,v) 然后得到的DFS 森林(也是递归树森林)中每个树就是一个强连通分量 3. 最小生成树利用了贪心算法,12345Generate-Minimum-spanning-tree(G) A = [] while len(A)!=len(G.V)-1: add a safe edge for A to A return A 3.1. Kruskal 算法总体上, 从最开始 每个结点就是一颗树的森林中(不相交集合, 并查集), 逐渐添加不形成圈的(两个元素不再同一个集合),最小边权的边.123456edges=[]for edge as u,v in sorted(G.E): if find-set(u) != find-set(v): edges.append(edge) union(u,v)return edges 如果并查集的实现采用了 按秩合并与路径压缩技巧, 则 find 与 union 的时间接近常数所以时间复杂度在于排序边, 即 $O(ElgE)$, 而 $E\lt V^2$, 所以 $lgE = O(lgV)$, 时间复杂度为 $O(ElgV)$ 3.2. Prim 算法用了 BFS, 类似 Dijkstra 算法从根结点开始 BFS, 一直保持成一颗树1234567891011for v in V: v.minAdjEdge = MAX v.pre = Noneroot.minAdjEdge = 0que = priority-queue (G.V) # sort by minAdjEdgewhile not que.isempty(): u = que.extractMin() for v in Adj(u): if v in que and v.minAdjEdge&gt;w(u,v): v.pre = u v.minAdjEdge = w(u,v) 建堆 $O(V)$ //note it&#39;s v, not vlgv 主循环中 extractMin: $O(VlgV)$ in 操作 可以另设标志位, 在常数时间完成, 总共 $O(E)$ 设置结点的 minAdjEdge, 需要$O(lgv)$, 循环 E 次,则 总共$O(ElgV)$ 综上, 时间复杂度为$O(ElgV)$如果使用的是 斐波那契堆, 在 设置 minAdjEdge时 调用 decrease-key, 这个操作摊还代价为 $O(1)$, 所以时间复杂度可改进到 $O(E+VlgV)$ 4. 单源最短路求一个结点到其他结点的最短路径, 可以用 Bellman-ford算法, 或者 Dijkstra算法.定义两个结点u,v间的最短路 \delta(u,v) = \begin{cases} \min(w(path)),\quad u\xrightarrow{path} v\\ \infty, \quad u\nrightarrow v \end{cases}问题的变体 单目的地最短路问题: 可以将所有边反向转换成求单源最短路问题 单结点对的最短路径 所有结点对最短路路径 4.1. 最短路的子路径也是最短路径$p=(v_0,v_1,\ldots,v_k)$为从结点$v_0$到$v_k$的一条最短路径, 对于任意$0\le i\le j \le k$, 记$p_{ij}=(v_i,v_{i+1},\ldots,v_j)$为 p 中 $v_i$到$v_j$的子路径, 则 $p_{ij}$为 $v_i$到$v_j$的一条最短路径 4.2. 负权重的边Dijkstra 算法不能处理负值边, 只能用 Bellman-Ford 算法,而且如果有负值圈, 则没有最短路, bellman-ford算法也可以检测出来 4.3. 初始化12345def initialaize(G,s): for v in G.V: v.pre = None v.distance = MAX s.distance = 0 4.4. 松弛操作1234def relax(u,v,w): if v.distance &gt; u.distance + w: v.distance = u.distance + w: v.pre = u 性质 三角不等式: $\delta(s,v) \leqslant \delta(s,u) + w(u,v)$ 上界: $v.distance \geqslant \delta(s,v)$ 收敛: 对于某些结点u,v 如果s-&gt;…-&gt;u-&gt;v是图G中的一条最短路径，并且在对边，进行松弛前任意时间有 $u.distance=\delta(s,u)$则在之后的所有时间有 $v.distance=\delta(s,v)$ 路径松弛性质: 如果$p=v_0 v_1 \ldots v_k$是从源结点下v0到结点vk的一条最短路径，并且对p中的边所进行松弛的次序为$(v_0,v_1),(v_1,v_2), \ldots ,(v_{k-1},v_k)$, 则 $v_k.distance = \delta(s,v_k)$该性质的成立与任何其他的松弛操作无关，即使这些松弛操作是与对p上的边所进行的松弛操作穿插进行的。 证明 4.5. 有向无环图的单源最短路问题$\Theta(V+E)$12345def dag-shortest-path(G,s): initialize(G,s) for u in topo-sort(G.V): for v in Adj(v): relax(u,v,w(u,v)) 4.6. Bellman-Ford 算法$O(VE)$123456789def bellman-ford(G,s): initialize(G,s) for ct in range(|V|-1): # v-1 times for u,v as edge in E: relax(u,v,w(u,v)) for u,v as edge in E: if v.distance &gt; u.distance + w(u,v): return False return True 第一个 for 循环就是进行松弛操作, 最后结果已经存储在 结点的distance 和 pre 属性中了, 第二个 for 循环利用三角不等式检查有不有负值圈. 下面是证明该算法的正确性 4.7. Dijkstra 算法$O(ElogV)$, 要求不能有负值边 Dijkstra算法既类似于广度优先搜索（，也有点类似于计算最小生成树的Prim算法。它与广度优先搜索的类似点在于集合S对应的是广度优先搜索中的黑色结点集合：正如集合S中的结点的最短路径权重已经计算出来一样，在广度优先搜索中，黑色结点的正确的广度优先距离也已经计算出来。Dijkstra算法像Prim算法的地方是，两个算法都使用最小优先队列来寻找给定集合（Dijkstra算法中的S集合与Prim算法中逐步增长的树）之外的“最轻”结点，将该结点加入到集合里，并对位于集合外面的结点的权重进行相应调整。 123456789def dijkstra(G,s): initialize(G,s) paths=[] q = priority-queue(G.V) # sort by distance while not q.empty(): u = q.extract-min() paths.append(u) for v in Adj(u): relax(u,v,w(u,v)) 5. 所有结点对的最短路问题 5.1. 矩阵乘法使用动态规划算法, 可以得到最短路径的结构设 $l_{ij}^{(m)}$为从结点i 到结点 j 的至多包含 m 条边的任意路径的最小权重,当m = 0, 此时i=j, 则 为0,可以得到递归定义 l_{ij}^{(m)} =\min( l_{ij}^{(m-1)}, \min_{1\leqslant k\leqslant n}( l_{ik}^{(m-1)}+w_{kj})) = \min_{1\leqslant k\leqslant n}( l_{ik}^{(m-1)}+w_{kj}))由于对于所有 j, 有 $w_{jj}=0$,所以上式后面的等式成立. 由于是简单路径, 则包含的边最多为 |V|-1 条, 所以 \delta(i,j) = l_{ij}^{(|V|-1)} = l_{ij}^{(|V|)} =l_{ij}^{(|V| + 1)}= ...所以可以从自底向上计算, 如下输入权值矩阵 $W(w_{ij})), L^{(m-1)}$,输出$ L^{(m)}$, 其中 $L^{(1)} = W$,123456789def f(L, W): n = L.rows L_new = new matrix(row=n ,col = n) for i in range(n): for j in range(n): L_new[i][j] = MAX for k in range(n): L_new[i][j] = min(L_new[i][j], L[i][k]+w[k][j]) return L_new 可以看出该算法与矩阵乘法的关系$L^{(m)} = W^m$,所以可以直接计算乘法, 每次计算一个乘积是 $O(V^3)$, 计算 V 次, 所以总体 $O(V^4)$, 使用矩阵快速幂可以将时间复杂度降低为$O(V^3lgV)$1234567def f(W): L = W i = 1 while i&lt;W.rows: L = L*L i*=2 return L 5.2. Floyd-Warshall 算法同样要求可以存在负权边, 但不能有负值圈. 用动态规划算法:设 $ d_{ij}^{(k)}$ 为 从 i 到 j 所有中间结点来自集合 ${\{1,2,\ldots,k\}}$ 的一条最短路径的权重. 则有 d_{ij}^{(k)} = \begin{cases} w_{ij},\quad k=0\\ min(d_{ij}^{(k-1)},d_{ik}^{(k-1)}+d_{kj}^{(k-1)}),\quad k\geqslant 1 \end{cases}而且为了找出路径, 需要记录前驱结点, 定义如下前驱矩阵 $\Pi$, 设 $ \pi_{ij}^{(k)}$ 为 从 i 到 j 所有中间结点来自集合 ${\{1,2,\ldots,k\}}$ 的最短路径上 j 的前驱结点则 \pi_{ij}^{(0)} = \begin{cases} nil,\quad i=j \ or \ w_{ij}=\infty \\ i, \quad i\neq j\ and \ w_{ij}]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『数据结构』Fibonacci-heap]]></title>
    <url>%2Ffib-heap.html</url>
    <content type="text"><![CDATA[1. 结构 2. 势函数 3. 最大度数 4. 操作 4.1. 创建一个斐波那契堆 4.2. 插入一个结点 4.3. 寻找最小结点 4.4. 合并两个斐波那契堆 4.5. 抽取最小值 4.6. 关键字减值 4.7. 删除结点 5. 最大度数的证明 1. 结构斐波那契堆是一系列具有最小堆序的有根树的集合, 同一代(层)结点由双向循环链表链接, 为了便于删除最小结点, 还需要维持链表为升序, 即nd&lt;=nd.right(nd==nd.right时只有一个结点或为 None), 父子之间都有指向对方的指针. 结点有degree 属性, 记录孩子的个数, mark 属性用来标记(为了满足势函数, 达到摊还需求的) 还有一个最小值指针 H.min 指向最小根结点 2. 势函数下面用势函数来分析摊还代价, 如果你不明白, 可以看摊还分析 $\Phi(H) = t(H) + 2m(h)$t 是根链表中树的数目,m(H) 表示被标记的结点数 最初没有结点 3. 最大度数结点的最大度数(即孩子数)$D(n)\leqslant \lfloor lgn \rfloor$, 证明放在最后 4. 操作 4.1. 创建一个斐波那契堆$O(1)$ 4.2. 插入一个结点123456789nd = new nodend.prt = nd.chd = Noneif H.min is None: creat H with nd H.min = ndelse: insert nd into H's root list if H.min&lt;nd: H.min = ndH.n +=1 \Delta \Phi = \Delta t(H) + 2\Delta m(H) = 1+0 = 1摊还代价为$O(1)$ 4.3. 寻找最小结点直接用 H.min, $O(1)$ 4.4. 合并两个斐波那契堆12345def union(H1,H2): if H1.min ==None or (H1.min and H2.min and H1.min&gt;H2.min): H1.min = H2.min link H2.rootList to H1.rootList return H1 易知 $\Delta \Phi = 0$ 4.5. 抽取最小值抽取最小值, 一定是在根结点, 然后将此根结点的所有子树的根放在 根结点双向循环链表中, 之后还要进行树的合并. 以使每个根结点的度不同,1234567891011121314def extract-min(H): z = H.min if z!=None: for chd of z: link chd to H.rootList chd.prt = None remove z from the rootList of H if z==z.right: H.min = None else: H.min = z.right consolidate(H) H.n -=1 return z consolidate 函数使用一个 辅助数组degree来记录所有根结点(不超过lgn)对应的度数, degree[i] = nd 表示.有且只有一个结点 nd 的度数为 i.12345678910111213141516171819202122def consolidate(H): initialize degree with None for nd in H.rootList: d = nd.degree while degree[d] !=None: nd2 = degree[d] if nd2.degree &lt; nd.degree: nd2,nd = nd,nd2 make nd2 child of nd nd.degree = d+1 nd.mark = False # to balace the potential remove nd2 from H.rootList degree[d] = None d+=1 else: degree[d] = nd for i in degree: if i!=None: link i to H.rootList if H.min ==None: H.min = i else if H.min&gt;i: H.min = i 时间复杂度为$O(lgn)$ 即数组移动的长度, 而最多有 lgn个元素 4.6. 关键字减值12345678910111213141516171819202122def decrease-key(H,x,k): if k&gt;x.key: error x.key = k y=x.p if y!=None and x.key &lt; y.key: cut(H,x,y) cascading-cut(H,y) if x.key &lt; H.min.key: H.min = xdef cut(H,x,y): remove x from the child list of y, decrementing y.degree add x to H.rootList x.prt = None x.mark = Falsedef cascading-cut(H,y): z- y,prt if z !=None: if y.mark ==False:y.mark = True else: cut(H,y,z) cascading-cut(H,z) 4.7. 删除结点12decrease(H,nd, MIN)extract-min(H) 5. 最大度数的证明这也是斐波那契这个名字的由来,$D(n)\leqslant \lfloor lgn \rfloor$]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『数据结构』B树(B-Tree)及其变体 B+树,B*树]]></title>
    <url>%2Fb-tree.html</url>
    <content type="text"><![CDATA[1. 背景 2. 定义 3. 查找操作 4. 插入操作 5. 删除操作 5.1. 第一种方法 5.2. 第二种方法 6. B+树 7. B*树 8. 代码实现与测试 8.1. 测试 8.2. python 实现 9. 参考资料 从此心里有了B数(●’◡’●) 1. 背景当有大量数据储存在磁盘时,如数据库的查找,插入, 删除等操作的实现, 如果要读取或者写入, 磁盘的寻道, 旋转时间很长, 远大于在 内存中的读取,写入时间. 平时用的二叉排序树搜索元素的时间复杂度虽然是 $O(log_2n)$的, 但是底数还是太小, 树高太高. 所以就出现了 B 树(英文为B-Tree, 不是B减树), 可以理解为多叉排序树. 一个结点可以有多个孩子, 于是增大了底数, 减小了高度, 虽然比较的次数多(关键字数多), 但是由于是在内存中比较, 相较于磁盘的读取还是很快的. 2. 定义度为 d(degree)的 B 树(阶(order) 为 2d) 定义如下, 每个结点中包含有 n 个关键字信息： $(n,P_0,K_1,P_1,K_2,\ldots,K_n,P_n)$。其中： a) $K_i$为关键字,且关键字按顺序升序排序 $K_{i-1}&lt; K_i$ b) $P_i$ 为指向子树根的接点, $K_{i-1}&lt;P(i-1) &lt; Ki$ c) 关键字的数 n 满足(由此也确定了孩子结点的个数): $d-1\leqslant n \leqslant 2d-1$ (根节点可以少于d-1) 树中每个结点最多含有 2d个孩子（d&gt;=2）； 除根结点和叶子结点外,其它每个结点至少有 d个孩子； 若根结点不是叶子结点,则至少有 2 个孩子（特殊情况：没有孩子的根结点,即根结点为叶子结点,整棵树只有一个根节点）； 所有叶子结点都出现在同一层,叶子节点没有孩子和指向孩子的指针 性质:$h\leq \left\lfloor \log _{d}\left({\frac {n+1}{2}}\right)\right\rfloor .$ 如下是 度为2的 B 树, 每个结点可能有2,3或4 个孩子, 所以也叫 2,3,4树, 等价于红黑树 3. 查找操作可以看成二叉排序树的扩展,二叉排序树是二路查找,B - 树是多路查找。节点内进行查找的时候除了顺序查找之外,还可以用二分查找来提高效率。 下面是顺序查找的 python 代码1234567891011121314def search(self,key,withpath=False): nd = self.root fathers = [] while True: i = nd.findKey(key) if i==len(nd): fathers.append((nd,i-1,i)) else: fathers.append((nd,i,i)) if i&lt;len(nd) and nd[i]==key: if withpath:return nd,i,fathers else:return nd,i if nd.isLeafNode(): if withpath:return None,None,None else:return None,None nd = nd.getChd(i) 我实现时让 fathers 记录查找的路径, 方便在实现 delete 操作时使用(虽然有种 delete 方法可以不需要, 直接 from up to down with no pass by), 4. 插入操作自顶向下地进行插入操作, 最终插入在叶子结点,考虑到叶子结点如果有 2t-1 $(k_1,k_2,\ldots,k_{2t-1})$个 关键字, 则需要进行分裂, 一个有 2t-1$(k_1,k_2,\ldots,k_{2t-1})$个关键字 结点分裂是这样进行的: 此结点分裂为 两个关键字为 t-1个的结点, 分别为 $(k_1,k_2,\ldots,k_{t-1})$, $(k_{t+1},k_{t+2},\ldots,k_{2t-1})$, 然后再插入一个关键字$k_t$到父亲结点. 注意同时要将孩子指针移动正确. 所以自顶向下地查找到叶子结点, 中间遇到 2t-1个关键字的结点就进行分裂, 这样如果其子结点进行分裂, 上升来的一个关键字可以插入到父结点而不会超过2t-1 代码如下12345678910111213141516171819def insert(self,key): if len(self.root)== self.degree*2-1: self.root = self.root.split(node(isLeaf=False),self.degree) self.nodeNum +=2 nd = self.root while True: idx = nd.findKey(key) if idx&lt;len(nd) and nd[idx] == key:return if nd.isLeafNode(): nd.insert(idx,key) self.keyNum+=1 return else: chd = nd.getChd(idx) if len(chd)== self.degree*2-1: #ensure its keys won't excess when its chd split and u nd = chd.split(nd,self.degree) self.nodeNum +=1 else: nd = chd 5. 删除操作删除操作是有点麻烦的, 有两种方法1 Locate and delete the item, then restructure the tree to retain its invariants, OR Do a single pass down the tree, but before entering (visiting) a node, restructure the tree so that once the key to be deleted is encountered, it can be deleted without triggering the need for any further restructuring 5.1. 第一种方法有如下情况 删除结点在叶子结点上 结点内的关键字个数大于d-1,可以直接删除（大于关键字个数下限,删除不影响 B - 树特性） 结点内的关键字个数等于d-1（等于关键字个数下限,删除后将破坏 特性）,此时需观察该节点左右兄弟结点的关键字个数：a. 旋转: 如果其左右兄弟结点中存在关键字个数大于d-1 的结点,则从关键字个数大于 d-1 的兄弟结点中借关键字：(这里看了网上的很多说法, 都是在介绍关键字的操作,而没有提到孩子结点. 我实现的时候想了很久才想出来: 借关键字时, 比如从右兄弟借一个关键字(第一个$k_1$), 此时即为左旋, 将父亲结点对应关键字移到当前结点, 再将右兄弟的移动父亲结点(因为要满足排序性质, 类似二叉树的选择) 然后进行孩子操作, 将右兄弟的$p_0$ 插入到 当前结点的孩子指针末尾) 左兄弟类似, 而且要注意到边界条件, 比如当前结点是第0个/最后一个孩子, 则没有 左兄弟/右兄弟) b. 合并: 如果其左右兄弟结点中不存在关键字个数大于 t-1 的结点,进行结点合并：将其父结点中的关键字拿到下一层,与该节点的左右兄弟结点的所有关键字合并同样要注意到边界条件, 比如当前结点是第0个/最后一个孩子, 则没有 左兄弟/右兄弟 自底向上地检查来到这个叶子结点的路径上的结点是否满足关键字数目的要求, 只要关键字少于d-1,则进行旋转(2a)或者合并(2b)操作 删除结点在非叶子结点上 查到到该结点, 然后转化成 上述 叶子结点中情况 转化过程： a. 找到相邻关键字：即需删除关键字的左子树中的最大关键字或右子树中的最小关键字 b. 用相邻关键字来覆盖需删除的非叶子节点关键字,再删除原相邻关键字(在;叶子上,这即为上述情况)。 python 代码如下, delete函数中, 查找到结点, 用 fathers::[(父节点, 关键字指针, 孩子指针)] 记录路径, 如果不是叶子结点, 就再进行查找, 并记录结点, 转换关键字. rebalance 就是从叶子结点自底向上到根结点, 只要遇到关键字数少于 2d-1 的,就进行平衡操作(旋转, 合并) 实现时要很仔细, 考虑边界条件, 还有当是左孩子的时候操作的是父结点的 chdIdx 的前一个, 是右孩子的时候是 chdIdx 的关键字. 具体实现完整代码见文末.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960def delete(self,key):#to do '''search the key, delete it , and form down to up to rebalance it ''' nd,idx ,fathers= self.search(key,withpath=True) if nd is None : return del nd[idx] self.keyNum-=1 if not nd.isLeafNode(): chd = nd.getChd(idx) # find the predecessor key while not chd.isLeafNode(): fathers.append((chd,len(chd)-1,len(chd))) chd = chd.getChd(-1) fathers.append((chd,len(chd)-1,len(chd))) nd.insert(idx,chd[-1]) del chd[-1] if len(fathers)&gt;1:self.rebalance(fathers)def rebalance(self,fathers): nd,keyIdx,chdIdx = fathers.pop() while len(nd)&lt;self.degree-1: # rebalance tree from down to up prt,keyIdx,chdIdx = fathers[-1] lbro = [] if chdIdx==0 else prt.getChd(chdIdx-1) rbro = [] if chdIdx==len(prt) else prt.getChd(chdIdx+1) if len(lbro)&lt;self.degree and len(rbro)&lt;self.degree: # merge two deficient nodes beforeNode,afterNode = None,None if lbro ==[]: keyIdx = chdIdx beforeNode,afterNode = nd,rbro else: beforeNode,afterNode = lbro,nd keyIdx = chdIdx-1 # important, when choosing keys = beforeNode[:]+[prt[keyIdx]]+afterNode[:] children = beforeNode.getChildren() + afterNode.getChildren() isLeaf = beforeNode.isLeafNode() prt.delChd(keyIdx+1) del prt[keyIdx] nd.update(keys,isLeaf,children) prt.children[keyIdx]=nd self.nodeNum -=1 elif len(lbro)&gt;=self.degree: # rotate when only one sibling is deficient keyIdx = chdIdx-1 nd.insert(0,prt[keyIdx]) # rotate keys prt[keyIdx] = lbro[-1] del lbro[-1] if not nd.isLeafNode(): # if not leaf, move children nd.insert(0,nd=lbro.getChd(-1)) lbro.delChd(-1) else: keyIdx = chdIdx nd.insert(len(nd),prt[keyIdx]) # rotate keys prt[keyIdx] = rbro[0] del rbro[0] if not nd.isLeafNode(): # if not leaf, move children #note that insert(-1,ele) will make the ele be the last second one nd.insert(len(nd),nd=rbro.getChd(0)) rbro.delChd(0) if len(fathers)==1: if len(self.root)==0: self.root = nd self.nodeNum -=1 break nd,i,j = fathers.pop() 5.2. 第二种方法这是算法导论2上的 例如 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113B-TREE-DELETE(T,k)1 r ← root[T] 2 if n[r] = 1 3 then DISK_READ(c1[r]) 4 DISK_READ(c2[r]) 5 y ←c1[r] 6 z ←c2[r] 7 if n[y] = n[z] = t-1 ▹ Cases 2c or 3b 8 then B-TREE-MERGE-CHILD(r, 1, y, z) 9 root[T] ← y 10 FREE-NODE(r) 11 B-TREE-DELETE-NONONE(y, k)12 else B-TREE-DELETE-NONONE (r, k)13 else B-TREE-DELETE-NONONE (r, k)考虑到根结点的特殊性,对根结点为1,并且两个子结点都是t-1的情况进行了特殊的处理：先对两个子结点进行合并,然后把原来的根删除,把树根指向合并后的子结点y。这样B树的高度就减少了1。这也是B树高度唯一会减少的情况。 除了这种情况以外,就直接调用子过程 B-TREE-DELETE-NONONE (x, k)。 B-TREE-DELETE-NONONE (x, k)1 i ← 1 2 if leaf[x] ▹ Cases 1 3 then while i &lt;= n[x] and k &gt; keyi[x] 4 do i ← i + 1 5 if k = keyi[x] 6 then for j ← i+1 to n[x] 7 do keyj-1[x] ←keyj[x] 8 n[x] ← n[x] - 1 9 DISK-WRITE(x) 10 else error:”the key does not exist” 11 else while i &lt;= n[x] and k &gt; keyi[x]12 do i ← i + 1 13 DISK-READ(ci[x]) 14 y ←ci[x] 15 if i &lt;= n[x] 16 then DISK-READ(ci+1[x]) 17 z ←ci+1[x] 18 if k = keyi[x] ▹ Cases 219 then if n[y] &gt; t-1 ▹ Cases 2a 20 then k′←B-TREE-SEARCH-PREDECESSOR(y) 21 B-TREE-DELETE-NONONE (y, k′) 22 keyi[x] ←k′ 23 else if n[z] &gt; t-1 ▹ Cases 2b 24 then k′←B-TREE-SEARCH-SUCCESSOR (z) 25 B-TREE-DELETE-NONONE (z, k′) 26 keyi[x] ←k′ 27 else B-TREE-MERGE-CHILD(x, i, y, z)▹ Cases 2c 28 B-TREE-DELETE-NONONE (y, k) 29 else ▹ Cases 3 30 if i &gt;1 31 then DISK-READ(ci-1[x]) 32 p ←ci-1[x] 33 if n[y] = t-1 34 then if i&gt;1 and n[p] &gt;t-1 ▹ Cases 3a 35 then B-TREE-SHIFT-TO-RIGHT-CHILD(x,i,p,y) 36 else if i &lt;= n[x] and n[z] &gt; t-1 ▹ Cases 3a 37 then B-TREE-SHIFT-TO-LEFT-CHILD(x,i,y,z) 38 else if i&gt;1 ▹ Cases 3b 39 then B-TREE-MERGE-CHILD(x, i, p, y) 40 y ← p 41 else B-TREE-MERGE-CHILD(x, i, y, z)▹ Cases 3b 42 B-TREE-DELETE-NONONE (y, k) 转移到右边的子结点B-TREE-SHIFT-TO-RIGHT-CHILD(x,i,y,z)1 n[z] ← n[z] +12 j ← n[z]3 while j &gt; 14 do keyj[z] ←keyj-1[z]5 j ← j -16 key1[z] ←keyi[x]7 keyi[x] ←keyn[y][y]8 if not leaf[z]9 then j ← n[z]10 while j &gt; 011 do cj+1[z] ←cj[z]12 j ← j -113 c1[z] ←cn[y]+1[y]14 n[y] ← n[y] -115 DISK-WRITE(y)16 DISK-WRITE(z)17 DISK-WRITE(x)转移到左边的子结点B-TREE-SHIFT-TO-LEFT-CHILD(x,i,y,z)1 n[y] ← n[y] +12 keyn[y][y] ← keyi[x]3 keyi[x] ←key1[z]4 n[z] ← n[z] -15 j ← 16 while j &lt;= n[z]7 do keyj[z] ←keyj+1[z]8 j ← j +19 if not leaf[z]10 then cn[y]+1[y] ←c1[z]11 j ← 112 while j &lt;= n[z]+113 do cj[z] ←cj+1[z]14 j ← j + 115 DISK-WRITE(y)16 DISK-WRITE(z)17 DISK-WRITE(x) 6. B+树 B+ 树3是 B- 树的变体,与B树不同的地方在于: 非叶子结点的子树指针与关键字个数相同； 非叶子结点的子树指针 $p_i$指向关键字值属于 $[k_i,k_{i+1})$ 的子树（B- 树是开区间）； 为所有叶子结点增加一个链指针； 所有关键字都在叶子结点出现 B+ 的搜索与 B- 树也基本相同,区别是 B+ 树只有达到叶子结点才命中（B- 树可以在非叶子结点命中）,其性能也等价于在关键字全集做一次二分查找；下面摘自 wiki4&gt; 查找查找以典型的方式进行,类似于二叉查找树。起始于根节点,自顶向下遍历树,选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是二分查找来确定这个位置。 插入节点要处于违规状态,它必须包含在可接受范围之外数目的元素。 首先,查找要插入其中的节点的位置。接着把值插入这个节点中。 如果没有节点处于违规状态则处理结束。 如果某个节点有过多元素,则把它分裂为两个节点,每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点,如果根节点被分裂,则创建一个新根节点。为了使它工作,元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。 删除 首先,查找要删除的值。接着从包含它的节点中删除这个值。 如果没有节点处于违规状态则处理结束。 如果节点处于违规状态则有两种可能情况： 它的兄弟节点,就是同一个父节点的子节点,可以把一个或多个它的子节点转移到当前节点,而把它返回为合法状态。如果是这样,在更改父节点和两个兄弟节点的分离值之后处理结束。 它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中,而且我们递归到父节点上,因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点,在其上根节点的子节点被合并而且合并后的节点成为新的根节点。 由于叶子结点间有指向下一个叶子的指针, 便于遍历, 以及区间查找, 所以数据库的以及操作系统文件系统的实现常用 B+树, 7. B*树B-tree 5 是 B+-tree 的变体,在 B+ 树的基础上 (所有的叶子结点中包含了全部关键字的信息,及指向含有这些关键字记录的指针),B 树中非根和非叶子结点再增加指向兄弟的指针；B 树定义了非叶子结点关键字个数至少为 (2/3)M,即块的最低使用率为 2/3（代替 B+ 树的 1/2） 8. 代码实现与测试github地址 8.1. 测试1234567891011121314151617181920212223if __name__ =='__main__': bt = bTree() from random import shuffle,sample n = 20 lst = [i for i in range(n)] shuffle(lst) test= sample(lst,len(lst)//4) print(f'building b-tree with &#123;lst&#125;') for i in lst: bt.insert(i) #print(f'inserting &#123;i&#125;) #print(bt) print(bt) print(f'serching &#123;test&#125;') for i in test: nd,idx = bt.search(i) print(f'node: &#123;repr(nd)&#125;[&#123;idx&#125;]== &#123;i&#125;') for i in test: print(f'deleting &#123;i&#125;') bt.delete(i) print(bt) 8.2. python 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189class node: def __init__(self,keys=None,isLeaf = True,children=None): if keys is None:keys=[] if children is None: children =[] self.keys = keys self.isLeaf = isLeaf self.children = [] def __getitem__(self,i): return self.keys[i] def __delitem__(self,i): del self.keys[i] def __setitem__(self,i,k): self.keys[i] = k def __len__(self): return len(self.keys) def __repr__(self): return str(self.keys) def __str__(self): children = ','.join([str(nd.keys) for nd in self.children]) return f'keys: &#123;self.keys&#125;\nchildren: &#123;children&#125;\nisLeaf: &#123;self.isLeaf&#125;' def getChd(self,i): return self.children[i] def delChd(self,i): del self.children[i] def setChd(self,i,chd): self.children[i] = chd def getChildren(self,begin=0,end=None): if end is None:return self.children[begin:] return self.children[begin:end] def findKey(self,key): for i,k in enumerate(self.keys): if k&gt;=key: return i return len(self) def update(self,keys=None,isLeaf=None,children=None): if keys is not None:self.keys = keys if children is not None:self.children = children if isLeaf is not None: self.isLeaf = isLeaf def insert(self,i,key=None,nd=None): if key is not None:self.keys.insert(i,key) if not self.isLeaf and nd is not None: self.children.insert(i,nd) def isLeafNode(self):return self.isLeaf def split(self,prt,t): # form new two nodes k = self[t-1] nd1 = node() nd2 = node() nd1.keys,nd2.keys = self[:t-1], self[t:] # note that t is 1 bigger than key index nd1.isLeaf = nd2.isLeaf = self.isLeaf if not self.isLeaf: # note that children index is one bigger than key index, and all children included nd1.children, nd2.children = self.children[0:t], self.children[t:] # connect them to parent idx = prt.findKey(k) if prt.children !=[]: prt.children.remove(self) # remove the original node prt.insert(idx,k,nd2) prt.insert(idx,nd = nd1) return prtclass bTree: def __init__(self,degree=2): self.root = node() self.degree=degree self.nodeNum = 1 self.keyNum = 0 def search(self,key,withpath=False): nd = self.root fathers = [] while True: i = nd.findKey(key) if i==len(nd): fathers.append((nd,i-1,i)) else: fathers.append((nd,i,i)) if i&lt;len(nd) and nd[i]==key: if withpath:return nd,i,fathers else:return nd,i if nd.isLeafNode(): if withpath:return None,None,None else:return None,None nd = nd.getChd(i) def insert(self,key): if len(self.root)== self.degree*2-1: self.root = self.root.split(node(isLeaf=False),self.degree) self.nodeNum +=2 nd = self.root while True: idx = nd.findKey(key) if idx&lt;len(nd) and nd[idx] == key:return if nd.isLeafNode(): nd.insert(idx,key) self.keyNum+=1 return else: chd = nd.getChd(idx) if len(chd)== self.degree*2-1: #ensure its keys won't excess when its chd split and u nd = chd.split(nd,self.degree) self.nodeNum +=1 else: nd = chd def delete(self,key):#to do '''search the key, delete it , and form down to up to rebalance it ''' nd,idx ,fathers= self.search(key,withpath=True) if nd is None : return del nd[idx] self.keyNum-=1 if not nd.isLeafNode(): chd = nd.getChd(idx) # find the predecessor key while not chd.isLeafNode(): fathers.append((chd,len(chd)-1,len(chd))) chd = chd.getChd(-1) fathers.append((chd,len(chd)-1,len(chd))) nd.insert(idx,chd[-1]) del chd[-1] if len(fathers)&gt;1:self.rebalance(fathers) def rebalance(self,fathers): nd,keyIdx,chdIdx = fathers.pop() while len(nd)&lt;self.degree-1: # rebalance tree from down to up prt,keyIdx,chdIdx = fathers[-1] lbro = [] if chdIdx==0 else prt.getChd(chdIdx-1) rbro = [] if chdIdx==len(prt) else prt.getChd(chdIdx+1) if len(lbro)&lt;self.degree and len(rbro)&lt;self.degree: # merge two deficient nodes beforeNode,afterNode = None,None if lbro ==[]: keyIdx = chdIdx beforeNode,afterNode = nd,rbro else: beforeNode,afterNode = lbro,nd keyIdx = chdIdx-1 # important, when choosing keys = beforeNode[:]+[prt[keyIdx]]+afterNode[:] children = beforeNode.getChildren() + afterNode.getChildren() isLeaf = beforeNode.isLeafNode() prt.delChd(keyIdx+1) del prt[keyIdx] nd.update(keys,isLeaf,children) prt.children[keyIdx]=nd self.nodeNum -=1 elif len(lbro)&gt;=self.degree: # rotate when only one sibling is deficient keyIdx = chdIdx-1 nd.insert(0,prt[keyIdx]) # rotate keys prt[keyIdx] = lbro[-1] del lbro[-1] if not nd.isLeafNode(): # if not leaf, move children nd.insert(0,nd=lbro.getChd(-1)) lbro.delChd(-1) else: keyIdx = chdIdx nd.insert(len(nd),prt[keyIdx]) # rotate keys prt[keyIdx] = rbro[0] del rbro[0] if not nd.isLeafNode(): # if not leaf, move children #note that insert(-1,ele) will make the ele be the last second one nd.insert(len(nd),nd=rbro.getChd(0)) rbro.delChd(0) if len(fathers)==1: if len(self.root)==0: self.root = nd self.nodeNum -=1 break nd,i,j = fathers.pop() def __str__(self): head= '\n'+'-'*30+'B Tree'+'-'*30 tail= '-'*30+'the end'+'-'*30+'\n' lst = [[head],[f'node num: &#123;self.nodeNum&#125;, key num: &#123;self.keyNum&#125;']] cur = [] ndNum =0 ndTotal= 1 que = [self.root] while que!=[]: nd = que.pop(0) cur.append(repr(nd)) ndNum+=1 que+=nd.getChildren() if ndNum==ndTotal: lst.append(cur) cur = [] ndNum = 0 ndTotal =len(que) lst.append([tail]) lst = [','.join(li) for li in lst] return '\n'.join(lst) def __iter__(self,nd = None): if nd is None: nd = self.root que = [nd] while que !=[]: nd = que.pop(0) yield nd if nd.isLeafNode():continue for i in range(len(nd)+1): que.append(nd.getChd(i)) 9. 参考资料 1. B树 &#8617; 2. 算法导论 &#8617; 3:B - 树特征及插入删除操作总结 4. B+树 &#8617; 5. 从 B 树、B + 树、B * 树谈到 R 树 &#8617;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>B树</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『比特币』概述]]></title>
    <url>%2Fintroduction-to-bitcoin.html</url>
    <content type="text"><![CDATA[本文整理自&lt;&lt;精通比特币&gt;&gt;** 1. 概述 1.1. 钱包地址 1.2. 交易链 1.3. 找零 1.4. 钱包 1.5. 挖矿的作用 2. bitcoin core 客户端 3. 密钥与地址 3.1. 公钥加密 3.2. 椭圆曲线乘法 3.3. 生成公钥 3.4. 生成比特币地址 3.5. 公钥格式 3.6. 私钥格式 3.7. 高级密钥和地址 3.7.1. 加密私钥 3.7.2. P2SH(Pay-to-Script Hash) 3.8. 纸钱包 4. 钱包 4.1. 钱包种类 4.1.1. 非确定性钱包(nondeterministic wallet) 4.1.2. 确定性钱包(deterministic wallet) 4.2. HD钱包 4.3. 种子和助记词 4.3.1. 创建助记词 4.3.2. 从助记词得到种子 4.4. 可选密码短语 4.4.1. 功能 4.4.2. 风险 4.5. 从种子中创造 HD 钱包 4.5.1. 私有子密钥的衍生更 4.5.2. 扩展密钥 4.5.3. 公共子密钥的推导 4.5.4. 硬化子密钥的衍生 4.5.5. 索引号码 4.5.6. 钱包密钥识别符(路径) 4.5.7. HD钱包树状结构的导航 5. 交易 5.1. UTXO 5.2. 币基交易(CoinbaseTransaction) 5.3. 交易输出 5.4. 交易输入 5.5. 交易过程 5.6. 交易费 5.7. 交易脚本语言 5.7.1. 图灵非完备性 5.7.2. 去中心化验证 5.7.3. 脚本构建(锁定与解锁) 5.7.3.1. 锁定脚本(Locking Script) 5.7.3.2. 解锁脚本(Unlocking Script) 5.8. 数字签名(ECDSA) 5.8.1. 如何工作 5.8.2. 作用 5.8.3. 创建与验证 5.8.4. 签名序列化(DER) 5.8.5. 签名哈希类型(SIGHASH) 6. 高级交易和脚本 6.1. 多重签名 6.2. P2SH(Pay-to-Script-Hash) 6.2.1. 多重签名的问题 6.2.2. 赎回脚本 6.2.3. P2SH地址 6.2.4. 优点 6.3. 数据记录输出(RETURN操作符) 6.4. 时间锁(Timelocks) 6.4.1. 检查锁定时间验证CheckLockTimeVerify(CLTV) 6.4.2. 相对时间锁 6.4.2.1. nSequence 6.4.2.2. CHECKSEQUENCEVERIFY(CSV) 6.4.3. Median-Time-Past 6.5. 条件子句(Conditional Clauses) 7. P2P 网络架构 7.1. 扩展比特币网络 7.2. 网络发现 7.3. 同步区块链 7.4. 简单支付验证(SPV) 7.5. Bloom filter 7.6. SPV 节点如何使用 Bloom filter 7.7. 加密和认证连接 7.8. 交易池 8. 区块链 9. 挖矿与共识 9.1. 交易验证 9.2. coinbase交易(创币交易) 9.3. 构造区块头 9.4. 校验新区块 9.5. 构建区块 9.6. 区块链的组装与选择 9.7. 矿池 9.7.1. 矿工加入 9.7.2. 托管矿池 9.7.3. P2P矿池 9.8. 共识攻击 9.9. 分叉 9.9.1. 硬分叉 9.9.2. 软分叉 10. 比特币安全 10.1. 安全准则 10.2. 比特币系统安全开发 10.3. 信任根(ROOT-OF-TRUST) 1. 概述每一笔交易可以分为 输入, 输出, 其他输入&gt;=输出+其他(奖励给矿工),而输入的比特币需要引用其来源(它作为上次交易的输出),称UTXO.而且每笔交易作为输入不能分割. 1.1. 钱包地址新生成的钱包, 即未交易过的比特币地址对于比特币网络来说是不知道的，或者是未经注册到比特币系统中。它只是一个数字，对应于一个可以用来控制资金访问的密钥。由钱包独立生成的，还没有参考或注册任何服务。事实上，在大多数钱包中，比特币地址和任何外部可识别的信息(包括用户的身份)之间没有关联。在该地址被引用作为比特币总帐的交易中的接收者之前，比特币地址只是在比特币中有效的大量可能的地址的一部分。只有一旦与交易相关联才能成为网络中已知地址的一部分。 1.2. 交易链 1.3. 找零许多比特币交易都会包括新所有者的地址(买方地址)和当前所有者的地址(称为找零地址)的输出。这是因为交易输入，就像纸币那样能够，不能再分割。如果您在商店购买了5美元的商品，但是使用20美元的美金来支付商品，您预计会收到15美元的找零。 相同的概念适用于比特币交易输入。如果您购买了一个价格为5比特币但只能使用20比特币输入的商品，那么您可以将5个比特币的一个输出发送给商店所有者，并将一个15比特币的输出返回给您自己作为找零(减去任何适用的交易费用)。重要的是，找零地址不必与输入时提供的地址相同，出于隐私的原因，通常是所有者钱包中的新地址。 另外还有其他模式, 比如有一把零钱, 凑在一起,支付一次还有就是一次有很大一笔钱, 分给很多人.如下图所示 1.4. 钱包钱包应用可以在完全离线时建立交易。就像在家里写张支票， 之后放到信封发给银行一样，比特币交易建立和签名时不用连接比特币网络。只有在执行交易时才需要将交易发送到网络。 1.5. 挖矿的作用 挖矿节点通过参考比特币的共识规则验证所有交易。 因此，挖矿通过拒绝无效或畸形交易来提供比特币交易的安全性。 挖矿在构建区块时会创造新的比特币，和一个中央银行印发新的纸币很类似。每个区块创造的比特币数量是固定的， 随时间会渐渐减少 2. bitcoin core 客户端 下载 123$ git clone$ git tag$ git checkout TAG 检查./autogen.sh 配置 1234./configure--with-gui=no \-with-incompatible-bdb \-prefix=$HOME \ 编译 12makesudo make install 测试是否成功 12$ which bitcoind #/usr/local/bin/bitcoind$ whic bitcoin-cli #/usr/local/bitcoin-cli 设置 API 访问的密码(首次运行):编辑bitcoin/bitcoin.conf 内容如下. rpc 即 remote procedure call 12rpcuser=bitcoinrpcrpcpassword=... 启动守护进程后台运行 ,$ bitcoind -daemon 监视状态$ bitcoin-cli getinfo RPC 1234567891011$ bitcoin-cli getinfo #return json$ bitcoin-cli getrawtransaction txid #return hash-cont$ bitcoin-cli decoderawransaction hash-cont #ret json$ bitcoin-cli gettransaction txid # json$ bitcoin-cli getblockhash bloack-id # ret block-hash$ bitcoin-cli getblock block-hash #ret json$ bitcoin-cli getnewaddress # ret 64位 十六进制的数 addr 公钥$ bitcoin-cli dumpprivkey addr # ret 私钥 3. 密钥与地址 3.1. 公钥加密 3.2. 椭圆曲线乘法比特币使用 secp256k1标准定义的一种特殊的椭圆曲线和一系列常数secp256k1: y^2=(x^3+7) mod (p)其中 $p=2^{256}-2^{32}-2^9-2^8-2^7-2^6-2^4-1$为素数 无穷远点: 对应于 加法中的 0 , x=y=0(虽然不满足曲线方程,但可作为特殊情况进行检验) 椭圆曲线加法: 两个点 p1,p2的加法p1+p2 得到一个点 p3, 记 p3’(x,y) 是 直线p1p2与椭圆曲线不同于p1,p2的交点, 则 p3(x,-y)注意p1=p2时, 直线p1p2定义为p1处的切线 椭圆曲线乘法: $kP = P+P+\ldots+P(k\ times)$ 3.3. 生成公钥随机数私钥 k,取椭圆曲线上的一点 G, 称为生成点,公钥 $K = kG$, 注意是 mod p 的域内这个过程是不可逆的 3.4. 生成比特币地址 增加位权减少长度 Base64: 26个小写字母、26个大写字母、10个数字以及两个符号(例 如“+”和“/”)， Base58: 不包括(0，O，l，I)的大小写字母和数字组成。3.5. 公钥格式一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，知道了公钥的x坐标,通过解方程y^2 \ mod \ p =(x^3+7)\ mod\ p得到y坐标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256比特。 使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号 压缩格式公钥和非压缩格式公钥看起来不同,但是对应着同样的一个私钥。更重要的是，如果我们使用双哈希函数(RIPEMD160(SHA256(K)))将压缩格式公钥转化成比特币地址，得到的地址将会不同于由非压缩格式公钥产生的地址。这种结果会让人迷惑，因为一个私钥可以生成两种不同格式的公钥——压缩格式和非压缩格式，而这两种格式的公钥可以生成两个不同的比特币地址。但是，这两个不同的比特币地址的私钥是一样的。 3.6. 私钥格式当一个私钥被使用WIF压缩格式导出时，不但没有压缩，而且比“非压缩格式”私钥长出一个字节。这个多出来的一个字节是私钥被加了后缀01，用以表明该私钥是来自于一个较新的钱包， 只能被用来生成压缩的公钥。私钥是非压缩的，也不能被压缩。“压缩的私钥”实际上只是表示“用于生成压缩格式公钥的私钥”，而“非压缩格式私钥”用来表明“用于生成非压缩格式公钥的私钥”。 十六进制压缩私钥格式在末尾有一个额外的字节(十六进制为01)。虽然Base58编码版本前缀对于WIF和WIF压缩格式都是相同的(0x80)，但在数字末尾添加一个字节会导致Base58编码的第一个字符从5变为K或 L，考虑到对于Base58这是十进制编码100号和99号之间的差别。对于100是一个数字长于99的数字，它有一个前缀1，而不是前缀9。当长度变化，它会影响前缀。 在Base58中，前缀5改变为K或L，因为数字的长度增加一个字节。 要注意的是，这些格式并不是可互换使用的。在实现了压缩格式公钥的较新的钱包中，私钥只能且永远被导出为WIF压 缩格式(以K或L为前缀)。对于较老的没有实现压缩格式公钥的钱包，私钥将只能被导出为WIF格式(以5为前缀)导 出。这样做的目的就是为了给导入这些私钥的钱包一个信号：是否钱包必须搜索区块链寻找压缩或非压缩公钥和地址。 最全面的比特币Python库是 Vitalik Buterin写的 pybitcointools 3.7. 高级密钥和地址 3.7.1. 加密私钥 加密标准— BIP0038: 使用一个口令加密私钥并使用Base58Check对加密的私钥进行编码，这样加密的私钥就可以安全地保存在备份介质里，安全地在钱包间传输，保持密钥在任何可能被暴露情况下的安全性。(使用了 AES) BIP0038加密方案：输入一个比特币私钥，通常使用WIF编码过，base58chek字符串的前缀“5”。此外BIP0038加密方案需要一个长密码作为口令，通常由多个单词或一段复杂的数字字母字符串组成。BIP0038加密方案的结果是一个由 base58check编码过的加密私钥，前缀为6P。如果你看到一个6P开头的的密钥，这就意味着该密钥是被加密过，并需要一个口令来转换(解码)该密钥回到可被用在任何钱包WIF格式的私钥(前缀为5) 3.7.2. P2SH(Pay-to-Script Hash)以数字3开头的比特币地址是P2SH地址，有时被错误的称谓多重签名或多重签名地址。他们指定比特币交易中受益人为哈希的脚本，而不是公钥的所有者 不同于P2PKH交易发送资金到传统1开头的比特币地址，资金被发送到3开头的地址时，需要的不仅仅是一个公钥的哈希值和一个私钥签名作为所有者证明。在创建地址的时候，这些要求会被指定在脚本中，所有对地址的输入都会被这些要求阻隔。 一个P2SH地址从交易脚本中创建，它定义谁能消耗这个交易输出script hash =RIPEMD160(SHA256(script)) 产生的脚本哈希由Base58Check编码前缀为5的版本、编码后得到开头为3的编码地址 P2SH函数最常见的实现是多重签名地址脚本。顾名思义，底层脚本需要多个签名来证明所有权，此后才能消费资金。设计比特币多重签名特性是需要从总共N个密钥中需要M个签名(也被称为“阈值”)，被称为M-N多签名，其 中M是等于或小于N。例如，第一章中提到的咖啡店主Bob使用多重签名地址需要1-2签名，一个是属于他的密钥和一个属于他同伴的密钥，以确保其中一方可以签署消费一笔锁定到这个地址的输出。这类似于传统的银行中的一个“联合账户”，其中任何一方配偶可以单独签单消费。 3.8. 纸钱包将公钥和私钥(可以是加密过的)打印在纸上, 这期间都没有经过网络(直接用算法计算出), 所以又被称为冷钱包. 4. 钱包广义上，钱包是一个应用程序，为用户提供交互界面。钱包控制用户访问权限，管理密钥和地址，跟踪余额以及创建和签名交易。 狭义上，即从程序员的角度来看，“钱包”是指用于存储和管理用户密钥的数据结构。 一个常见误解是，比特币钱包里含有比特币。 事实上，钱包里只含有钥匙。 “钱币”被记录在比特币网络的区块链中。 用户通过钱包中的密钥签名交易，从而来控制网络上的钱币。 在某种意义上，比特币钱包是密钥链。 4.1. 钱包种类每个用户有一个包含多个密钥的钱包。根据包含的多个密钥是否相互关联,可以分为两类 4.1.1. 非确定性钱包(nondeterministic wallet)其中每个密钥都是从随机数独立生成的。密钥彼此无关。这种钱包也被称为“Just a Bunch Of Keys(一堆密钥)”，简称 JBOK 钱包。 4.1.2. 确定性钱包(deterministic wallet)其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子(seed)。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。确定性钱包中使用了许多不同的密钥推导方法。最常用的推导方法是使用树状结构，称为分级确定性钱包或HD钱包。 4.2. HD钱包HD钱包包含以树状结构衍生的密钥 优点: 树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门、子公司、具体功能以及会计类别。 允许使用者去建立一个公共密钥的序列而不需要访问相对应的私钥。这可允许HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公共钥匙。公共钥匙不需要被预先加载或者提前衍生，而在服务器中不需要可用来支付的私钥。 4.3. 种子和助记词由一系列英文单词生成种子是个标准化的方法，这样易于在钱包中转移、导出和导入。这些英文单词被称为助记词，标准由BIP-39定义 4.3.1. 创建助记词助记词是由钱包使用BIP-39中定义的标准化过程自动生成的。 钱包从熵源开始，增加校验和，然后将熵映射到单词列表：1、创建一个128到256位的随机序列(熵)。2、提出SHA256哈希前几位(熵长/ 32)，就可以创造一个随机序列的校验和。3、将校验和添加到随机序列的末尾。4、将序列划分为包含11位的不同部分。5、将每个包含11位部分的值与一个已经预先定义2048个单词的字典做对应。6、生成的有顺序的单词组就是助记码。 4.3.2. 从助记词得到种子助记词表示长度为128至256位的熵。 通过使用密钥延伸函数PBKDF2，熵被用于导出较长的(512位)种子。将所得的种子用于构建确定性钱包并得到其密钥。密钥延伸函数有两个参数：助记词和盐。其中盐的目的是增加构建能够进行暴力攻击的查找表的困难度。 7、PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记符。8、PBKDF2密钥延伸函数的第二个参数是盐。 由字符串常数“助记词”与可选的用户提供的密码字符串连接组成。9、PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记符和盐参数，产生一个512位的值作为其最终输出。 这个512位的值就是种子。密钥延伸函数，使用2048次哈希是一种非常有效的保护，可以防止对助记词或密码短语的暴力攻击。 它使得攻击尝试非常昂贵(从计算的角度)，需要尝试超过几千个密码和助记符组合，而这样可能产生的种子的数量是巨大的(2^512)。 4.4. 可选密码短语BIP-39标准允许在推导种子时使用可选的密码短语。 如果没有使用密码短语，助记词是用由常量字符串“助记词”构成的盐进行延伸，从任何给定的助记词产生一个特定的512位种子。 如果使用密码短语，密钥延伸函数使用同样的助记词也会产生不同的种子。 BIP-39中没有“错误的”密码短语。 每个密码都会导致一些钱包，只是未使用的钱包是空的。 4.4.1. 功能 (存储在大脑中的)密码短语成为第二个因素，使得助记词不能单独使用，避免了助记词备份盗取后被利用。 起到掩人耳目的效果，把密码短语指向有小额资金的钱包，分散攻击者注意力，使其不在关注拥有大额资金的“真实”钱包。 4.4.2. 风险如果钱包所有者无行为能力或死亡，没有人知道密码，种子是无用的，所有存储在钱包中的资金都将永远丢失。相反，如果所有者将密码短语与种子备份在相同的地方，则违反了上述第二个因素的目的。虽然密码是非常有用的，但它们只能与仔细计划的备份和恢复流程结合使用，考虑到所有者个人风险的可能性，应该允许其家人恢复加密资产。 4.5. 从种子中创造 HD 钱包 4.5.1. 私有子密钥的衍生分层确定性钱包使用CKD(child key derivation)函数去从母密钥衍生出子密钥。子密钥衍生函数是基于单项哈希函数。这个函数结合了： 一个母私钥或者公共钥匙(ECDSA未压缩键) 一个叫做链码(256 bits)的种子 一个索引号(32 bits) 链码是用来给这个过程引入确定性随机数据的，使得索引不能充分衍生其他的子密钥。因此，有了子密钥并不能让它发现自己的姊妹密钥，除非你已经有了链码。最初的链码种子(在密码树的根部)是用随机数据构成的，随后链码从各自的母链码中衍生出来。 母公共钥匙——链码——以及索引号合并在一起并且用HMAC-SHA512函数散列之后可以得到512位的散列。所得的散列可被拆分为两部分。散列右半部分的256位产出可以给子链当链码。左半部分256位散列以及索引码被加载在母私钥上来衍生子私钥。 如上图 改变索引可以让我们延长母密钥以及创造序列中的其他子密钥。比如子0，子1，子2等等。每一个母密钥可以有2,147,483,647 (2^31) 个子密钥。2^31是整个2^32范围可用的一半，因为另一半是为特定类型的推导而保留的. 如下则是扩展母公钥来衍生子公钥的传递机制。 4.5.2. 扩展密钥密钥以及链码的结合，就叫做扩展密钥(extended key). 可以简单地被储存并且表示为简单的将256位密钥与256位链码所并联的512位序列。 扩展密钥通过Base58Check来编码，从而能轻易地在不同的BIP-32兼容钱包之间导入导出。扩展密钥编码用的 Base58Check使用特殊的版本号，这导致在Base58编码字符中，出现前缀“xprv”和“xpub”。 4.5.3. 公共子密钥的推导分层确定性钱包的一个很有用的特点就是可以不通过私钥而直接从公共母密钥派生出公共子密钥的能 力。所以有两种衍生子公钥的方法：通过子私钥，或者就是直接通过母公钥。 因此，扩展密钥可以在HD钱包结构的分支中，被用来衍生所有的公钥(且只有公钥)。 应用: 用来创造非常保密的只有公钥配置。在配置中，服务器或者应用程序不管有没有私钥，都可以有扩展公钥的副本。这种配置可以创造出无限数量的公钥以及比特币地址。但是发送到这个地址里的任何比特币都不能使用。与此同时，在另一种更保险的服务器上，扩展私钥可以衍生出所有的对应的可签署交易以及花钱的私钥。 扩展的私钥可以被储存在纸质钱包中或者硬件设备中(比如 Trezor 硬件钱包)，与此同时扩展公钥可以在线保存。根据意愿创造“接收”地址而私钥可以安全地在线下被保存。为了支付资金，使用者可以使用扩展的私钥离线签署比特币客户或者通过硬件钱包设备(比如 Trezor)签署交易。 这种方案的常见应用是安装扩展公钥电商的网络服务器上。网络服务器可以使用这个公钥衍生函数去给每一笔交易(比如客户的购物车)创造一个新的比特币地址。但为了避免被偷，网络服务商不会有任何私钥。没有HD钱包的话，唯一的方法就是在不同的安全服务器上创造成千上万个比特币地址，之后就提前上传到电商服务器上。这种方法比较繁琐而且要求持续的维护来确保电商服务器不“用光”公钥。 4.5.4. 硬化子密钥的衍生访问扩展公钥并不能得到访问子私钥的途径。但是，因为扩展公钥包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥 为了应对这种风险，HD钱包使用一种叫做硬化衍生(hardened derivation)的替代衍生函数。 这就“打破”了母公钥以及子链码之间的关系。这个硬化衍生函数使用了母私钥去推导子链码，而不是母公钥。这就在母/子顺序中创造了一道“防火墙”——有链码但并不能够用来推算子链码或者姊妹私钥。强化衍生函数看起来几乎与一般的衍生的子私钥相同，不同的是母私钥被用来输入散列函数中而不是母公钥， 4.5.5. 索引号码用在衍生函数中的索引号码是32位的整数。为了区分密钥是从正常衍生函数中衍生出来还是从强化衍生函数中产出，这个索引号被分为两个范围。索引号在0和2^31–1(0x0 to0x7FFFFFFF)之间的是只被用在常规衍生。索引号在2^31和2^32– 1(0x80000000 to 0xFFFFFFFF)之间的只被用在强化衍生。 4.5.6. 钱包密钥识别符(路径)HD钱包中的密钥是用“路径”命名的，且每个级别之间用斜杠(/)字符来表示。由主私钥衍生出的私钥起始以“m”打头。由主公钥衍生的公钥起始以“M“打头。因此，母密钥生成的第一个子私钥是m/0。第一个公钥是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。 4.5.7. HD钱包树状结构的导航HD钱包树状结构提供了极大的灵活性。每一个母扩展密钥有40亿个子密钥：20亿个常规子密钥和20亿个强化子密钥。 而每个子密钥又会有40亿个子密钥并且以此类推。 由此带来问题,对无限的树状结构进行导航就变得异常困难。尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及亚分支的可能性是无穷的。 两个比特币改进建议(BIPs) 通过创建几个HD钱包树的提议标准。BIP-43提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”。 基于BIP-43，HD钱包应该使用且只用第一层级的树的分支，而且有索引号码去识别结构并且有命名空间来定义剩余的树的目的地。举个例子，HD钱包只使用分支m/i’/是 为了表明那个被索引号“i”定义的特殊为目地。 BIP-44指定了包含5个预定义树状层级的结构：m / purpose&#39; / coin_type&#39; / account&#39; / change / address_index 第一层的purpose总是被设定为44’。 第二层的“coin_type”特指币种并且允许多元货币HD钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义：Bitcoin is m/44’/0’、Bitcoin Testnet is m/44’/1’，以及 Litecoin is m/44’/2’。 第三层级是“account”，举个例子，一个HD钱包可能包含两个比特币“账户”：m/44’/0’/0’和 m/44’/0’/1’。每个账户都是它自己亚树的根。 第四层级就是“change”。注意无论先前的层级是否使用强化衍生，这一层级使用的都是常规衍生。这是为了允许这一层级的树可以在不安全环境下，输出扩展公钥。 被HD钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的“address_index” 如 5. 交易根据比特币系统的设计原理，系统中任何其他的部分都是为了确保比特币交易可以被生成、能在比特币网络中得以传播和通过验证，并最终添加入全球比特币交易总账簿(比特币区块链)。比特币交易的本质是数据结构，这些数据结构中含有比特币交易参与者价值转移的相关信息。比特币区块链是一本全球复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。 5.1. UTXO比特币交易中的基础构建单元是交易输出。 交易输出是比特币不可分割的基本组合，记录在区块上，并被整个网络识别为有效。 比特币完整节点跟踪所有可找到的和可使用的输出，称为 “未花费的交易输出”(unspent transaction outputs)，即UTXO。所有UTXO的集合被称为UTXO集。每一个交易都代表UTXO集的变化(状态转换)。 用户的比特币“余额”是指用户钱包中可用的UTXO总和. 比特币钱包通过扫描区块链并聚集所有属于该用户的UTXO来计算该用户的余额 。大多数钱包维护一个数据库或使用数据库服务来存储所有UTXO的快速参考集，这些UTXO由用户所有的密钥来控制花费行为。 一个UTXO只能在一次交易中作为一个整体被消耗。一定数量的比特币价值在不同所有者之间转移，并在交易链中消耗和创建UTXO。一笔比特币交易通过使用所有者的签名来解锁UTXO，并通过使用新的所有者的比特币地址来锁定并创建UTXO 5.2. 币基交易(CoinbaseTransaction)它是每个区块中的第一笔交易，这种交易存在的原因是作为对挖矿的奖励，创造出全新的可花费比特币用来支付给“赢家”矿工。 输入和输出，哪一个是先产生的呢？先有鸡还是先有蛋呢？严格来讲，先产生输出，因为可以创造新比特币的 “币基交易”没有输入，但它可以无中生有地产生输出。 5.3. 交易输出交易输出包含两部分： 一定量的比特币，面值为“聪”(satoshis),是最小的比特币单位； 确定花费输出所需条件的加密难题(cryptographic puzzle) 这个加密难题也被称为锁定脚本(locking script), 见证脚本(witness script), 或脚本公钥(scriptPubKey)。 如下面的交易包含两个输出,每个输出包含 比特币的值(本身编码是以聪为单位, 以json解码后单位是 比特币), 以及锁定脚本12345678910111213"vout": [truetrue&#123;truetruetruetrue"value": 0.01500000,truetruetruetrue"scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFYOP_CHECKSIG"truetrue&#125;,truetrue&#123;truetruetruetrue"value": 0.08450000,truetruetruetrue"scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",truetrue&#125;] 5.4. 交易输入包含 一个指向UTXO的指针，通过指向UTXO被记录在区块链中所在的交易的哈希值和序列号来实现。 解锁脚本，钱包构建它用以满足设定在UTXO中的支出条件。 大多数情况下，解锁脚本是一个证明比特币所有权的数字签名和公钥，但是并不是所有的解锁脚本都包含签名。 序列号。 如下面的交易包含一个输入 txid: 引用的 UTXO 交易, vout(输出索引) : 标识来自txid的交易的哪个输出被引用(0-indexed) scriptSig(解锁脚本): 满足放置在 UTXO 上的条件,解锁它用于支出 sequence: 序列号 1234567891011"vin": [truetrue&#123;truetruetruetrue"txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",truetruetruetrue"vout": 0,truetruetruetrue"scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",truetruetruetrue"sequence": 4294967295truetrue&#125;] 5.5. 交易过程首先检索引用的UTXO，检查其锁定脚本，然后使用它来构建所需的解锁脚本以满足此要求。 除了对包含它引用的交易之外，我们无从了解这个UTXO的任何内容。我们不知道它的价值(多少satoshi金额)，我们不知道设置支出条件的锁定脚本。要找到这些信息，我们必须通过检索整个交易来检索被引用的UTXO。 然后运行解锁脚本与锁定脚本, 检查结果是否为True 5.6. 交易费大多数交易包含交易费(矿工费)，这是为了确保网络安全而给比特币矿工的一种补偿。费用本身也作为一个安全机制，使经济上不利于攻击者通过交易来淹没网络。 大多数钱包自动计算并计入交易费。但是， 如果你以编程方式构造交易，或者使用命令行界面，你必须手动计算并计入这些费用。 任何创建交易的比特币服务，包括钱包，交易所，零售应用等，都必须实现动态收费。动态费用可以通过第三方费用估算服务或内置的费用估算算法来实现 费用估算算法根据网络能力和“竞争”交易提供的费用计算适当的费用。大多数服务为用户提供高、中、低优先费用的选择。高优先级意味着用户支付更高交易费. 交易费即输入总和减输出总和的余量：交易费 = 求和(所有输入) - 求和(所有输出) 如果你忘记了在手动构造的交易中增加找零的输出，系统会把找零当作交易费来处理。“不用找了！”也许不是你的真实意愿。 一般交易费是根据交易的数据正相关的, 而不是交易的比特币值,所以如果有很多个 输入(很多个 UTXO 零钱), 或很多输出, 造成数据量很大, 而使交易费很多. 5.7. 交易脚本语言 5.7.1. 图灵非完备性有条件的流控制以外，没有循环或复杂流控制能力。这限制确保该语言不被用于创造无限循环或其它类型的逻辑炸弹，这样的炸弹可以植入在一笔交易中，引起针对比特币网络的“拒绝服务”攻击。因为每一笔交易都会被网络中的全节点验证，受限制的语言能防止交易验证机制被作为一个漏洞而加以利用。 5.7.2. 去中心化验证没有任何中心主体能凌驾于脚本之上，也没有中心主体会在脚本被执行后对其进行保存。所以执行脚本所需信息都已包含在脚本中。一个脚本能在任何系统上以相同的方式执行。 5.7.3. 脚本构建(锁定与解锁) 5.7.3.1. 锁定脚本(Locking Script)一个放置在输出上面的花费条件.它指定了今后花费这笔输出必须要满足的条件。曾被称为脚本公钥(scriptPubKey) , 也被称为见证脚本(witness script)，或者更一般地说，它是一个加密难题(cryptographic puzzle)。这些术语在不同的抽象层次上都意味着同样的东西。 5.7.3.2. 解锁脚本(Unlocking Script)一个“解决”或满足被锁定脚本在一个输出上设定的花费条件,从而允许输出被消费的脚本。解锁脚本是每一笔比特币交易输入的一部分，而且往往含有一个由用户的比特币钱包(通过用户的私钥)生成的数字签名,曾被称作ScriptSig。 每一个比特币验证节点会通过同时执行锁定和解锁脚本来验证一笔交易。每个输入都包含一个解锁脚本，并引用了之前存在的UTXO。 验证软件将复制解锁脚本，检索输入所引用的UTXO，并从该UTXO复制锁定脚本。 然后依次执行解锁和锁定脚本。如果解锁脚本满足锁定脚本条件，则输入有效。所有输入都是独立验证的，作为交易总体验证的一部分。 形式上两个脚本拼接如下, 如后用栈的方式执行, 右边为栈顶. 最终结果为 TRUE 则 满足条件 如锁定脚本: 3 OP_ADD 5 OP_EQUAL解锁脚本: 2拼接后为: 2 3 OP_ADD 5 OP_EQUAL 实际过程使用堆栈执行引擎执行解锁脚本。如果解锁脚本在执行过程中未报错(例如：没有“悬挂”操作码)，则复制主堆栈(而不是备用堆栈)，并执行锁定脚本。如果从解锁脚本中复制而来的堆栈数据执行锁定脚本的结果为“TRUE”，那么解锁脚本就成功地满足了锁定脚本所设条件 如锁定脚本: OP_DUP OP_HASH160 &lt;Cafe Public Key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG解锁脚本: &lt;Cafe Signature&gt; &lt;Cafe Public Key&gt;验证过程 5.8. 数字签名(ECDSA) 5.8.1. 如何工作 使用私钥(签名密钥)从消息(交易)创建签名 给定消息和公钥允许任何人验证签名 5.8.2. 作用数字签名在不揭示私钥的情况下提供私钥的所有权证明。 数字签名在比特币中的作用: 签名证明私钥的所有者，即资金所有者，已经授权支出这些资金。 授权证明是不可否认的(不可否认性)。 签名证明交易(或交易的具体部分)在签字之后没有也不能被任何人修改。 每个交易输入和它可能包含的任何签名完全独立于任何其他输入或签名。多方可以协作构建交易，并各自仅签一个输入。 5.8.3. 创建与验证公钥是一个二维数组, 图形上是一个点 比特币中使用的数字签名算法是椭圆曲线数字签名算法(Elliptic Curve Digital SignatureAlgorithm , ECDSA) 签名算法首先生成一个 ephemeral(临时)私钥(即随机数 $k_{tmp}$), 记临时私钥生成的临时公钥的 x坐标为 $x$, p 是椭圆曲线的主要顺序, 记用户的私钥为k,公钥为K(是一个点) , G是椭圆曲线发生器点.则 y = k_{\text{tmp}}^{-1}(hash(transaction)+x*k )\ mod \ p得到签名为 $signature = (x,y)$ 验证过程如下, 计算 (x_{verify},y_{verify}) =y^{-1}( hash(transaction)* G+ x*K)如果 $x_{verify} = x$, 则签名有效如果在两个不同的交易中，在签名算法中使用相同的值 k，则私钥可以被计算并暴露给世界！ 重用 k 值的最常见原因是未正确初始化的随机数生成器。为了避免这个漏洞，业界最佳实践不是用熵播种的随机数生成器生成 k 值，而是使用交易数据本身播种的确定性随机进程。 5.8.4. 签名序列化(DER)如用 DER((Distinguished Encoding Rules)编码后的签名为3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301这里 数字签名记为(R,S) 5.8.5. 签名哈希类型(SIGHASH)SIGHASH,指示交易数据的哪一部分.SIGHASH 标志是附加到签名的单个字节。每个签名都有一个SIGHASH标志，该标志在不同输入之间也可以不同。 有三个 标志 如下 另外还有一个修饰符标志SIGHASH_ANYONECANPAY，它可以与前面的每个标志组合。 当设置ANYONECANPAY时，只有一个输入被签名，其余的(及其序列号)打开以进行修改。ANYONECANPAY的值为0x80，并通过按位OR运算，得到如下所示的组合标志： SIGHASH标志在签名和验证期间应用的方式是建立交易的副本和删节其中的某些字段(设置长度为零并清空)，继而生成的交易被序列化，SIGHASH标志被添加到序列化交易的结尾，并将结果哈希化 ，得到的哈希值本身即是被签名的“消息”。 基于SIGHASH标志的使用，交易的不同部分被删节。 所得到的哈希值取决于交易中数据的不同子集。 例如 ALL | ANYONECANPAY可以用来发起众筹 NONE 可用于构建特定数量的”不记名支票”或”空白支票” NONE | ANYONECANPAY 造可以用来建造一个“吸尘器”。在他们的钱包中拥有微小UTXO的用户无法花费这些费用，因为手续费用超过了这些微小UTXO的价值。借助这种类型的签名，微小UTXO可以为任何人捐赠，以便随时随地收集和消费。 6. 高级交易和脚本 6.1. 多重签名多重签名脚本设置了一个条件，其中N个公钥被记录在脚本中，并且至少有M个必须提供签名来解锁资金。这也称为M-N方案，其中N是密钥的总数，M是验证所需的签名的数量。例如，2-3的多重签名是三个公钥被列为潜在签名人，至少有2个有效的签名才能花费资金。 锁定脚本格式:1M &lt;PubKey 1&gt; &lt;Pubkey 2&gt; ... &lt;Pubkey N&gt; N CHECKMULTISIG 1&lt;Signature 1&gt; &lt;Signature 2&gt; ... &lt;Signature M&gt; 然而由于实施中 CHECKMULTISIG 的 bug: 会在弹出解锁脚本时从栈中多弹出一个, 所以解锁脚本规定为10 &lt;Signature 1&gt; &lt;Signature 2&gt; ... &lt;Signature M&gt; 6.2. P2SH(Pay-to-Script-Hash) 6.2.1. 多重签名的问题P2SH 是针对 多重签名 以下问题提出的 老板要在客户付款前将该脚本发送给每一位客户，而每一位顾客也必须使用特制的能产生客户交易脚本的比特币钱包软件，每位顾客还得学会如何利用脚本来完成交易。 由于脚本可能包含特别长的公钥，最终的交易脚本可能是最初交易脚本长度几倍。额外长度的脚本将给客户造成费用负担。 一个长的交易脚本将一直记录在所有节点的随机存储器的UTXO集中，直到该笔资金被使用。采用这种复杂输出脚本使得在实际交易中变得困难重重。 6.2.2. 赎回脚本在P2SH 支付中锁定脚本由哈希运算后的20字节的散列值取代，被称为赎回脚本。当一笔交易试图支付UTXO时，要解锁支付脚本，它必须含有与哈希相匹配的脚本。如下 赎回脚本本身之后作为解锁脚本在输出花费时的一部分出现。 这使得给矿工的交易费用从发送方转移到收款方，复杂的计算工作也从发送方转移到收款方。 6.2.3. P2SH地址P2SH旨在使复杂脚本的运用能与直接向比特币地址支付一样简单。 P2SH 能将脚本哈希编译为一个地址, 以“3”为前缀，该地址与一个脚本相对应而非与一个公钥相对应，但是它的效果与比特币地址支付别无二致。 6.2.4. 优点 在交易输出中，复杂脚本由简短电子指纹取代，使得交易代码变短。 脚本能被编译为地址，支付指令的发出者和支付者的比特币钱包不需要复杂工序就可以执行P2SH。 P2SH将构建脚本的重担转移至接收方，而非发送方。 P2SH将长脚本数据存储的负担从输出方(存储于UTXO集，影响内存)转移至输入方(存储在区块链里面)。 P2SH将长脚本数据存储的重担从当前(支付时)转移至未来(花费时)。 P2SH将长脚本的交易费成本从发送方转移至接收方，接收方在使用该笔资金时必须含有赎回脚本。 不能将P2SH植入P2SH赎回脚本，因为P2SH不能自循环。虽然在技术上可以将RETURN包含在赎回脚本中，但由于规则中没有策略阻止来, 因此在验证期间执行RETURN将导致交易被标记为无效. P2SH锁定脚本脚本对于赎回脚本本身未提供任何描述。P2SH交易即便在赎回脚本无效的情况下也会被认为有效, 这时可能会被锁死在P2SH这个交易中，导致不能花费这笔比特币. 6.3. 数据记录输出(RETURN操作符)运用比特币的区块链技术存储与比特币支付不相关数据, 例如，为文件记录电子指纹，则任何人都可以通过该机制在特定的日期建立关于文档存在性的证明。 此类交易仅将比特币地址当作自由组合的20个字节而使用，进而会产生不能用于交易的UTXO。因为比特币地址只是被当作数据使用，并不与私钥相匹配，所以会导致UTXO不能被用于交易，因而是一种伪支付行为。因此，这些交易永远不会被花费，所以永远不会从UTXO集中删除，并导致UTXO数据库的大小永远增加或“膨胀” Return允许开发者在交易输出上增加80字节的非交易数据。与伪交易型的UTXO不同，Return创造了一种明确的可复查的非交易型输出，此类数据无需存储于UTXO集。Return输出被记录在区块链上，会消耗磁盘空间，也会导致区块链规模的增加，但它们不存储在UTXO集中，因此也不会使得UTXO内存膨胀. RETURN 不涉及可用于支付的解锁脚本的特点， RETURN 不能使用其输出中所锁定的资金，因此没有必要记录在蕴含潜在成本的UTXO集中，所以 RETURN 实际是没有成本的。 RETURN 常为一个金额为0的比特币输出， 因为任何与该输出相对应的比特币都会永久消失。假如一笔 RETURN 被作为一笔交易的输入，脚本验证引擎将会阻止验证脚本的执行，将标记交易为无效 6.4. 时间锁(Timelocks)时间锁是只允许在一段时间后才允许支出的交易,锁定时间也称为nLocktime. nLocktime=0，即时传播和执行 0&lt;nLocktime≤5e8，则将其解释为块高度，这意味着交易无效. nLocktime＞5e8, 解释为Unix纪元时间戳,并且交易在指定时间之前无效。 试想, 如果 A 支付 B 一个交易, nLocktime 为3个月后, 那么 B 3个月后才可用这个 UTXO , 如果 A这时再将原来输入的 UTXO 用于其他交易,那么 B 3个月后就不能用了. 因此,时间限制必须放在UTXO本身上，并成为锁定脚本的一部分，而不是交易。可通过时间锁定的一种形式检查锁定时间验证(CLTV)来实现. 6.4.1. 检查锁定时间验证CheckLockTimeVerify(CLTV)通过在输出的赎回脚本中添加CLTV操作码来限制输出，从而只能在指定的时间过后使用. CLTV不会取代nLocktime，而是限制特定的UTXO，并通过将nLocktim设置为更大或相等的值，从而达到在未来才能花费这笔钱的目的。 一个 P2SH 交易的赎回脚本如下: Alice 转给 Bob的钱, 3个月才到1&lt;now+3 months&gt; CHECKLOCKTIMEVERIFY DROP DUP HASH160 &lt;Bob's Public Key Hash&gt; EQUALVERIFY CHECKSIG 如果 Bob 尝试引用(花费)这个 UTXO,他使用他的签名和公钥在该输入的解锁脚本，并将交易nLocktime设置为等于或更大于Alice设置的CHECKLOCKTIMEVERIFY 时间锁。然后Bob在比特币网络上广播交易。 矿工对交易评估如下:如果Alice设置的CHECKLOCKTIMEVERIFY参数小于或等于支出交易的nLocktime，脚本执行将继续(就好像执行“无操作”或NOP操作码一样). 否则,CHECKLOCKTIMEVERIFY失败并停止执行，标记交易无效: 堆栈是空的要么 堆栈中的顶部项小于0;要么 顶层堆栈项和nLocktime字段的锁定时间类型(高度或者时间戳)不相同;要么 顶层堆栈项大于交易的nLocktime字段;要么 输入的nSequence字段为0xffffffff。 6.4.2. 相对时间锁nLocktime和CLTV都是绝对时间锁定，它们指定绝对时间点。 它们允许将两个或多个相互依赖的交易链接在一起，同时对依赖于从先前交易的确认所经过的时间的一个交易施加时间约束。换句话说，在UTXO被记录在块状块之前，时钟不开始计数。这个功能在双向状态通道和闪电网络中特别有用 交易级相对时间锁定是作为对每个交易输入中设置的交易字段nSequence的值的共识规则实现的。脚本级相对时间锁定使用CHECKSEQUENCEVERIFY(CSV)操作码实现。 6.4.2.1. nSequence在每个输入中加多一个nSequence字段来设置此类相对时间锁. ，如果输入的交易的序列值小于2^32 (0xFFFFFFFF)，就表示尚未“确定”的交易。 nSequence的原始含义从未被正确实现，并且在不利用时间锁定的交易中nSequence的值通常设置为$2^{32}$. 对于具有nLocktime或CHECKLOCKTIMEVERIFY的交易，nSequence值必须设置为小于$2^{32}$， 以使时间锁定器有效。通常设置为$2^{32}-1\\ (0xFFFFFFFE)$。 一笔输入交易，当输入脚本中的nSequence值小于2^31时，就是相对时间锁定的输入交易。 交易可以包括时间锁定输入(nSequence =2^31)的输入。 nSequence值以块或秒为单位, 类型标志用于区分计数块和计数时间(以秒为单位)的值。类型标志设置在第23个最低有效位(即值1 &lt;&lt; 22)。如果设置了类型标志，则nSequence值将被解释为512秒的倍数。如果未设置类型标志，则nSequence值被解释为块数。 当将nSequence解释为相对时间锁定时，只考虑16个最低有效位。一旦评估了标志(位32和23)，nSequence值通常用16位掩码(例如nSequence＆0x0000FFFF)“屏蔽”。 6.4.2.2. CHECKSEQUENCEVERIFY(CSV)脚本操作码, 在UTXO的赎回脚本中评估时，CSV操作码仅允许在输入nSequence值大于或等于CSV参数的交易中进行消耗。 6.4.3. Median-Time-Past在比特币中, 墙上时间(wall time)和共识时间之间存在微妙但非常显著的差异。比特币是一个分散的网络，这意味着每个参与者都有自己的时间观。网络上的事件不会随时随地发生。网络延迟必须考虑到每个节点的角度。最终，所有内容都被同步，以创建一个共同的分类帐。 通过取最后11个块的时间戳并计算其中位数作为“中位时间过去”的值,作为共识时间，并被用于所有的时间计算. 通过这个方法，没有一个矿工可以利用时间戳从具有尚未成熟的时间段的交易中获取非法矿工费。 6.5. 条件子句(Conditional Clauses)可以控制流量.由于比特币脚本语言是一种堆栈语言, 则其条件控制如下1234567trueconditionIFtruetruecode to run when condition is trueELSEtruetruecode to run when condition is falseENDIFcode to run in either case 另外也有带有VERIFY操作码的条件子句 任何以VERIFY结尾的操作码。 VERIFY后缀表示如果评估的条件不为TRUE，脚本的执行将立即终止，并且该交易被视为无效。VERIFY后缀充当保护子句，只有在满足前提条件的情况下才会继续。如1HASH160 &lt;expected hash&gt; EQUALVERIFY &lt;Bob's Pubkey&gt; CHECKSIG 等同于1234HASH160 &lt;expected hash&gt; EQUALIFtruetruetrue&lt;Bob's Pubkey&gt; CHECKSIGENDIF 使用IF的脚本与使用具有VERIFY后缀的操作码相同; 他们都作为保护条款。 然而，VERIFY的构造更有效率，使用较少的操作码。 诸如EQUAL之类的操作码会将结果(TRUE / FALSE)推送到堆栈上，留下它用于后续操作码的评估。 相比之下，操作码EQUALVERIFY后缀不会在堆栈上留下任何东西。 在VERIFY中结束的操作码不会将结果留在堆栈上。 在多重签名, 赎回脚本中使用赎回脚本12345IFtrue&lt;Alice's Pubkey&gt; CHECKSIGELSE &lt;Bob's Pubkey&gt; CHECKSIGENDIF 而条件应该在解锁脚本中,Alice用解锁脚本&lt;Alice&#39;s Sig&gt; 1,Bob 用解锁脚本&lt;Bob&#39;s Sig&gt; 0 一个复杂的例子 多重签名的计划的参与者是Mohammed，他的两个合作伙伴Saeed和Zaira，以及他们的公司律师Abdul。三个合作伙伴根据多数规则作出决定，因此三者中的两个必须同意。然而，如果他们的钥匙有问题，他们希望他们的律师能够用三个合作伙伴签名之一收回资金。最后，如果所有的合作伙伴一段时间都不可用或无行为能力，他们希望律师能够直接管理该帐户。 具有时间锁定(Timelock)变量的多重签名12345678910111213IFtruetrueIFtruetruetruetrue2truetrueELSEtruetruetruetrue&lt;30 days&gt; CHECKSEQUENCEVERIFY DROPtruetruetruetrue&lt;Abdul the Lawyer's Pubkey&gt; CHECKSIGVERIFY 1 ENDIF &lt;Mohammed's Pubkey&gt; &lt;Saeed's Pubkey&gt; &lt;Zaira's Pubkey&gt; 3 CHECKMULTISIGELSEtruetrue&lt;90 days&gt; CHECKSEQUENCEVERIFY DROPtruetrue&lt;Abdul the Lawyer's Pubkey&gt; CHECKSIGENDIF 第二个执行路径只能在UTXO创建30天后才能使用。 那时候，它需要签署Abdul(律师)和三个合作伙伴之一(三分之一)。解锁第二个执行路径的脚本(Lawyer + 1-of-3) 10 &lt;Saeed's Sig&gt; &lt;Abdul's Sig&gt; FALSE TRUE ** 此解锁脚本开头的0是因为CHECKMULTISIG中的错误从堆栈中弹出一个额外的值 先FALSE后TRUE, 分析栈的顺序 ** 7. P2P 网络架构P2P是指位于同一网络中的每台计算机都彼此对等，各个节点共同提供网络服务，不存在任何“特殊”节点。每个网络节点以“扁平(flat)”的拓扑结构相互连通。 在P2P网络中不存在任何服务端(server)、中央化的服务、以及层级结构。P2P网络的节点之间交互运作、协同处理：每个节点在对外提供服务的同时也使用网络中其他节点所提供的服务。P2P网络也因此具有可靠性、去中心化，以 及开放性。 尽管比特币P2P网络中的各个节点相互对等，但是根据所提供的功能不同，各节点可能具有不同的角色。每个比特币节点都是路由、区块链数据库、挖矿、钱包服务的功能集合。 全节点含有 区块链的完整拷贝, 而轻量级结点只有一部分, 交易验证的方式是 简单支付验证(SPV) 常见结点类型 7.1. 扩展比特币网络运行比特币P2P协议的比特币主网络由大约5000-8000个运行着不同版本比特币核心客户端(Bitcoin Core)的监听节 点、以及几百个运行着各类比特币P2P协议的应用(例如BitcoinClassic, Bitcoin Unlimited, BitcoinJ, Libbitcoin, btcd, and bcoin等)的节点组成。比特币P2P网络中的一小部分节点也是挖矿节点，它们竞争挖矿、验证交易、并创建新的区块。许多连接到比特币网络的大型公司运行 着基于Bitcoin核心客户端的全节点客户端，它们具有区块链的完整拷贝及网络节点，但不具备挖矿及钱包功能。这些节点是网络中的边缘路由器(edgerouters)，通过它们可以搭建其他服务，例如交易所、钱包、区块浏览器、商家支付处理(merchant payment processing)等 7.2. 网络发现当新的网络节点启动后，为了能够参与协同运作，它必须发现网络中的其他比特币节点。新的网络节点必须发现至少一个网络中存在的节点并建立连接。由于比特币网络的拓扑结构并不基于节点间的地理位置，因此各个节点之间的地理信息完全无关。在新节点连接时，可以随机选择网络中存在的比特币节点与之相连。 节点通常采用TCP协议、使用8333端口. 。在建立连接时，该节点会通过发送一条包含基本认证内容的version消息开始“握手”通信过 程. 包括如下内容: nVersion: 比特币P2P协议所采用的版本 nLocalServices: 一组该节点支持的本地服务列表，当前仅支持NODE_NETWORK▷ nTime: 当前时间 addrYou: 当前节点可见的远程节点的IP地址 addrMe: 本地节点所发现的本机IP地址 subver: 指示当前节点运行的软件类型的子版本号 BaseHeight: 当前节点区块链的区块高度 接收版本消息的本地对等体将检查远程对等体报告的nVersion，并确定远端对等体是否兼容。 如果远程对等体兼容，则本地对等体将确认版本消息，并通过发送一个verack建立连接。 当建立一个或多个连接后，新节点将一条包含自身IP地址的addr消息发送给其相邻节点。相邻节点再将此条addr消息依 次转发给它们各自的相邻节点，从而保证新节点信息被多个节点所接收、保证连接更稳定。然后，新接入的节点可以向 它的相邻节点发送getaddr消息，要求它们返回其已知对等节点的IP地址列表。 节点必须连接到若干不同的对等节点才能在比特币网络中建立通向比特币网络的种类各异的路径(path)。由于节点可以随时加入和离开，通讯路径是不可靠的。因此，节点必须持续进行两项工作：在失去已有连接时发现新节点，并在其他节点启动时为其提供帮助。节点启动时只需要一个连接，因为第一个节点可以将它引荐给它的对等节点，而这些节点又会进一步提供引荐。一个节点，如果连接到大量的其他对等节点，这既没必要，也是对网络资源的浪费。在启动完成 后，节点会记住它最近成功连接的对等节点；因此，当重新启动后它可以迅速与先前的对等节点网络重新建立连接。如果先前的网络的对等节点对连接请求无应答，该节点可以使用种子节点进行重启动。 如果已建立的连接没有数据通信，所在的节点会定期发送信息以维持连接。如果节点持续某个连接长达90分钟没有任何通信，它会被认为已经从网络中断开，网络将开始查找一个新的对等节点 7.3. 同步区块链对于全节点, 需要同步备份整个区块链..此过程从发送version消息开始，这是因为该消息中含有的BestHeight字段标示了一个节点当前的区块链高度(区块数量)。对等节点们会交换一个getblocks消息，其中包含他们本地区块链的顶端区块哈希值(指纹)。如果某个对等节点识别出它接收到的哈希值并不属于顶端区块，而是属于一个非顶端区块的旧区块，那么它就能推断出：其自身的本地区块链比其他对等节点的区块链更长。 拥有更长区块链的对等节点,识别出第 一批可供分享的500个区块，通过使用inv(inventory)消息把这些区块的哈希值传播出去。缺少这些区块的节点便可以 通过各自发送的getdata消息来请求得到全区块信息，用包含在inv消息中的哈希值来确认是否为正确的被请求的区块， 从而读取这些缺失的区块。 7.4. 简单支付验证(SPV)SPV节点只需下载区块头，而不用下载包含在每个区块中的交易信息。由此产生的不含交易信息的区块链，大小只有完整区块链的1/1000。SPV节点不能构建所有可用于消费的UTXO的全貌. SPV节点验证交易时依赖对等节点“按需”提供区块链相关部分的局部视图。 如要检查第300000号区块的某个交易, SPV节点会在该交易信息和它所在区块之间用merkle路径建立一条链接。然后SPV节点一直等待，直到序号从300,001到300,006的六个区块堆叠在该交易所在的区块之上，并通过确立交易的深度是在第300,006区块~第300,001区块之下来验证交易的有效性。 SPV节点可以证实某个交易的存在性，但它不能验证某个交易(譬如同一个UTXO的双重支付)不存在，这是因为SPV节点没有一份关于所有交易的记录。这个漏洞会被针对SPV节点的拒绝服务攻击或双重支付型攻击所利用。为了防御这些攻击，SPV节点需要随机连接到多个节点，以增加与至少一个可靠节点相连接的概率。这种随机连接的需求意味着SPV节 点也容易受到网络分区攻击或Sybil攻击。在后者情况中，SPV节点被连接到虚假节点或虚假网络中，没有通向可靠节点或真正的比特币网络的连接。 7.5. Bloom filterSPV节点对特定数据的请求可能无意中透露了钱包里的地址信息。例如，监控网络的第三方可以跟踪某个SPV节点上的钱包所请求的全部交易信息，并且利用这些交易信息把比特币地址和钱包的用户关联起来，从而损害了用户的隐私。 Bloom过滤器通过一个采用概率而不是固定模式的过滤机制，允许SPV节点只接收交易信息的子集，同时不会精确泄露哪些是它们感兴趣的地址。 Bloom过滤器可以让SPV节点指定交易的搜索模式，该搜索模式可以基于准确性或私密性的考虑被调节。如果过滤器只包含简单的关键词，更多相应的交易会被搜索出来，在包含若干无关交易的同时有着更高的私密性。 构成:一个可变长(N)的 二进制数组, 数组初始值为0, . 一组数量可变(M)的哈希函数, 哈希函数输出为 1—-N, 对应数组,且为确定性函数. 算法如下记数组 arr[N] , M个hash函数 $hs=\{h_1,h_2,\ldots,h_M\}$关键字 $keys = \{k_1,k_2,\ldots,k_i\}$ 过滤器记录关键字过程1234arr[N]=&#123;0&#125; # initializationfor key in keys: for hash in hs: arr[hash(key)] = 1 判断一个关键字是否被过滤器记录: 将关键字分别代入各hash 函数 计算对比 arr 对应的值, 如果有0, 则没有被记录, 如果全为1, 则 可能 被记录.(基于概率) 7.6. SPV 节点如何使用 Bloom filter数组置0, 然后SPV节点将列出所有感兴趣的地址，密钥和散列，它将通过从其钱包控制的任何UTXO中提取公钥哈希和脚本哈希和交易ID来实现。 SPV节点然后将其中的每一个添加到Bloom过滤器，以便如果这些模式存在于交易中，则Bloom过滤器将“匹配”，而不会自动显示模式。 然后，SPV节点将向对等体发送一个过滤器加载消息，其中包含在连接上使用的bloom过滤器。在对等体上，针对每个传入交易检查Bloom过滤器。完整节点根据bloom过滤器检查交易的几个部分，寻找匹配， 只有与过滤器匹配的交易才会发送到节点。响应于来自节点的getdata消息，对等体将发送一个merkleblock消息，该消息仅包含与过滤器匹配的块和每个匹配交易的merkle路径。然后，对等体还将发送包含由过滤器匹配的交易的tx消息。 7.7. 加密和认证连接Tor传输和P2P认证和加密 7.8. 交易池比特币网络中几乎每个节点都会维护一份未确认交易的临时列表，被称为内存池或交易池 有些节点的实现还维护一个单独的孤立交易池。如果一个交易的输入与某未知的交易有关，如与缺失的父交易相关，该 孤立交易就会被暂时储存在孤立交易池中直到父交易的信息到达。当一个交易被添加到交易池中，会同时检查孤立交易池，看是否有某个孤立交易引用了此交易的输出(子交易)。 交易池和孤立交易池(如有实施)都是存储在本地内存中，并不是存储在永久性存储设备(如硬盘)里。 8. 区块链平均每个区块至少包含超过500个交易区块头由三组区块元数据组成: 引用父区块哈希值的数据，用于与前一区块相连接。 难度、时间戳和nonce,与挖矿竞争相关 merkle树根 因为创世区块被编入到比特币客户端软件里，所以每一个节点都始于至少包含一个区块的区块链，这能确保创世区块不会被改变。每一个节点都“知道”创世区块的哈希值、结构、被创建的时间和里面的一个交易。因此，每个节点都把该区块作为区块链的首区块，从而构建了一个安全的、可信的区块链。 在比特币网络中，Merkle树被用来归纳一个区块中的所有交易,同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。。如果仅有奇数个交易需要归纳，那最后的交易就会被复制一份以构成偶数个叶子节点， 不需要下载整个区块而通过Merkle路径去验证交易的存在,又被称作简单支付验证. 一个SPV节点想知道它钱包中某个比特币地址即将到达的支付。该节点会在节点间的通信链接上建立起bloom过滤器，限制只接受含有目标比特币地址的交易。当对等体探测到某交易符合bloom过滤器，它将以Merkleblock消息的形式发送该区块。Merkleblock消息包含区块头和一条连接目标交易与Merkle根的Merkle路径。SPV节点能够使用该路径找到与该交易相关的区块，进而验证对应区块中该交易的有无。SPV节点同时也使用区块头去关联区块和区块链中的其余区块。这两种关联，交易与区块、区块和区块链，就可以证明交易存在于区块链。简而言之，SPV节点会收到少于1KB的有关区块头和Merkle路径的数据，其数据量比一个完整的区块(目前大约有1MB)少了一千多倍。\ 比特币的测试区块链 testnet—比特币的试验场: 实际上它和主网只有两个区别：testnet币是毫无价值的，挖掘难度足够低，任何人都可以相对容易地使用testnet币)。任何打算在比特币主干网上用于生产的软件开发都应该首先在testnet上用测试币进行测试。免受由于软件错误而导致的金钱损失，也可以保护网络免受由于软件错误导致的意外攻击 regtest—本地区块链: regtest 代表回归测试, 是比特币的一中核心功能,可以创建本地区块链以进行测试. 开发过程:首先在regtest上部署每个变更，然后在testnet上进行测试，最后实现生产,部署到比特币网络上。 9. 挖矿与共识挖矿巩固了去中心化的清算交易机制，通过这种机制，交易得到验证和清算,实现去中心化的安全机制，是P2P数字货币的基础。 矿工们在挖矿过程中会得到两种类型的奖励：创建新区块的新币奖励，以及区块中所含交易的交易费。矿工们争相完成一种基于加密哈希算法的数学难题，这些难题的答案包括在新区块中，作为矿工的计算工作量的证明，被称为”“工作量证明”。该算法的竞争机制以及获胜者有权在区块链上进行交易记录的机制，这二者是比特币安全的基石。 比特币的去中心化共识由所有网络节点的4种独立过程相互作用而产生： 每个全节点依据综合标准对每个交易进行独立验证 通过完成工作量证明算法的验算，挖矿节点将交易记录独立打包进新区块 每个节点独立的对新区块进行校验并组装进区块链 每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链。 它们之间如何相互作用并达成全网的自发共识，从而使任意节点组合出 它自己的权威、可信、公开的总帐副本。 9.1. 交易验证在交易传递到临近的节点前，每一个收到交易的比特币节点将会首先验证该交易，这将确保只有有效的交易才会 在网络中传播，而无效的交易将会在第一个节点处被废弃。 交易的语法和数据结构必须正确。 输入与输出列表都不能为空。 交易的字节大小是小于 MAX_BLOCK_SIZE 的。 每一个输出值，以及总量，必须在规定值的范围内 (小于2,100万个币，大于0)。 没有哈希等于0，N等于-1的输入(coinbase交易不应当被传递)。 nLockTime是小于或等于 INT_MAX 的。或者nLocktime and nSequence的值满足MedianTimePast 交易的字节大小是大于或等于100的。 交易中的签名数量(SIGOPS)应小于签名操作数量上限。 解锁脚本( scriptSig )只能够将数字压入栈中，并且锁定脚本( scriptPubkey )必须要符合isStandard的格式 (该格式将会拒绝非标准交易)。 池中或位于主分支区块中的一个匹配交易必须是存在的。 对于每一个输入，引用的输出是必须存在的，并且没有被花费。 对于每一个输入，如果引用的输出存在于池中任何别的交易中，该交易将被拒绝。 对于每一个输入，在主分支和交易池中寻找引用的输出交易。如果输出交易缺少任何一个输入，该交易将成为一个孤 立的交易。如果与其匹配的交易还没有出现在池中，那么将被加入到孤立交易池中。 对于每一个输入，如果引用的输出交易是一个coinbase输出，该输入必须至少获得COINBASE_MATURITY(100)个确认。 使用引用的输出交易获得输入值，并检查每一个输入值和总值是否在规定值的范围内 (小于2100万个币，大于0)。 如果输入值的总和小于输出值的总和，交易将被中止。 如果交易费用太低以至于无法进入一个空的区块，交易将被拒绝。 每一个输入的解锁脚本必须依据相应输出的锁定脚本来验证。 验证交易后，比特币节点会将这些交易添加到自己的内存池中。内存池也称作交易池，用来暂存尚未被加入到区块的交 易记录。 例如:Jing节点的区块链已经收集到了区块277,314，并继续监听着网络上的交易，在尝试挖掘新区块的同时，也监 听着由其他节点发现的区块。这时他从比特币网络收到了区块277,315, 标志着终结了产出区块277,315竞赛，与此同时也是产出区块277,316竞赛的开始。 在上一个10分钟内，当Jing的节点正在寻找区块277,315的解的同时，他也在收集交易记录为下一个区块做准备。目前 它已经收到了几百笔交易记录，并将它们放进了内存池。直到接收并验证区块277,315后，Jing的节点会检查内存池中 的全部交易，并移除已经在区块277,315中出现过的交易记录，确保任何留在内存池中的交易都是未确认的，等待被记 录到新区块中。 Jing的节点立刻构建一个新的空区块，做为区块277,316的候选区块。称作候选区块是因为它还没有包含有效的工作量证明(计算出合适的 nonce)，不是一个有效的区块，而只有在矿工成功找到一个工作量证明解之后，这个区块才生效。现在，Jing的节点从内存池中整合到了全部的交易，新的候选区块包含有418笔交易，总的矿工费为0.09094925个比特币。 9.2. coinbase交易(创币交易)每个区块中的第一笔交易是笔特殊交易，称为创币交易或者coinbase交易 与常规交易不同，创币交易没有输入，不消耗UTXO。它只包含一个被称作coinbase的输入，仅仅用来创建新的比特 币。创币交易有一个输出，支付到这个矿工的比特币地址。 为了构造创币交易，矿工节点需要计算如下 矿工费的总额: 输入总额减去输出总额 新区块奖励额: 是基于区块高度的，以每个区块50个比特币为开 始，每产生210,000个区块(10分钟一个区块,大约4年)减半一次。2016年7月为 12.5 bitcoin 9.3. 构造区块头 merkle root: 将全部的交易组成一个merkle树。创币交易作为区块中的首个交易，后将余下的 418笔交易添至其后，这样区块中的交易一共有419笔。 Target(难度目标值): 定义了所需满足的工作量证明的难度。难度在区块中以“尾数-指数”的格式，编码并存储，这种格式称作target-bits(难度位)。首字节表示指数(exponent)，后面的3字节表示尾数(系数)(coefficient)。则$\text{difficulty} = cofficient 2^{8{(exponent-3)} }$难度是可以调整的, 以保证不论计算力如何, 总要大约每十分钟产生一个区块. 因此, 新公式为 $\text{ newDifficulty} = \text{diffculty} * \frac{Time(last\ 2016\ blocks)}{20160\ min}$ nonce: 初始值为0 构造区块 nonce 如下1234nonce = 0while 1: if hash(blockHead)&lt;Target:break # nonce in blockHead else: CHANGE NONCE # eg nonce+=1 构造好之后, 挖矿节点立刻将这个区块发给它的所有相邻节点。这些节点在接收并验证这个新区块后，也会继续传播此区块。当这个新区块在网络中扩散时，每个节点都会将它加入自己的区块链副本中。其他挖矿结点就放弃之前对构建这个相 同高度区块的计算，并立即开始计算区块链中下一个区块的工作。 9.4. 校验新区块前面清单列出了一些, 也可以通过 客户端的 CheckBlock, CheckBlockHead,查看 为什么矿工不为他们自己记录一笔交易去获得数以千计的比特币？这是因为每一个节点根据相同的规则对区块进行校验。一个无效的coinbase交易将使整个区块无效，这将导致该区块被拒 绝，因此，该交易就不会成为总账的一部分。矿工们必须构建一个完美的区块，基于所有节点共享的规则，并且根据正 确工作量证明的解决方案进行挖矿，他们要花费大量的电力挖矿才能做到这一点。如果他们作弊，所有的电力和努力都 会浪费。这就是为什么独立校验是去中心化共识的重要组成部分。 9.5. 构建区块构建了一个候选区块，然后求解工作量证明算法以使这个区块有效。 每次改变 nonce, 尝试产生一个随机的结果，但是任何可能的结果的概率可以预先计算。因此，指定特定难度(Target)的结果构成了具体的工作量证明。 验证nonce 哈希值只需要一次计算，而我们找到它却花了很多次。知道目标值后，任何人都可以用统计学来估算其难度，因此就能知道找到这个nonce需要多少工作。 按当前比特币系统的难度，矿工得试$10^15$次才能找到一个合适的nonce使区块头信息哈希值足够小。 9.6. 区块链的组装与选择 连接到主链上的 从主链上产生分支的(备用链)， 在已知链中没有找到已知父区块的。 在验证过程中，一旦发现有不符合标准的地方，验证就会失败，这样区块会被节点拒绝，所以也不 会加入到任何一条链中。 任何时候，主链都是累计了最多难度的区块链。在一般情况下，主链也是包含最多区块的那个链，除非有两个等长的链 并且其中一个有更多的工作量证明。主链也会有一些分支，这些分支中的区块与主链上的区块互为“兄弟”区块。这些区 块是有效的，但不是主链的一部分。 新区块所延长的区块链并不是主链,节点将新的区块添加到备用链，同时比较备用链与主链的难度。如果备用链比主链积累了更多的难度，节点将收敛于备用链，意味 着节点将选择备用链作为其新的主链，而之前那个老的主链则成为了备用链。 如果节点收到了一个有效的区块，而在现有的区块链中却未找到它的父区块，那么这个区块被认为是“孤块”。孤块会被 保存在孤块池中，直到它们的父区块被节点收到。 比特币将区块间隔设计为10分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协。更短的区块产生间隔会让交 易清算更快地完成，也会导致更加频繁地区块链分叉。 难度增长后, nonce 值不够, 可以延后时间戳来解决, 但是如果延后太久, 可能导致区块无效, 更好的解决方案是利用 coinbase 这笔交易中的空间(coinbase 脚本可以存储2-100bytes 数据), 而且这笔交易会影响 merkle 根的变化. 9.7. 矿池 9.7.1. 矿工加入个人矿工在建立矿池账号后，设置他们的矿机连接到矿池服务器。他们的挖矿设备在挖矿时保持和矿池服务器的连接，和其他矿工同步各自的工作。这样，矿池中的矿工分享挖矿任务，之后分享奖励。成功出块的奖励支付到矿池的比特币地址，而不是单个矿工的。一旦奖励达到一个特定的阈值，矿池服务器便会定期支 付奖励到矿工的比特币地址。 9.7.2. 托管矿池大部分矿池是“托管的”，有一个公司或者个人经营一个矿池服务器。矿池服务器的所有者叫矿池管理员，同时他 从矿工的收入中收取一个百分比的费用。矿池服务器运行专业软件以及协调池中矿工们活动的矿池采矿协议。矿池服务器同时也连接到一个或更多比特币完全节点并直接访问一个块链数据库的完整副本。这使得矿池服务器可以代替矿池中的矿工验证区块和交易，缓解他们运行一个完整节点的负担. 9.7.3. P2P矿池托管矿池存在管理人作弊的可能，管理人可以利用矿池进行双重支付或使区块无效, 此外，中 心化的矿池服务器代表着单点故障。如果因为拒绝服务攻击服务器挂了或者被减慢，池中矿工就不能采矿。 P2Pool是一个点对点的矿池，没有中心管理 人。P2Pool通过将矿池服务器的功能去中心化，实现一个并行的类似区块链的系统，名叫份额链(share chain)。 一个份额链是一个难度低于比特币区块链的区块链系统。份额链允许池中矿工在一个去中心化的池中合作,采矿，并获得份额。份额链上的区块记录了贡献工作的矿工的份额，并且继承了之前份额区块上的份额记录。当一 个份额区块上还实现了比特币网络的难度目标时，它将被广播并包含到比特币的区块链上，并奖励所有已经在份额链区块中取得份额的池中矿工。 9.8. 共识攻击比特币的共识机制的前提: 绝大多数的矿工，出于自己利益最大化的考虑，都会通过诚实地挖矿来维持整个比特币系统。 当一个或者一群拥有了整个系统中大量算力的矿工出现, 可以通过攻击比特币的共识机制来达到破坏比特币网络的安全性和可靠性的目的。 注意, ，共识攻击只能影响整个区块链未来的共识，即最多影响 过去10个块。而且随着时间的推移，整个比特币块链被篡改的可能性越来越低。 共识攻击也 不能从其他的钱包那里偷到比特币、不签名地支付比特币、重新分配比特币、改变过去的交易或者改变比特币持有纪 录。共识攻击能够造成的唯一影响是影响最近的区块(最多10个)并且通过拒绝服务来影响未来区块的生成。 区块链分叉/双重支付攻击指的是攻击者通过 不承认最近的某个交易，并在这个交易之前重构新的块，从而生成新的分叉，继而实现双重支付。双重支付只能在攻击者拥有的钱包所发生的交易上进行，因为只有钱包的拥有者才能生成一个合法的签名用 于双重支付交易。攻击者在自己的交易上进行双重支付攻击，如果可以通过使交易无效而实现对于不可逆转的购买行为不予付款，这种攻击就是有利可图的。 51%攻击并不是像它的命名里说的那样，攻击者需要至少51%的算力才能发起，实际上，即使其拥有不到51%的系统算力，依然可以尝试发起这种攻击。之所以命名为51％攻击，只是因为在攻击者的算力达到51%这个阈值的时候，其发起的攻击尝试几乎肯定会成功。 9.9. 分叉 9.9.1. 硬分叉导致硬分叉：共识规则中的错误，以及对共识规则的故意修改。 对于硬分叉发生，必须是由于采取相互竞争的实施方案，并且规则需要由矿工，钱包和中间节点激活。相反，有许多比特币核心的替代实现方案，甚至还有软分叉，这些没有改变共识规则，阻止发生错误，可以在网络上共存并互操作，最终并未导致硬分叉。 可以将硬分叉子看成四个阶段：软分叉，网络分叉，挖矿分叉和区块链分叉。该过程开始于开发人员创建的客户端，这个客户端对共识规则进行了修改。当这种新版本的客户端部署在网络中时，一定百分比的矿工，钱包用户和中间节点可以采用并运行该版本客户端。得到的分叉将取决于新的共识规则是否适用于区块，交易或系统其他方面。如果新的共识规则与交易有关，那么当交易被挖掘成一个块时，根据新规则创建交易的钱包可能会产生出一个网络分叉，这就是一个硬分叉。如果新规则与区块有关，那么当一个块根据新规则被挖掘时，硬分叉进程将开始。 一些开发商反对任何形式的硬叉，认为它太冒险了。另一些人认为硬分叉机制是提升共识规则的重要工具，避免了“技术债务”，并与过去提供了一个干净的了断 9.9.2. 软分叉共识规则的改变也能够让未修改的客户端仍然按照先前的规则对待交易或者区块 软分叉级只能用于增加共识规则约束，而不是扩展它们。软叉可以通过多种方式实现,方法的共同点是不要求所有节点升级或强制非升级节点必须脱离共识。如 重新定义 NOP 操作码Bitcoin脚本有10个操作码保留供将来使用，NOP1到NOP10。 根据共识规则，这些操作码在脚本中的存在被解释为无效的运算符。软叉可以修改NOP代码的语义给它新的含义。 segwit是一个交易结构的体系结构变化，它将解锁脚本(见证)从交易内部移动到外部数据结构(将其隔离) 对软分叉的批评 技术性债务指由于过去的设计权衡而增加代码维护的未来成本。代码复杂性又增加了错误和安全漏洞的可能性。(因为软叉在技术上比硬叉升级更复杂) 验证放松未经修改的客户端将交易视为有效，而不评估修改的共识规则。实际上，未经修改的客户端不会使用全面的协商一致的规则来验证，因为它们对新规则无视。这适用于基于NOP的升级，以及其他软分叉升级。 不可逆转升级因为软分叉产生额外的共识约束的交易，所以它们在实践中成为不可逆转的升级。如果软分叉升级在被激活后被回退，根据新规则创建的任何交易都可能导致旧规则下的资金损失。因此，评论家认为，由于错误而不得不被回退的失败的软分叉几乎肯定会导致资金的流失。 10. 比特币安全 10.1. 安全准则比特币的核心准则是去中心化,将责任和控制权都移交给了用户。由于网络的安全性是基于工作量证明而非访问控制，比特币网络可以对所有人开放，也无需对比特币传输进行加密。 一笔比特币交易只授权向指定接收方发送一个指定数额，并且不能被修改或伪造。它不会透露任何个人信息，例如当事人的身份，也不能用于权限外的支付。因此，比特币的支付网络并不需要加密或防窃听保护 10.2. 比特币系统安全开发比特币的安全性依赖于密钥的分散性控制，并且需要矿工们各自独立地进行交易验证。如果想利用好比特币的安全性，确保自己处于比特币的安全模型里。简而言之，不要将用户的密钥控制权拿走，不要接受非区块链交易信息。一个常见的错误是接受区块链离线交易，妄图减少交易费或加速交易处理速度。一个“区块链离线交易”系统将交易数据记录在一个内部的中心化账本上，然后偶尔将它们同步到比特币区块链中。这种做法，再一次，用专制和集中的方式取 代比特币的去中心化安全模型。当数据处于离线的区块链上的时候，保护不当的中心化账本里的资金可能会不知不觉被 伪造、被挪用、被消耗。 除非你是准备大力投资运营安全，叠加多层访问控制，或(像传统的银行那样)加强审计，否则将资金从比特币的去中心化安全场景中抽离出来这样的设计也仅仅是复制了一个脆弱不堪，深受账户盗窃威胁、贪污和挪用公款困扰的传统金融网络而已。要想充分利用比特币特有的去中心化安全模型，必须避免中心化架构的常见诱惑，因它最终将摧毁比特币的安全性。 10.3. 信任根(ROOT-OF-TRUST)传统的安全体系的基础，它指的总体系统或应用程序中一个可信赖的安全核心。安全体系像一圈同心圆一样围绕着信任根源来进行开发，像层层包裹的洋葱一样，信任从内至外依次延伸。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>数字货币</tag>
        <tag>比特币</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『区块链』简介]]></title>
    <url>%2Fintroduction-to-blockchain.html</url>
    <content type="text"><![CDATA[以下内容摘录自 &lt;&lt;区块链原理,设计与应用&gt;&gt; 1. 分布式记账 1.1. 原理 1.2. 重要性 2. 区块链的特点 3. 区块链的定义 4. 区块链的原理 4.1. 例如比特币 5. 区块链的演化 6. 关键问题与挑战 6.1. 抗抵赖与隐私保护 6.2. 分布式共识 6.3. 扩展性 6.4. 数据库和存储系统 6.5. 认识上的误区 7. 应用场景 7.1. 金融服务 7.2. 征信管理 7.3. 权属管理 7.4. 资源共享 7.5. 贸易管理 7.6. 物联网 8. 分布式系统 8.1. 一致性问题(Consistency) 8.1.1. 理想一致性 8.1.2. 带约束的一致性 8.2. 共识算法 8.2.1. Paxos &amp; Raft 8.2.2. FLP不可能原理 8.3. CAP原理 8.4. ACID 原则 9. 密码学技术 9.1. hash算法 9.2. 加解密算法 9.2.1. 对称 9.2.2. 非对称加密 9.2.3. 混合加密机制 9.3. 数字签名 9.4. 数字证书 9.5. Merkle 树 9.5.1. 定义 9.5.2. 特点 9.5.3. 应用场景 9.6. 同态加密 10. 比特币 10.1. 从实体货币到数字货币 10.2. 去中心化实现数字货币的难题 10.3. 原理与设计 10.3.1. 基本交易过程 10.3.2. 概念 10.4. 闪电网络 10.5. 侧链 11. 以太坊 11.1. 特点 11.2. 概念 11.3. 主要设计 12. 超级账本-Hyperldger 1. 分布式记账 1.1. 原理商业活动参与者首先要寻找一个多方均信任的第三方来记账, 确保交易的准确. 可以很容易设计出一个简单粗暴的分布式记账结构，如下图。多方均允许对账本进行任意读写，一旦发生新的交易即追加到账本上。这种情况下，如果参与多方均诚实可靠，则该方案可以正常工作；但是一旦有参与方恶意篡改已发生过的记录，则无法确保账本记录的正确性。 为防止恶意篡改, 可以引入验证机制. 使用数字摘要技术(digital digest). 每当有新交易记录被追加到账本上, 记录前面交易历史的 hash 值, 此后每个时刻, 参与者都可以重新计算 hash, 看是否与记录的 hash 匹配. 不匹配说明修改过, 也可以容易地定位修改的交易记录了 不必要每次都计算前面所有历史的 hash, 可以计算 上次的 hash 加上当前交易 的 内容的 hash 这正是一个区块链结构. 1.2. 重要性分布式记账问题为何重要？可以类比互联网出现后对社会带来的重大影响。互联网是人类历史上最大的分布式互联系统。作为信息社会的基础设施，它很好地解决了传递信息的问题。然而，由于早期设计上的缺陷，互联网无法确保所传递信息的可靠性，这大大制约了人们利用互联网进行大规模协作的能力。而以区块链为基础的分布式账本科技则可能解决传递可信信息的问题。这意味着基于分布式账本科技的未来商业网络，将成为新一代的文明基础设施——大规模的协作网络。 分布式账本科技的核心价值在于为未来多方协同网络提供可信基础。区块链引发的记账科技的演进，将促使商业协作和组织形态发生变革。 2. 区块链的特点 分布式容错性：分布式网络极其 robust , 能够容忍部分节点的异常状态； 不可篡改性：一致提交后的数据会一直存在，不可被销毁或修改； 隐私保护性：密码学保证了数据隐私，即便数据泄露，也无法解析。 可能带来的业务特性 可信任性：区块链技术可以提供天然可信的分布式账本平台，不需要额外第三方中介机构参与； 降低成本：跟传统技术相比，区块链技术可能带来更短的时间、更少的人力，降低维护成本； 增强安全：区块链技术将有利于安全、可靠的审计管理和账目清算，减少犯罪风险。 3. 区块链的定义狭义上，区块链是一种以区块为基本单位的链式数据结构，区块中利用数字摘要对之前的交易历史进行校验，适合分布式记账场景下防篡改和可扩展性的需求。广义上，区块链还指代基于区块链结构实现的分布式记账技术，还包括分布式共识、隐私与安全保护、点对点通信技术、网络协议、智能合约等。 4. 区块链的原理 交易(transaction): 一次对账本的操作,导致账本状态的一次改变. 区块(block): 记录一段时间内发生的所有交易和状态结果.,是对当前账本状态的一次共识 链(chain): 由区块按照发生顺序串联而成,是整个版本状态变化的日志记录 在实现上, 首先假设存在一个分布式的数据记录账本,只允许添加,不允许删除. 4.1. 例如比特币首先，比特币客户端发起一项交易，广播到比特币网络中并等待确认。网络中的节点会将一些收到的等待确认的交易记录打包在一起（此外还要包括前一个区块头部的哈希值等信息），组成一个候选区块。然后，试图找到一个 nonce 串（随机串）放到区块里，使得候选区块的哈希结果满足一定条件（比如小于某个值）。这个nonce 串的查找需要一定的时间进行计算尝试。一旦节点算出来满足条件的 nonce 串，这个区块在格式上就被认为是“合法”了，就可以尝试在网络中将它广播出去。其它节点收到候选区块，进行验证，发现确实符合约定条件了，就承认这个区块是一个合法的新区块，并添加到自己维护的区块链上。当大部分节点都将区块添加到自己维护的区块链结构上时，该区块被网络接受，区块中所包括的交易也就得到确认。 这种基于算力寻找 nonce 串的共识机制成为 PoW(Proof of Work). (还有很多其他共识机制 PoX, 如 PoS (stake)…) 5. 区块链的演化比特币区块链支持简单的脚本计算, 仅限于数字画笔相关的处理. 还可以将区块链上执行的处理过程进一步泛化,即提供 智能合约 Smart Contract. 由此提供除货币交易功能外更灵活的合约共功能,执行更为复杂的操作. 6. 关键问题与挑战 6.1. 抗抵赖与隐私保护 怎么防止交易记录被篡改 怎么证明交易双方的身份 怎么保护交易双方的隐私 6.2. 分布式共识指标: 容错的结点比例, 决策收敛速度, 出错后的恢复,动态特性等. 6.3. 扩展性不能简单得增加结点来扩展整个系统的处理能力. 对于比特币和以太坊区块链而言，网络中每个参与维护的核心节点都要保持一份完整的存储，并且进行智能合约的处理。此时，整个网络的总存储和计算能力，取决于单个节点的能力。甚至当网络中节点数过多时，可能会因为一致性的达成过程延迟降低整个网络的性能。尤其在公有网络中，由于大量低性能处理节点的存在，问题将更加明显。 要解决这个问题，根本上是放松对每个节点都必须参与完整处理的限制（当然，网络中节点要能合作完成完整的处理），这个思路已经在超级账本中得到应用；同时尽量减少核心层的处理工作。 在联盟链模式下，还可以专门采用高性能的节点作为核心节点，用相对较弱的节点仅作为代理访问节点。 6.4. 数据库和存储系统区块链网络中的大量信息需要写到文件和数据库中进行存储。 预测将可能出现更具针对性的“块数据库（BlockDB）”，专门服务类似区块链这样的新型数据业务，其中每条记录将包括一个完整的区块信息，并天然地跟历史信息进行关联，一旦写入确认则无法修改。所有操作的最小单位将是一个块。为了实现这种结构，需要原生支持高效的签名和加解密处理。 6.5. 认识上的误区区块链不等于数据库。虽然区块链也可以用来存储数据，但它要解决的核心问题是多方的互信问题。单纯从存储数据角度，它的效率可能不高，不建议把大量的原始数据放到区块链系统上。 7. 应用场景 7.1. 金融服务区块链带来的潜在优势包括降低交易成本、减少跨组织交易风险等。 7.2. 征信管理区块链平台将可能提供前所未有规模的相关性极高的数据，这些数据可以在时空中准确定位，并严格关联到用户。因此，基于区块链提供数据进行征信管理，将大大提高信用评估的准确率，同时降低评估成本 另外，跟传统依靠人工的审核过程不同，区块链中交易处理完全遵循约定自动化执行。基于区块链的信用机制将天然具备稳定性和中立性。 7.3. 权属管理区块链技术可以用于产权、版权等所有权的管理和追踪。其中包括汽车、房屋、艺术品等各种贵重物品的交易等，也包括数字出版物，以及可以标记的数字资源。目前权属管理领域存在的几个难题是： 物品所有权的确认和管理； 交易的安全性和可靠性保障； 必要的隐私保护机制。 利用区块链技术，物品的所有权是写在数字链上的，谁都无法修改。并且一旦出现合同中约定情况，区块链技术将确保合同能得到准确执行。这能有效减少传统情况下纠纷仲裁环节的人工干预和执行成本 7.4. 资源共享相比于依赖于中间方的资源共享模式，基于区块链的模式有潜力更直接的连接资源的供给方和需求方，其透明、不可篡改的特性有助于减小摩擦。 7.5. 贸易管理区块链技术可以帮助自动化国际贸易和物流供应链领域中繁琐的手续和流程。基于区块链设计的贸易管理方案会为参与的多方企业带来极大的便利。另外，贸易中销售和法律合同的数字化、货物监控与检测、实时支付等方向都可能成为创业公司的 7.6. 物联网物联网络中每一个设备分配地址，给该地址所关联一个账户，用户通过向账户中支付费用可以租借设备，以执行相关动作，从而达到租借物联网的应用。 典型的应用包括 PM2.5 监测点的数据获取、温度检测服务、服务器租赁、网络摄像头数据调用等等。 另外，随着物联网设备的增多、边沿计算需求的增强，大量设备之间形成分布式自组织的管理模式，并且对容错性要求很高。区块链自身分布式和抗攻击的特点可以很好地融合到这一场景中。 8. 分布式系统 8.1. 一致性问题(Consistency)对于系统中的多个服务结点,给定一系列操作, 在协议(某种共识算法)保障下, 使得它们对处理结果达成某种程度的一致存在的问题 节点之间的网络通讯是不可靠的，包括任意延迟和内容故障； 节点的处理可能是错误的，甚至节点自身随时可能宕机； 同步调用会让系统变得不具备可扩展性。 解决的基本思想: 将可能引发不一致的并行操作串行化 8.1.1. 理想一致性分布式系统一致性应满足 可终止性（Termination）：一致的结果在有限时间内能完成； 共识性（Consensus）：不同节点最终完成决策的结果应该相同； 合法性（Validity）：决策的结果必须是其它进程提出的提案。 8.1.2. 带约束的一致性理想情况的强一致性是很难达到的. 其实实际需求并没有那么强,可以适当放宽一致性要求. 8.2. 共识算法由于响应请求往往存在时延、网络会发生中断、节点会发生故障、甚至存在恶意节点故意要破坏系统, 不能简单地通过多播过程投票. 一般地，把故障（不响应）的情况称为“非拜占庭错误”，恶意响应的情况称为“拜占庭错误”（对应节点为拜占庭节点）。 8.2.1. Paxos &amp; Raft这种算法解决的是对于 分布式系统中存在故障(fault), 但不存在恶意(corrupt)结点场景(即可能消息丢失或重复, 但无错误信息)下的共识达成(consensus)问题. 8.2.2. FLP不可能原理 在网络可靠，存在节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。 即一个可扩展的分布式系统的共识问题的下限是无解 它告诉人们，不要浪费时间去为异步分布式系统设计在任意场景下都能实现共识的算法。 但是可以在付出一定代价下, 达到一定的目标. 下面的CAP原理告诉我们能做到多少 8.3. CAP原理分布式系统不可能同时确保一致性（Consistency）、可用性（Availablity）和分区容忍性（Partition），设计中往往需要弱化对某个特性的保证。 一致性（Consistency）：任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性； 可用性（Availablity）：在有限时间内，任何非失败节点都能应答请求； 分区容忍性（Partition）：网络可能发生分区，即节点之间的通信不可保障。 CAP 不能同时满足,设计系统时针对应用场景弱化对某个特性的支持 弱化一致性: 如网站静态页面内容, 实时性较弱的查询类数据库 弱化可用性: 对结果一致性很敏感的应用. 如银行取款机 弱化分区容忍性: 如 某些关系型数据库, ZooKeeper 8.4. ACID 原则即 Atomicity（原子性）、Consistency（一致性）、Isolation（隔离性）、Durability（持久性）。ACID 原则描述了对分布式数据库的一致性需求，同时付出了可用性的代价。Atomicity：每次操作是原子的，要么成功，要么不执行；Consistency：数据库的状态是一致的，无中间状态；Isolation：各种操作彼此互相不影响；Durability：状态的改变是持久的，不会失效。 一个与之相对的原则是 BASE（Basic Availiability，Soft state，Eventually Consistency），牺牲掉对一致性的约束（最终一致性），来换取一定的可用性。 9. 密码学技术 9.1. hash算法是一种信息摘要, 可以用于检验内容的完全性, 一致性等. 流行的有 md5, sha-1, sha-2(Secure Hash Algorithm), sha-1已被证明不具备”强抗碰撞性” 9.2. 加解密算法 组件包括: 加解密算法,加密密钥,解密密钥.根据加解密的密钥是否相同,可以分成对称加密与非对称加密(asymmetrix cryptography). 9.2.1. 对称对称密码从实现原理上可以分为两种：分组密码和序列密码。前者将明文切分为定长数据块作为加密单位，应用最为广泛。后者则只对一个字节进行加密，且密码不断变化，只用在一些特定领域，如数字媒介的加密等。代表算法 DES（Data Encryption Standard）：经典的分组加密算法,将 64 位明文加密为 64 位的密文，其密钥长度为 56位 + 8 位校验。现在已经很容易被暴力破解。 3DES：三重 DES 操作：加密 —&gt; 解密 —&gt; 加密，处理过程和加密强度优于 DES，但现在也被认为不够安全。 AES（Advanced Encryption Standard）：分组算法，分组长度为 128、192、256 位三种。AES 的优势在于处理速度快，整个过程可以数学化描述，目前尚未有有效的破解手段。 适用于大量数据的加解密；不能用于签名场景；需要提前分发密钥。 9.2.2. 非对称加密非对称加密是现代密码学历史上最为伟大的发明，可以很好的解决对称加密需要的提前分发密钥问题。 一般比对称加解密算法慢两到三个数量级；同时加密强度相比对称加密要差。非对称加密算法的安全性往往需要基于数学问题来保障，目前主要有基于大数质因子分解、离散对数、椭圆曲线等几种思路。代表算法: RSA：经典的公钥算法。算法利用了对大数进行质因子分解困难的特性，但目前还没有数学证明两者难度等价，或许存在未知算法在不进行大数分解的前提下解密。 Diffie-Hellman 密钥交换：基于离散对数无法快速求解，可以在不安全的通道上，双方协商一个公共密钥。 ElGamal：利用了模运算下求离散对数困难的特性。被应用在PGP 等安全工具中。 椭圆曲线算法（Elliptic curve cryptography，ECC）：基于对加解密算法椭圆曲线上特定点进行特殊乘法逆运算难以计算的特性。一般适用于签名场景或密钥协商，不适于大量数据的加解密。 RSA 算法等已被认为不够安全，一般推荐采用椭圆曲线系列算法。 9.2.3. 混合加密机制即先用计算复杂度高的非对称加密协商一个临时的对称加密密钥（会话密钥，一般相对内容来说要短的多），然后双方再通过对称加密对传递的大量数据进行加解密处理。典型的场景是现在大家常用的 HTTPS 机制。HTTPS 实际上是利用了 Transport LayerSecurity/Secure Socket Layer（TLS/SSL）来实现可靠的传输。TLS 为 SSL 的升级版本 9.3. 数字签名类似在纸质合同上签名确认合同内容，数字签名用于证实某数字内容的完整性（integrity）和来源（或不可抵赖，non-repudiation）。 一个典型的场景是，A 要发给 B 一份信息.A 先对文件进行摘要，然后用自己的私钥进行加密，将文件和加密串都发给B。B 收到文件和加密串后，用 A 的公钥来解密加密串，得到原始的数字摘要，跟对文件进行摘要后的结果进行比对。 9.4. 数字证书数字证书用来证明某个公钥是谁的，并且内容是正确的。 数字证书内容可能包括版本、序列号、签名算法类型、签发者信息、有效期、被签发人、签发的公开密钥、CA 数字签名、其它信息等等，一般使用最广泛的标准为 ITU 和 ISO 联合制定的 X.509 规范。其中，最重要的包括 签发的公开密钥 、 CA 数字签名 两个信息。因此，只要通过这个证书就能证明某个公钥是合法的，因为带有 CA 的数字签名。 9.5. Merkle 树 9.5.1. 定义默克尔树（又叫哈希树）是一种二叉树，由一个根节点、一组中间节点和一组叶节点组成。最下面的叶节点包含存储数据或其哈希值，每个中间节点是它的两个孩子节点内容的哈希值，根节点也是由它的两个子节点内容的哈希值组成。 9.5.2. 特点 底层数据的任何变动，都会传递到其父亲节点，一直到树根。 9.5.3. 应用场景 快速比较大量数据：当两个默克尔树根相同时，则意味着所代表的数据必然相同。 快速定位修改：例如上例中，如果 D1 中数据被修改，会影响到 N1，N4 和 Root。因此，沿着 Root —&gt; N4 —&gt; N1，可以快速定位到发生改变的 D1； 零知识证明：例如如何证明某个数据（D0……D3）中包括给定内容 D0，很简单，构造一个默克尔树，公布 N0，N1，N4，Root，D0 拥有者可以很容易检测 D0 存在，但不知道其它内容。 9.6. 同态加密同态加密（Homomorphic Encryption）是一种特殊的加密方法，允许对密文进行处理得到仍然是加密的结果，即对密文直接进行处理，跟对明文进行处理再加密，得到的结果相同。从代数的角度讲，即同态性。(保运算) 10. 比特币 10.1. 从实体货币到数字货币 10.2. 去中心化实现数字货币的难题 货币的防伪：谁来负责对货币的真伪进行鉴定； 货币的交易：如何确保货币从一方安全转移到另外一方； 避免双重支付：如何避免同一份货币支付给多个接收者。 10.3. 原理与设计比特币网络是一个分布式的点对点网络，网络中的矿工通过“挖矿”来完成对交易记录的记账过程，维护网络的正常运行。 10.3.1. 基本交易过程比特币中没有账户的概念。因此，每次发生交易，用户需要将交易记录写到比特币网络账本中，等网络确认后即可认为交易完成。 除了挖矿获得奖励的 coinbase 交易只有输出，正常情况下每个交易需要包括若干输入和输出，未经使用（引用）的交易的输出（Unspent Transaction Outputs，UTXO）可以被新的交易引用作为其合法的输入。被使用过的交易的输出（Spent Transaction Outputs，STXO），则无法被引用作为合法输入。 10.3.2. 概念 账户 比特币采用了非对称的加密算法，用户自己保留私钥，对自己发出的交易进行签名确认，并公开公钥。比特币的账户地址其实就是用户公钥经过一系列 Hash（HASH160，或先进行 SHA256，然后进行 RIPEMD160）及编码运算后生成的 160 位（20 字节）的字符串。 交易 易可能包括如下信息：付款人地址：合法的地址，公钥经过 SHA256 和 RIPEMD160 两次 Hash，得到 160 位Hash 串；付款人对交易的签字确认：确保交易内容不被篡改；付款人资金的来源交易 ID：从哪个交易的输出作为本次交易的输入；交易的金额：多少钱，跟输入的差额为交易的服务费；收款人地址：合法的地址；时间戳：交易何时能生效节点收到交易信息后，将进行如下检查：交易是否已经处理过；交易是否合法。包括地址是否合法、发起交易者是否是输入地址的合法拥有者、是否是UTXO；交易的输入之和是否大于输出之和。 交易脚本: 保障交易的完成的核心机制 区块 比特币区块链的一个区块不能超过 1 MB，将主要包括如下内容：区块大小：4 字节；区块头：80 字节：交易个数计数器：1~9 字节；所有交易的具体内容，可变长，匹配 Merkle 树叶子节点顺序。 避免作恶: 在一个开放的网络中，无法通过技术手段保证每个人都是合作的。但可以通过经济博弈来让合作者得到利益，让非合作者遭受损失和风险 . 如共识机制PoW 10.4. 闪电网络比特币交易性能：全网每秒 7 笔左右的交易速度，远低于传统的金融交易系统 提出闪电网络的解决方法主要通过引入智能合约的思想来完善链下的交易渠道。核心的概念主要有两个：RSMC（Recoverable Sequence Maturity Contract）和 HTLC（Hashed TimelockContract）。前者解决了链下交易的确认问题，后者解决了支付通道的问题。 10.5. 侧链以比特币区块链作为主链（Parent chain），其他区块链作为侧链，二者通过双向挂钩（Two-way peg），可实现比特币从主链转移到侧链进行流通。 侧链可以是一个独立的区块链，有自己按需定制的账本、共识机制、交易类型、脚本和合约的支持等。侧链不能发行比特币，但可以通过支持与比特币区块链挂钩来引入和流通一定数量的比特币。当比特币在侧链流通时，主链上对应的比特币会被锁定，直到比特币从侧链回到主链。可以看到，侧链机制可将一些定制化或高频的交易放到比特币主链之外进行，实现了比特币区块链的扩展。侧链的核心原理在于能够冻结一条链上的资产，然后在另一条链上产生，可以通过多种方式来实现, 如 SPV 11. 以太坊以太坊区块链底层也是一个类似比特币网络的 P2P 网络平台，智能合约运行在网络中的以太坊虚拟机里。网络自身是公开可接入的，任何人都可以接入并参与网络中数据的维护，提供运行以太坊虚拟机的资源。 11.1. 特点跟比特币项目相比 支持图灵完备的智能合约，设计了编程语言 Solidity 和虚拟机 EVM； 选用了内存需求较高的哈希函数，避免出现强算力矿机、矿池攻击； 叔块（Uncle Block）激励机制，降低矿池的优势，并减少区块产生间隔（10 分钟降低到15 秒左右）； *采用账户系统和世界状态，而不是 UTXO，容易支持更复杂的逻辑； 通过 Gas 限制代码执行指令数，避免循环执行攻击； 支持 PoW 共识算法，并计划支持效率更高的 PoS 算法。 11.2. 概念 智能合约:即以计算机程序的方式来缔结和运行各种合约。 账户: 比特币在设计中并没有账户（Account）的概念，而是采用了UTXO 模型记录整个系统的状态。任何人都可以通过交易历史来推算出用户的余额信息。而以太坊则直接用账户来记录系统状态。每个账户存储余额信息、智能合约代码和内部数据存储等。 以太坊账户分为两类 合约账户：存储执行的智能合约代码，只能被外部账户来调用激活； 外部账户：以太币拥有者账户，对应到某公钥。账户包括 nonce、balance、storageRoot、codeHash 等字段，由个人来控制。 交易: 是指从一个账户到另一个账户的消息数据 包括如下字段： * to：目标账户地址。 * value：可以指定转移的以太币数量。 * nonce：交易相关的字串，用于防止交易被重放。 * gasPrice：执行交易需要消耗的 Gas 价 格。 * startgas：交易消耗的最大 Gas 值。 * signature：签名信息。 在发送交易时，用户需要缴纳一定的交易费用，通过以太币方式进行支付和消耗。 燃料（Gas），控制某次交易执行指令的上限。每执行一条合约指令会消耗固定的燃料。当某个交易还未执行结束，而燃料消耗完时，合约执行终止并回滚状态。 Gas 可以跟以太币进行兑换。需要注意的是，以太币的价格是波动的，但运行某段智能合约的燃料费用可以是固定的，通过设定 Gas 价格等进行调节 11.3. 主要设计 运行环境: EVM 以太坊虚拟机是一个隔离的轻量级虚拟机环境，运行在其中的智能合约代码无法访问本地网络、文件系统或其它进程。对同一个智能合约来说，往往需要在多个以太坊虚拟机中同时运行多份，以确保整个区块链数据的一致性和高度的容错性。另一方面，这也限制了整个网络的容量。 开发语言: Solidity, vyper… 智能合约编写完毕后，用编译器编译为以太坊虚拟机专用的二进制格式（EVM bytecode），由客户端上传到区块链当中，之后在矿工的以太坊虚拟机中执行。 交易模型: 以太坊的账户模型与比特币的 UXTO 模型对比 共识: 基于成熟的 PoW 共识的变种算法 Ethash 协议 客户端和开发库 以太坊客户端可用于接入以太坊网络，进行账户管理、交易、挖矿、智能合约等各方面操作。 12. 超级账本-HyperldgerHyperledger 项目是首个面向企业的开放区块链技术的重要探索.该项目试图打造一个透明、公开、去中心化的分布式账本项目，作为区块链技术的开源规范和标准，让更多的应用能更容易的建立在区块链技术之上。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>数字货币</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『算法』概述]]></title>
    <url>%2Falgorithm-general.html</url>
    <content type="text"><![CDATA[1. 算法 2. 可以解决哪些类型的问题 3. 算法分析 4. 算法设计 4.1. 分治(divide and conquer) 5. 递归式 5.1. 代换法 5.1.1. 步骤 5.1.2. 例子 5.1.3. 放缩 5.1.4. 改变变量 5.2. 递归树 5.3. 主方法(master method) 5.3.1. 记忆 5.3.2. 证明 5.3.2.1. 证明当 n 为 b 的正合幂时成立 5.3.2.2. 分析扩展至所有正整数 n 都成立 6. 随机算法 6.1. 随机排列数组(shuffle) 6.1.1. PERMUTE-BY-SORTING 6.1.2. RANDOMIZE-IN-PLACE 7. 组合方程的近似算法 8. 概率分析与指示器变量例子 8.1. 球与盒子 8.2. 序列 9. 摊还分析 9.1. 聚合分析(aggregate analysis) 9.2. 核算法 (accounting method) 9.3. 势能法(potential method) 1. 算法定义良好的计算过程,取输入,并产生输出. 即算法是一系列的计算步骤,将输入数据转化为输出结果 算法的特点: 有穷性 确定性 可行性 0 或多个输入 1 或多个输出 2. 可以解决哪些类型的问题 大数据的存储,以及开发出进行这方面数据分析的工具 网络数据的传输,寻路, 搜索 电子商务密码, (数值算法,数论) 资源分配,最大效益 … 3. 算法分析衡量算法的优劣 $\omicron,O,\Omega,\Theta$ 最坏情况, 平均情况 增长的量级$ O(1), O(log^*n), O(logn), O(n), O(n^k), O(a^n) $ $\log^{*}(\log x) = log^{\}x-1$ 4. 算法设计 4.1. 分治(divide and conquer)结构上是递归的,步骤: 分解,解决, 合并eg. 快排,归并排序, 矩阵乘法(Strassen $O(log_2 7)$ 5. 递归式 $T(n) = aT(\frac{n} {b})+f(n)$ 5.1. 代换法 5.1.1. 步骤 猜测解的形式 用数学归纳法找出常数 5.1.2. 例子$T(n) = 2T(\frac{n} {2})+n$猜测$T(n) = O(nlogn)$证明 $ T(n)\leqslant cnlogn$归纳奠基 n=2,3归纳假设 $T(\frac{n} {2}) \leqslant \frac{cn}{2}$递归$\begin{aligned}T(n) &amp;\leqslant 2c\frac{n}{2}log(\frac{n}{2}) + n \leqslant cnlog(\frac{n}{2}) \\\end{aligned}$ 5.1.3. 放缩对于 $T(n) = 2T(\frac{cn}{2}) + 1$如果 直接猜测 $T(n) = O (n)$ 不能证明,而且不要猜测更高的界 $O (n^2)$可以放缩为 n-b 5.1.4. 改变变量对于 $ T(n) = 2T(\sqrt{n})+logn $可以 令 m = logn, 得到$T(2^m) = 2T(m^{\frac{m}{2}}) + m $令 $S(m) = T(2^m)$得到 $ S(m) = 2S(\frac{m}{2}) + m $ T(n)=T(2^m)=S(m)=\Theta(m\log m)=\Theta(\log n \log^2 n) 5.2. 递归树例如 $T(n) = 3T(\frac{n}{4}) + c n^2$不妨假设 n 为4的幂, 则有如下递归树 T(n) = \sum_{i=0}^{ {\log_4 n}-1}cn^2*(\frac{3}{16})^i + \Theta(n^{\log4 3})每个结点是代价, 将每层加起来即可 5.3. 主方法(master method)对于 $T(n) = aT(\frac{n} {b})+f(n)$ \begin{aligned} T(n)=\begin{cases} \Theta(n^{log_b a}),\quad f(n)=O(n^{ {log_b a}-\epsilon}) \\ \Theta(n^{log_b a}logn),\quad f(n)=\Theta(n^{log_b a}) \\ \Theta(f(n)),\quad f(n)=\Omega(n^{ {log_b a}+ \epsilon}),af(\frac{n}{b})\leqslant cf(n) \\ \qquad \qquad \quad \text{其中常数c]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『数据结构』红黑树(red-black tree)]]></title>
    <url>%2Fred-black-tree.html</url>
    <content type="text"><![CDATA[1. 定义与性质 1.1. 数据域 1.2. 红黑性质 1.3. 黑高度 2. 旋转 3. 插入 3.1. 二叉查找树的插入 3.2. 颜色调整与旋转 3.2.1. 问题 3.2.2. 情况 3.2.2.1. case1: x 的叔叔是红色的 3.2.2.2. case2: x 的叔叔是黑色, x,p(x), p(p(x)),方向为 left-right 或者 right-left 3.2.2.3. case3: x 的叔叔是黑色, x,p(x), p(p(x)),方向为 left-left 或者 right-right 3.2.3. 总体解决方案 4. 删除 4.1. 二叉查找树删除结点 4.2. 调整颜色与旋转 5. 数据结构的扩张 5.1. 平衡树的扩张 6. python 代码 7. 参考 1. 定义与性质红黑树是一种平衡的二叉查找树 1.1. 数据域每个结点有 5 个数据域 color: red or black key: keyword left: pointer to left child right:pointer to right child p: pointer to nil leaf 1.2. 红黑性质满足下面的 红黑性质 的二叉查找树就是红黑树: 每个结点或是红色或是黑色 根是黑 nil leaf 是 黑 红结点的孩子是黑 从每个结点出发,通过子孙到达叶子结点的各条路径上 黑结点数相等 如,叶子结点 是 nil, 即不存储任何东西, 为了编程方便,相对的,存有数据的结点称为内结点 为了节省空间, 可以如下实现, 只需要一个 nil 结点 1.3. 黑高度从某个结点 x 到叶结点的黑色结点数,称为此结点的黑高度, 记为 $h_b(x)$树的黑高度是根的黑高度 以 x 为 根的子树至少包含 $2^{h_b(x)}-1$个结点 一颗有 n 个内结点的红黑树高度至多为$2lg(n+1)$ 可用归纳法证明1证明 2:设树高 h由红黑性质4, 根结点到叶子路径上的黑结点数至少 $\frac{h}{2}$,即 $h_b(root)\geqslant \frac{h}{2}$再由1, n \geqslant 2^{h_b(x)} -1 \geqslant 2^{\frac{h}{2}} -1即 $ h\leqslant 2lg(n+1)$ 2. 旋转由于上面证明的红黑树高为 $O(logn)$,红黑树的 insert, delete, search 等操作都是, $O(logn)$.进行了 insert, delete 后可能破坏红黑性质, 可以通过旋转来保持. 下面是对结点 x 进行 左旋与右旋.注意进行左旋时, 右孩子不是 nil(要用来作为旋转后 x 的双亲), 同理 右旋的结点的左孩子不是nil总结起来就是: 父亲旋转,顺时针就是右旋,逆时针就是左旋, 旋转的结果是儿子成为原来父亲的新父亲, 即旋转的结点下降一层, 它的一个儿子上升一层. 3. 插入插入的过程: 先同二叉查找树那样插入, 做为叶子(不为空) 然后将新结点的 左右孩子设为 nil , 颜色设为红色 最后再进行颜色调整以及旋转(维持红黑性质) 这是算法导论1上的算法123456789101112131415161718RB-INSERT(T, z) y ← nil[T] // 新建节点“y”，将y设为空节点。 x ← root[T] // 设“红黑树T”的根节点为“x” while x ≠ nil[T] // 找出要插入的节点“z”在二叉树T中的位置“y” do y ← x if key[z] &lt; key[x] then x ← left[x] else x ← right[x] p[z] ← y // 设置 “z的父亲” 为 “y” if y = nil[T] then root[T] ← z // 情况1：若y是空节点，则将z设为根 else if key[z] &lt; key[y] then left[y] ← z // 情况2：若“z所包含的值” &lt; “y所包含的值”，则将z设为“y的左孩子” else right[y] ← z // 情况3：(“z所包含的值” &gt;= “y所包含的值”)将z设为“y的右孩子” left[z] ← nil[T] // z的左孩子设为空 right[z] ← nil[T] // z的右孩子设为空。至此，已经完成将“节点z插入到二叉树”中了。 color[z] ← RED // 将z着色为“红色” RB-INSERT-FIXUP(T, z) // 通过RB-INSERT-FIXUP对红黑树的节点进行颜色修改以及旋转，让树T仍然是一颗红黑树 3.1. 二叉查找树的插入可以用python 实现如下12345678910111213141516171819202122232425def insert(self,nd): if not isinstance(nd,node): nd = node(nd) elif nd.isBlack: nd.isBlack = False if self.root is None: self.root = nd self.root.isBlack = True else: parent = self.root while parent: if parent == nd : return None if parent&gt;nd: if parent.left : parent = parent.left else: parent.left = nd break else: if parent.right: parent = parent.right else: parent.right = nd break self.fixUpInsert(parent,nd) 3.2. 颜色调整与旋转 3.2.1. 问题在插入后,可以发现后破坏的红黑性质只有以下两条(且互斥) root 是红 (这可以直接将root 颜色设为黑调整) 红结点的孩子是黑 所以下面介绍如何保持 红结点的孩子是黑 , 即插入结点的双亲结点是红的情况. 下面记 结点 x 的 双亲为 p(x), 新插入的结点为 x, 记 uncle 结点 为 u(x) 由于 p(x) 是红色, 而根结点是黑色, 所以 p(x)不是根, p(p(x))存在 3.2.2. 情况有如下三种情况 每种情况的解决方案如下 3.2.2.1. case1: x 的叔叔是红色的这里只需改变颜色, 将 p(x)变为 黑, p(p(x))变为红, u(x) 变为黑色 (x为右孩子同样) 3.2.2.2. case2: x 的叔叔是黑色, x,p(x), p(p(x)),方向为 left-right 或者 right-left即 x,p(x), p(p(x)) 成折线状 3.2.2.3. case3: x 的叔叔是黑色, x,p(x), p(p(x)),方向为 left-left 或者 right-right即 x,p(x), p(p(x)) 成直线状 当 x 为右孩子时, 通过旋转变成p(x) 的双亲, 然后相当于 新插入 p(x)作为左孩子, 再进行转换. 即将新结点的双亲向上一层旋转,颜色变为黑色, 而新节点的祖父向下一层, 颜色变为红色 3.2.3. 总体解决方案我最开始也没有弄清楚, 有点绕晕的感觉, 后来仔细读了书上伪代码, 然后才发现就是一个状态机, 画出来就一目了然了. 现在算是知其然了, 那么怎样知其所以然呢? 即 为什么要分类这三个 case, 不重不漏了吗? 其实也简单, 只是太繁琐.就是将各种情况枚举出来, 一一分析即可. 我最开始试过, 但是太多,写在代码里很容易写着写着就混了.而算法导论上分成这三个case , 很简洁, 只是归纳了一下而已. 如果想看看枚举情况的图与说明,可以参考2 . 算法导论上的伪代码1234567891011121314151617RB-INSERT-FIXUP(T, z)while color[p[z]] = RED // 若“当前节点(z)的父节点是红色”，则进行以下处理。 do if p[z] = left[p[p[z]]] // 若“z的父节点”是“z的祖父节点的左孩子”，则进行以下处理。 then y ← right[p[p[z]]] // 将y设置为“z的叔叔节点(z的祖父节点的右孩子)” if color[y] = RED // Case 1条件：叔叔是红色 then color[p[z]] ← BLACK ▹ Case 1 // (01) 将“父节点”设为黑色。 color[y] ← BLACK ▹ Case 1 // (02) 将“叔叔节点”设为黑色。 color[p[p[z]]] ← RED ▹ Case 1 // (03) 将“祖父节点”设为“红色”。 z ← p[p[z]] ▹ Case 1 // (04) 将“祖父节点”设为“当前节点”(红色节点) else if z = right[p[z]] // Case 2条件：叔叔是黑色，且当前节点是右孩子 then z ← p[z] ▹ Case 2 // (01) 将“父节点”作为“新的当前节点”。 LEFT-ROTATE(T, z) ▹ Case 2 // (02) 以“新的当前节点”为支点进行左旋。 color[p[z]] ← BLACK ▹ Case 3 // Case 3条件：叔叔是黑色，且当前节点是左孩子。(01) 将“父节点”设为“黑色”。 color[p[p[z]]] ← RED ▹ Case 3 // (02) 将“祖父节点”设为“红色”。 RIGHT-ROTATE(T, p[p[z]]) ▹ Case 3 // (03) 以“祖父节点”为支点进行右旋。 else (same as then clause with "right" and "left" exchanged) // 若“z的父节点”是“z的祖父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。color[root[T]] ← BLACK 我用python 实现如下. 由于左右方向不同, 如果向上面伪代码那样实现, fixup 代码就会有两份类似的(即 right left 互换), 为了减少代码冗余, 我就定义了 setChild, getChild 函数, 传递左或是右孩子这个方向的数据(代码中是isLeft), 所以下面的就是完整功能的 fixup, 可以减少一般的代码量, haha😄,(下文 删除结点同理) 其实阅读代码也简单, 可以直接当成 isLeft 取真值.1234567891011121314151617181920212223242526272829303132333435def fixUpInsert(self,parent,nd): ''' adjust color and level, there are two red nodes: the new one and its parent''' while not self.checkBlack(parent): grand = self.getParent(parent) isLeftPrt = grand.left is parent uncle = grand.getChild(not isLeftPrt) if not self.checkBlack(uncle): # case 1: new node's uncle is red self.setBlack(grand, False) self.setBlack(grand.left, True) self.setBlack(grand.right, True) nd = grand parent = self.getParent(nd) else: # case 2: new node's uncle is black(including nil leaf) isLeftNode = parent.left is nd if isLeftNode ^ isLeftPrt: # case 2.1 the new node is inserted in left-right or right-left form # grand grand # parent or parent # nd nd parent.setChild(nd.getChild(isLeftPrt),not isLeftPrt) nd.setChild(parent,isLeftPrt) grand.setChild(nd,isLeftPrt) nd,parent = parent,nd # case 2.2 the new node is inserted in left-left or right-right form # grand grand # parent or parent # nd nd grand.setChild(parent.getChild(not isLeftPrt),isLeftPrt) parent.setChild(grand,not isLeftPrt) self.setBlack(grand, False) self.setBlack(parent, True) self.transferParent(grand,parent) self.setBlack(self.root,True) 4. 删除算法导论上的算法 写的很简练👍 4.1. 二叉查找树删除结点下面 z 是要删除的结点, y 是 其后继或者是它自己, x 是 y 的一个孩子(如果 y 的孩子为 nil,则为 nli, 否则 y 只有一个非 nil 孩子, 为 x) 当 z 孩子全是 nil (y==z): 直接让其双亲对应的孩子为 nil 当 z 只有一个非 nil 孩子 x (y==z): 如果 z 为根, 则让 x 为根. 让 y 的双亲连接到 x 当 z 有两个非nil孩子(y!=z): 复制其后继 y 的内容到 z (除了指针,颜色) , 将其后继 y 的孩子(最多只有一个 非 nil ,不然就不是后继了)连接到其后继的双亲, 删除 其后继y, 即3 如果要删除有两个孩子的结点 z , 则找到它的后继y(前趋同理), 可以推断 y 一定没有左孩子, 右孩子可能有,可能没有. 也就是最多一个孩子.所以将 y 的值复制到 x 位置, 现在相当于删除 y 处的结点.这样就化为 删除的结点最多一个孩子的情况. 4.2. 调整颜色与旋转 可以发现只有当 y 是黑色,才进行颜色调整以及旋转(维持红黑性质), 因为如果删除的是红色, 不会影响黑高度, 所有红黑性质都不会破坏伪代码如下, (我的python代码见文末) 如果被删除的结点 y 是黑色的, 有三种破坏红黑性质的情况 y是根, 则 y 的一个红色孩子成为新根 进行删除结点过程中, p(y) 的孩子有 x, 两者都是红色 删除 y 导致包含y 的路径上的黑结点 少 1个 修复3的思路:如果可能,在兄弟一支,通过旋转,改变颜色修复否则, 将红结点一直向上推(因为当前路径上少了一个黑结点,向上推的过程中使红结点所在的子树都少一个黑结点), 直到到达树根, 那么全部路径都少一个黑结点, 3就修复了, 这时只需将根设为黑就修复了 1 代码中的 while 循环的目的是将额外的黑色沿树上移,直到 x 指向一个红黑结点 x 指向根,这时可以简单地消除额外的黑色 颜色修改与旋转 在 while 中, x 总是指向具有双重黑色的那个非根结点, 在第 2 行中要判断 x 是其双亲的左右孩子w 表示 x 的相抵. w 不能为 nil(因为 x 是双重黑色) 算法中的四种情况如图所示 即 x 的兄弟 w 是红色的 x 的兄弟 w 是黑色的, w的两个孩子都是黑色的 x 的兄弟 w 是黑色的, w 的左孩子是红,右孩子是黑 x 的兄弟 w 是黑色的, w 的孩子是红色的 注意上面都是先考虑的左边, 右边可以对称地处理. 同插入一样, 为了便于理解, 可以作出状态机.而且这些情形都是归纳化简了的, 你也可以枚举列出基本的全部情形. 5. 数据结构的扩张 5.1. 平衡树的扩张通过在平衡树(如红黑树上的每个结点 加上 一个数据域 size (表示以此结点为根的子树的结点数.) 可以使获得第 i 大的数 的时间复杂度为 $O(logn)$ 在 $O(n)$ 时间内建立, python代码如下123def setSize(root): if root is None:return 0 root.size = setSize(root.left) + setSize(root.right)+1 在$O(logn)$时间查找,12345678def find(root,i): r = root.left.size +1 if r==i: return root if r &gt; i: return find(root.left,i) else: return find(root.right,i-r) 6. python 代码github地址 我用了 setChild, getChild 来简化代码量, 其他的基本上是按照算法导论上的伪代码提到的case 来实现的. 然后display 只是测试的时候,为了方便调试而层序遍历打印出来 效果如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270''' mbinary########################################################################## File : redBlackTree.py# Author: mbinary# Mail: zhuheqin1@gmail.com# Blog: https://mbinary.github.io# Github: https://github.com/mbinary# Created Time: 2018-07-14 16:15# Description:#########################################################################'''from functools import total_orderingfrom random import randint, shuffle@total_orderingclass node: def __init__(self,val,left=None,right=None,isBlack=False): self.val =val self.left = left self.right = right self.parent= None self.isBlack = isBlack def __lt__(self,nd): return self.val &lt; nd.val def __eq__(self,nd): return nd is not None and self.val == nd.val def setChild(self,nd,isLeft): if isLeft: self.left = nd else: self.right = nd if nd is not None: nd.parent = self def getChild(self,isLeft): if isLeft: return self.left else: return self.right def __bool__(self): return self.val is not None def __str__(self): color = 'B' if self.isBlack else 'R' val = '-' if self.parent==None else self.parent.val return f'&#123;color&#125;-&#123;self.val&#125;' def __repr__(self): return f'node(&#123;self.val&#125;,isBlack=&#123;self.isBlack&#125;)'class redBlackTree: def __init__(self,unique=False): '''if unique is True, all node'vals are unique, else there may be equal vals''' self.root = None self.unique = unique @staticmethod def checkBlack(nd): return nd is None or nd.isBlack @staticmethod def setBlack(nd,isBlack): if nd is not None: if isBlack is None or isBlack: nd.isBlack = True else:nd.isBlack = False def setRoot(self,nd): if nd is not None: nd.parent=None self.root= nd def find(self,val): nd = self.root while nd: if nd.val ==val: return nd else: nd = nd.getChild(nd.val&gt;val) def getSuccessor(self,nd): if nd: if nd.right: nd = nd.right while nd.left: nd = nd.left return nd else: while nd.parent is not None and nd.parent.right is nd: nd = nd.parent return None if nd is self.root else nd.parent def rotate(self,prt,chd): '''rotate prt with the center of chd''' if self.root is prt: self.setRoot(chd) else: prt.parent.setChild(chd, prt.parent.left is prt) isLeftChd = prt.left is chd prt.setChild(chd.getChild(not isLeftChd), isLeftChd) chd.setChild(prt,not isLeftChd) def insert(self,nd): if nd.isBlack: nd.isBlack = False if self.root is None: self.setRoot(nd) self.root.isBlack = True else: parent = self.root while parent: if parent == nd : return None isLeft = parent &gt; nd chd = parent.getChild(isLeft) if chd is None: parent.setChild(nd,isLeft) break else: parent = chd self.fixUpInsert(parent,nd) def fixUpInsert(self,parent,nd): ''' adjust color and level, there are two red nodes: the new one and its parent''' while not self.checkBlack(parent): grand = parent.parent isLeftPrt = grand.left is parent uncle = grand.getChild(not isLeftPrt) if not self.checkBlack(uncle): # case 1: new node's uncle is red self.setBlack(grand, False) self.setBlack(grand.left, True) self.setBlack(grand.right, True) nd = grand parent = nd.parent else: # case 2: new node's uncle is black(including nil leaf) isLeftNode = parent.left is nd if isLeftNode ^ isLeftPrt: # case 2.1 the new node is inserted in left-right or right-left form # grand grand # parent or parent # nd nd self.rotate(parent,nd) #parent rotate nd,parent = parent,nd # case 3 (case 2.2) the new node is inserted in left-left or right-right form # grand grand # parent or parent # nd nd self.setBlack(grand, False) self.setBlack(parent, True) self.rotate(grand,parent) self.setBlack(self.root,True) def copyNode(self,src,des): '''when deleting a node which has two kids, copy its succesor's data to his position data exclude left, right , isBlack ''' des.val = src.val def delete(self,val): '''delete node in a binary search tree''' if isinstance(val,node): val = val.val nd = self.find(val) if nd is None: return self._delete(nd) def _delete(self,nd): y = None if nd.left and nd.right: y= self.getSuccessor(nd) else: y = nd py = y.parent x = y.left if y.left else y.right if py is None: self.setRoot(x) else: py.setChild(x,py.left is y) if y != nd: self.copyNode(y,nd) if self.checkBlack(y): self.fixUpDel(py,x) def fixUpDel(self,prt,chd): ''' adjust colors and rotate ''' while self.root != chd and self.checkBlack(chd): isLeft =prt.left is chd brother = prt.getChild(not isLeft) # brother is black lb = self.checkBlack(brother.getChild(isLeft)) rb = self.checkBlack(brother.getChild(not isLeft)) if not self.checkBlack(brother): # case 1: brother is red. converted to case 2,3,4 self.setBlack(prt,False) self.setBlack(brother,True) self.rotate(prt,brother) elif lb and rb: # case 2: brother is black and two kids are black. # conveted to the begin case self.setBlack(brother,False) chd = prt prt= chd.parent else: if rb: # case 3: brother is black and left kid is red and right child is black # rotate bro to make g w wl wr in one line # uncle's son is nephew, and niece for uncle's daughter nephew = brother.getChild(isLeft) self.setBlack(nephew,True) self.setBlack(brother,False) # brother (not isLeft) rotate self.rotate(brother,nephew) brother = nephew # case 4: brother is black and right child is red brother.isBlack = prt.isBlack self.setBlack(prt,True) self.setBlack(brother.getChild(not isLeft),True) self.rotate(prt,brother) chd = self.root self.setBlack(chd,True) def sort(self,reverse = False): ''' return a generator of sorted data''' def inOrder(root): if root is None:return if reverse: yield from inOrder(root.right) else: yield from inOrder(root.left) yield root if reverse: yield from inOrder(root.left) else: yield from inOrder(root.right) yield from inOrder(self.root) def display(self): def getHeight(nd): if nd is None:return 0 return max(getHeight(nd.left),getHeight(nd.right)) +1 def levelVisit(root): from collections import deque lst = deque([root]) level = [] h = getHeight(root) ct = lv = 0 while 1: ct+=1 nd = lst.popleft() if ct &gt;= 2**lv: lv+=1 if lv&gt;h:break level.append([]) level[-1].append(str(nd)) if nd is not None: lst += [nd.left,nd.right] else: lst +=[None,None] return level def addBlank(lines): width = 1+len(str(self.root)) sep = ' '*width n = len(lines) for i,oneline in enumerate(lines): k = 2**(n-i) -1 new = [sep*((k-1)//2)] for s in oneline: new.append(s.ljust(width)) new.append(sep*k) lines[i] = new return lines lines = levelVisit(self.root) lines = addBlank(lines) li = [''.join(line) for line in lines] length = 10 if li==[] else max(len(i) for i in li)//2 begin ='\n'+ 'red-black-tree'.rjust(length+14,'-') + '-'*(length) end = '-'*(length*2+14)+'\n' return '\n'.join([begin,*li,end]) def __str__(self): return self.display() 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def genNum(n =10): nums =[] for i in range(n): while 1: d = randint(0,100) if d not in nums: nums.append(d) break return numsdef buildTree(n=10,nums=None,visitor=None): if nums is None or nums ==[]: nums = genNum(n) rbtree = redBlackTree() print(f'build a red-black tree using &#123;nums&#125;') for i in nums: rbtree.insert(node(i)) if visitor: visitor(rbtree,i) return rbtree,numsdef testInsert(nums=None): def visitor(t,val): print('inserting', val) print(t) rbtree,nums = buildTree(visitor = visitor,nums=nums) print('-'*5+ 'in-order visit' + '-'*5) for i,j in enumerate(rbtree.sort()): print(f'&#123;i+1&#125;: &#123;j&#125;')def testSuc(nums=None): rbtree,nums = buildTree(nums=nums) for i in rbtree.sort(): print(f'&#123;i&#125;\'s suc is &#123;rbtree.getSuccessor(i)&#125;')def testDelete(nums=None): rbtree,nums = buildTree(nums = nums) print(rbtree) for i in sorted(nums): print(f'deleting &#123;i&#125;') rbtree.delete(i) print(rbtree)if __name__=='__main__': lst =[45, 30, 64, 36, 95, 38, 76, 34, 50, 1] lst = [0,3,5,6,26,25,8,19,15,16,17] #testSuc(lst) #testInsert(lst) testDelete() 下面是利用红黑树进行扩展成区间树的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129from redBlackTree import redBlackTreefrom functools import total_ordering@total_orderingclass node: def __init__(self,low,high,left=None,right=None,isBlack=False): self.val = low # self.val is the low self.high = high self.max = high self.left = left self.right = right self.parent=None self.isBlack = isBlack def __lt__(self,nd): return self.val &lt; nd.val def __eq__(self,nd): return nd is not None and self.val == nd.val def setChild(self,nd,isLeft = True): if isLeft: self.left = nd else: self.right = nd if nd is not None: nd.parent = self def getChild(self,isLeft): if isLeft: return self.left else: return self.right def __bool__(self): return self.val is not None def __str__(self): color = 'B' if self.isBlack else 'R' return f'&#123;color&#125;[&#123;self.val&#125;,&#123;self.high&#125;]-&#123;self.max&#125;' def __repr__(self): return f'intervalNode(&#123;self.val&#125;,&#123;self.high&#125;,&#123;self.max&#125;,isBlack=&#123;self.isBlack&#125;)' def overlap(self,low,high): return self.val&lt;=high and self.high&gt;=low def setMax(self): l = 0 if self.left is None else self.left.max r = 0 if self.right is None else self.right.max self.max = max(self.high, l, r) return self.maxclass intervalTree(redBlackTree): def search(self,low,high): nd = self.root while nd is not None and not nd.overlap(low,high): if nd.left is not None and nd.left.max&gt;=low: nd = nd.left else:nd = nd.right return nd def insert(self,nd): super(intervalTree,self).insert(nd) while nd is not None: nd.setMax() nd = nd.parent def delete(self,val): nd = self.find(val) if nd is not None: nd.max = 0 tmp = nd.parent while tmp is not None: tmp.setMax() tmp = tmp.parent super(intervalTree,self).delete(val) def rotate(self,prt,chd): '''rotate prt, and return new prt, namyly the original chd''' super(intervalTree,self).rotate(prt,chd) prt.setMax() chd.setMax() def copyNode(self,src,des): des.val = src.val des.high = src.high des.setMax()from random import randint, shuffledef genNum(n =10,upper=10): nums =&#123;&#125; for i in range(n): while 1: d = randint(0,100) if d not in nums: nums[d] = (d,randint(d,d+upper)) break return nums.values()def buildTree(n=10,nums=None,visitor=None): #if nums is None or nums ==[]: nums = genNum(n) tree = intervalTree() print(f'build a red-black tree using &#123;nums&#125;') for i in nums: tree.insert(node(*i)) if visitor: visitor(tree,i) return tree,numsdef testInsert(nums=None): def visitor(t,val): print('inserting', val) print(t) tree,nums = buildTree(visitor = visitor,nums=nums) print('-'*5+ 'in-order visit' + '-'*5) for i,j in enumerate(tree.sort()): print(f'&#123;i+1&#125;: &#123;j&#125;') return treedef testSuc(nums=None): tree,nums = buildTree(nums=nums) for i in tree.sort(): print(f'&#123;i&#125;\'s suc is &#123;tree.getSuccessor(i)&#125;')def testDelete(nums=None): tree,nums = buildTree(nums = nums) print(tree) for i in nums: print(f'deleting &#123;i&#125;') tree.delete(i[0]) print(tree) return treeif __name__=='__main__': lst = [(0,3),(5,8),(6,10),(26,26),(25,30),(8,9),(19,20),(15,23),(16,21),(17,19)] #lst = None #testSuc(lst) tree = testInsert(lst) #tree,_= buildTree(lst) while 1: a =int( input('low:')) b =int( input('high:')) res = tree.search(a,b) print(res)from redBlackTree import redBlackTree 7. 参考 1. 算法导论 &#8617; 2. https://www.jianshu.com/p/a5514510f5b9?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation &#8617; 3. https://www.jianshu.com/p/0b68b992f688?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation &#8617;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『数据结构』树]]></title>
    <url>%2Ftree.html</url>
    <content type="text"><![CDATA[1. 概念 2. 二叉查找树 2.1. 随机构造的二叉查找树 2.2. 平均结点深度 2.3. 不同的二叉树数目(Catalan num) 2.4. 好括号列 3. 基数树(radixTree) 4. 字典树(trie) 4.1. AC 自动机 5. 平衡二叉树 5.1. AVL Tree 5.2. splayTree 5.2.1. Zig-step 5.2.2. Zig-zig step 5.2.3. Zig-zag step 5.3. read-black Tree 5.4. treap 6. 总结 7. 附代码 7.1. 二叉树(binaryTree) 7.2. 前缀树(Trie) 7.3. 赢者树(winnerTree) 7.4. 左斜堆 1. 概念 双亲 左右孩子 左右子树 森林 结点,叶子,边,路径 高度 h 遍历(前中后层) 结点数 n 2. 二叉查找树又名排序二叉树,对于每个结点, 如果有,其左孩子不大于它,右孩子不小于它 通过前序遍历或者后序遍历就可以得到有序序列(升序,降序) 常用三种操作, 插入,删除,查找,时间复杂度是 $O(h)$h是树高, 但是由于插入,删除而导致树不平衡, 即可能 $h\geqslant \lfloor logn \rfloor$ 2.1. 随机构造的二叉查找树下面可以证明,随机构造,即输入序列有 $n!$中, 每种概率相同的情况下, 期望的树高 $h=O(logn)$ (直接搬运算法导论上面的啦&gt;_&lt;) 2.2. 平均结点深度一个较 上面定理 弱的结论: 一棵随机构造的二叉查找树,n 个结点的平均深度为 $O(logn)$ 类似 RANDOMIZED-QUICKSORT 的证明过程, 因为快排 递归的过程就是一个递归 二叉树.随机选择枢纽元就相当于这里的某个子树的根结点 在所有结点的大小随机排名, 如 i. 然后根结点将剩下的结点划分为左子树(i-1)个结点, 右子树(n-i)个结点. 2.3. 不同的二叉树数目(Catalan num)给定$\{1,2,\ldots,n\}$,组成二叉查找树的数目.由上面的证明过程, 可以容易地分析得出, 任选第 i 个数作为根, 由于二叉查找树的性质, 其左子树应该有 i-1个结点, 右子树有 n-i个结点.如果记 n 个结点 的二叉查找树的数目为$b_n$则有递推公式 b_n=\begin{cases} 1 &n=0 \\ \sum_{i=1}^{n}b_{i-1}b_{n-i} & n\geqslant 1 \end{cases}然后我们来看&lt;&lt;算法导论&gt;&gt;(p162,思考题12-4)上怎么求的吧( •̀ ω •́ )y设生成函数 B(x)=\sum_{n=0}^{\infty}b_n x^n下面证明$B(x)=xB(x)^2+1$易得xB(x)^2=\sum_{i=1}^{\infty}\sum_{n=i}^{\infty}b_{i-1}b_{n-i}x^n对比$B(x), xB(x)^2+1$的 x 的各次系数,分别是 $b_k,a_{k}$当 k=0, $a_k=1=b_k$当 k&gt;0 a_{k} = \sum_{i=1}^{k}b_{i-1}b_{k-i} = b_k所以$B(x)=xB(x)^2+1$由此解得 B(x)=\frac{1-\sqrt{1-4x} }{2x}在点 x=0 处,用泰勒公式得 \begin{aligned} \lim_{x\to 0}\sqrt{1-4x}&=1+\sum_{n=1}^{\infty}C_n^{\frac{1}{2}}{(-4)}^nx^n \\ &=1+\sum_{n=1}^{\infty}\frac{(2n-3)!!{(-4x)}^n}{n!} \end{aligned}所以对应系数 \begin{aligned} b_n&=\frac{1}{2}\frac{4^{n+1}(2n-1)!!}{2^{n+1}n!} \\ &=\frac{C_{2n}^{n}}{n+1} \end{aligned}这个数叫做 Catalan 数 2.4. 好括号列王树禾的&lt;&lt;图论&gt;&gt;(p42)上用另外的方法给出Catalan数, 并求出n结点 二叉查找数的个数 首先定义好括号列,有: 空列,即没有括号叫做好括号列 若A,B都是好括号列, 则串联后 AB是好括号列 若A是好括号列, 则 (A)是好括号列 充要条件: 好括号列 $\Longleftrightarrow$ 左右括号数相等, 且从左向右看, 看到的右括号数不超过左括号数 定理: 由 n个左括号,n个右括号组成的好括号列个数为$c(n)=\frac{C_{2n}^{n}}{n+1}$ 证明:由 n左n右组成的括号列有 $\frac{2n}{n!n!}=C_{2n}^{n}$个. 设括号列$a_1a_2\ldots a_{2n}$为坏括号列,由充要条件, 存在最小的 j, 使得$a_1a_2\ldots a_{j}$中右括号比左括号多一个,由于是最小的 j, 所以 $a_j$为右括号, $a_{j+1}$为右括号把$a_{j+1}a_{j+2}\ldots a_{2n}$中的左括号变为右括号, 右变左,记为$\bar a_{j+1}\bar a_{j+2}\ldots \bar a_{2n}$ 则括号列$a_1a_2\ldots a_{j}\bar a_{j+1}$为好括号列$a_1a_2\ldots a_{j}\bar a_{j+1}\bar a_{j+2}\ldots \bar a_{2n}$可好可坏,且有n-1个右,n+1个左, 共有$\frac{2n}{(n+1)!(n-1)!}=C_{2n}^{n+1}$个. 所以坏括号列$a_1a_2\ldots a_{2n}$ 与括号列 $a_1a_2\ldots a_{j}\bar a_{j+1}\bar a_{j+2}\ldots \bar a_{2n}$, 有$\frac{2n}{(n+1)!(n-1)!}=C_{2n}^{n+1}$个 那么好括号列有 c(n)=C_{2n}^{n} - C_{2n}^{n+1} =\frac{C_{2n}^{n}}{n+1} 推论: n个字符,进栈出栈(出栈可以在栈不为空的时候随时进行), 则出栈序列有 c(n)种 这种先入后出的情形都是这样 3. 基数树(radixTree) 4. 字典树(trie)又叫前缀树(preifx tree).适用于储存有公共前缀的字符串集合. 如果直接储存, 而很多字符串有公共前缀, 会浪费掉存储空间.字典树可以看成是基数树的变形, 每个结点可以有多个孩子, 每个结点存储的是一个字符, 从根沿着结点走到一个结点,走过的路径形成字符序列, 如果有合适的单词就可以输出. 当然,也可以同理得出后缀树 4.1. AC 自动机Aho-Corasick automation,是在字典树上添加匹配失败边(失配指针), 实现字符串搜索匹配的算法. 图中蓝色结点 表示存在字符串, 灰色表示不存在.黑色边是父亲到子结点的边, 蓝色边就是失配指针. 蓝色边(终点称为起点的后缀结点): 连接字符串终点到在图中存在的, 最长严格后缀的结点. 如 caa 的严格后缀为 aa,a, 空. 而在图中存在, 且最长的是字符串 a, 则连接到这个字符串的终点 a. 绿色边(字典后缀结点): 终点是起点经过蓝色有向边到达的第一个蓝色结点. 下面摘自 wiki 在每一步中，算法先查找当前节点的 “孩子节点”，如果没有找到匹配，查找它的后缀节点(suffix) 的孩子，如果仍然没有，接着查找后缀节点的后缀节点的孩子, 如此循环, 直到根结点，如果到达根节点仍没有找到匹配则结束。 当算法查找到一个节点，则输出所有结束在当前位置的字典项。输出步骤为首先找到该节点的字典后缀，然后用递归的方式一直执行到节点没有字典前缀为止。同时，如果该节点为一个字典节点，则输出该节点本身。 输入 abccab 后算法的执行步骤如下： 5. 平衡二叉树上面的二叉查找树不平衡,即经过多次插入,删除后, 其高度变化大, 不能保持$\Theta(n)$的性能而平衡二叉树就能.平衡二叉树都是经过一些旋转操作, 使左右子树的结点高度相差不大,达到平衡 有如下几种 5.1. AVL Tree平衡因子: 右子树高度 - 左子树高度定义: 每个结点的平衡因子属于{0,-1,1} 5.2. splayTree伸展树, 它的特点是每次将访问的结点通过旋转旋转到根结点.其实它并不平衡. 但是插入,查找,删除操作 的平摊时间是$O(logn)$有三种旋转,下面都是将访问过的 x 旋转到 根部 5.2.1. Zig-step 5.2.2. Zig-zig step 5.2.3. Zig-zag step 5.3. read-black Tree同样是平衡的二叉树, 以后单独写一篇关于红黑树的. 5.4. treap前面提到, 随机构造的二叉查找树高度为 $h=O(logn)$,以及在算法 general 中说明了怎样 随机化(shuffle)一个给定的序列. 所以,为了得到一个平衡的二叉排序树,我们可以将给定的序列随机化, 然后再进行构造二叉排序树. 但是如果不能一次得到全部的数据,也就是可能插入新的数据的时候,该怎么办呢? 可以证明,满足下面的条件构造的结构相当于同时得到全部数据, 也就是随机化的二叉查找树. 这种结构叫 treap, 不仅有要排序的关键字 key, 还有随机生成的,各不相等的关键字priority,代表插入的顺序. 二叉查找树的排序性质: 双亲结点的 key 大于左孩子,小于右孩子 最小(大)堆的堆序性质: 双亲的 prority小于(大于) 孩子的 prority 插入的实现: 先进行二叉查找树的插入,成为叶子结点, 再通过旋转 实现 上浮(堆中术语).将先排序 key, 再排序 prority(排序prority 时通过旋转保持 key 的排序) 6. 总结还有很多有趣的树结构,比如斜堆, 竞赛树(赢者树,输者树,线段树, 索引树,B树, fingerTree(不知道是不是译为手指树233)…这里就不详细介绍了, 如果以后有时间,可能挑几个单独写一篇文章 7. 附代码github地址 7.1. 二叉树(binaryTree)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from functools import total_ordering@total_orderingclass node: def __init__(self,val,left=None,right=None,freq = 1): self.val=val self.left=left self.right=right self.freq = freq def __lt__(self,nd): return self.val&lt;nd.val def __eq__(self,nd): return self.val==nd.val def __repr__(self): return 'node(&#123;&#125;)'.format(self.val)class binaryTree: def __init__(self): self.root=None def add(self,val): def _add(nd,newNode): if nd&lt;newNode: if nd.right is None:nd.right = newNode else:_add(nd.right,newNode) elif nd&gt;newNode: if nd.left is None:nd.left = newNode else : _add(nd.left,newNode) else:nd.freq +=1 _add(self.root,node(val)) def find(self,val): prt= self._findPrt(self.root,node(val),None) if prt.left and prt.left.val==val: return prt.left elif prt.right and prt.right.val==val:return prt.right else :return None def _findPrt(self,nd,tgt,prt): if nd==tgt or nd is None:return prt elif nd&lt;tgt:return self._findPrt(nd.right,tgt,nd) else:return self._findPrt(nd.left,tgt,nd) def delete(self,val): prt= self._findPrt(self.root,node(val),None) if prt.left and prt.left.val==val: l=prt.left if l.left is None:prt.left = l.right elif l.right is None : prt.left = l.left else: nd = l.left while nd.right is not None:nd = nd.right nd.right = l.right prt.left = l.left elif prt.right and prt.right.val==val: r=prt.right if r.right is None:prt.right = r.right elif r.right is None : prt.right = r.left else: nd = r.left while nd.right is not None:nd = nd.right nd.right = r.right prt.left = r.left def preOrder(self): def _p(nd): if nd is not None: print(nd) _p(nd.left) _p(nd.right) _p(self.root) 7.2. 前缀树(Trie)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class node: def __init__(self,val = None): self.val = val self.isKey = False self.children = &#123;&#125; def __getitem__(self,i): return self.children[i] def __iter__(self): return iter(self.children.keys()) def __setitem__(self,i,x): self.children[i] = x def __bool__(self): return self.children!=&#123;&#125; def __str__(self): return 'val: '+str(self.val)+'\nchildren: '+' '.join(self.children.keys()) def __repr__(self): return str(self)class Trie(object): def __init__(self): self.root=node('') self.dic =&#123;'insert':self.insert,'startsWith':self.startsWith,'search':self.search&#125; def insert(self, word): """ Inserts a word into the trie. :type word: str :rtype: void """ if not word:return nd = self.root for i in word: if i in nd: nd = nd[i] else: newNode= node(i) nd[i] = newNode nd = newNode else:nd.isKey = True def search(self, word,matchAll='.'): """support matchall function eg, 'p.d' matchs 'pad' , 'pid' """ self.matchAll = '.' return self._search(self.root,word) def _search(self,nd,word): for idx,i in enumerate(word): if i==self.matchAll : for j in nd: bl =self._search(nd[j],word[idx+1:]) if bl:return True else:return False if i in nd: nd = nd[i] else:return False else:return nd.isKey def startsWith(self, prefix): """ Returns if there is any word in the trie that starts with the given prefix. :type prefix: str :rtype: bool """ nd = self.root for i in prefix: if i in nd: nd= nd[i] else:return False return True def display(self): print('preOrderTraverse data of the Trie') self.preOrder(self.root,'') def preOrder(self,root,s): s=s+root.val if root.isKey: print(s) for i in root: self.preOrder(root[i],s) 7.3. 赢者树(winnerTree)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class winnerTree: '''if i&lt;lowExt p = (i+offset)//2 else p = (i+n-1-lowExt)//2 offset is a num 2^k-1 just bigger than n p is the index of tree i is the index of players lowExt is the double node num of the lowest layer of the tree ''' def __init__(self,players,reverse=False): self.n=len(players) self.tree = [0]*self.n players.insert(0,0) self.players=players self.reverse=reverse self.getNum() self.initTree(1) def getNum(self): i=1 while 2*i&lt; self.n:i=i*2 if 2*i ==self. n: self.lowExt=0 self.s = 2*i-1 else: self.lowExt = (self.n-i)*2 self.s = i-1 self.offset = 2*i-1 def treeToArray(self,p): return 2*p-self.offset if p&gt;self.s else 2*p+self.lowExt-self.n+1 def arrayToTree(self,i): return (i+self.offset)//2 if i&lt;=self.lowExt else (i-self.lowExt+ self.n-1)//2 def win(self,a,b): return a&lt;b if self.reverse else a&gt;b def initTree(self,p): if p&gt;=self.n: delta = p%2 #!!! good job notice delta mark the lchild or rchlid return self.players[self.treeToArray(p//2)+delta] l = self.initTree(2*p) r = self.initTree(2*p+1) self.tree[p] = l if self.win(l,r) else r return self.tree[p] def winner(self): idx = 1 while 2*idx&lt;self.n: idx = 2*idx if self.tree[2*idx] == self.tree[idx] else idx*2+1 num = self.treeToArray(idx) num = num+1 if self.players[num] !=self.tree[1] else num return self.tree[1],num def getOppo(self,i,x,p): oppo=None if 2*p&lt;self.n:oppo=self.tree[2*p] elif i&lt;=self.lowExt:oppo=self.players[i-1+i%2*2] else: lpl= self.players[2*p+self.lowExt-self.n+1] oppo = lpl if lpl!=x else self.players[2*p+self.lowExt-self.n+2] return oppo def update(self,i,x): ''' i is 1-indexed which is the num of player and x is the new val of the player ''' self.players[i]=x p = self.arrayToTree(i) oppo =self.getOppo(i,x,p) self.tree[p] = x if self.win(x,oppo) else oppo p=p//2 while p: l = self.tree[p*2] r = None if 2*p+1&lt;self.n:r=self.tree[p*2+1] #notice this !!! else:r = self.players[2*p+self.lowExt-self.n+1] self.tree[p] = l if self.win(l,r) else r p=p//2 7.4. 左斜堆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101from functools import total_ordering@total_orderingclass node: def __init__(self,val,freq=1,s=1,left=None,right=None): self.val=val self.freq=freq self.s=s if left is None or right is None: self.left = left if left is not None else right self.right =None else: if left.s&lt;right.s: left,right =right, left self.left=left self.right=right self.s+=self.right.s def __eq__(self,nd): return self.val==nd.val def __lt__(self,nd): return self.val&lt;nd.val def __repr__(self): return 'node(val=%d,freq=%d,s=%d)'%(self.val,self.freq,self.s)class leftHeap: def __init__(self,root=None): self.root=root def __bool__(self): return self.root is not None @staticmethod def _merge(root,t): #-&gt; int if root is None:return t if t is None:return root if root&lt;t: root,t=t,root root.right = leftHeap._merge(root.right,t) if root.left is None or root.right is None: root.s=1 if root.left is None: root.left,root.right = root.right,None else: if root.left.s&lt;root.right.s: root.left,root.right = root.right,root.left root.s = root.right.s+1 return root def insert(self,nd): if not isinstance(nd,node):nd = node(nd) if self.root is None: self.root=nd return if self.root==nd: self.root.freq+=1 return prt =self. _findPrt(self.root,nd,None) if prt is None: self.root=leftHeap._merge(self.root,nd) else : if prt.left==nd: prt.left.freq+=1 else:prt.right.freq+=1 def remove(self,nd): if not isinstance(nd,node):nd = node(nd) if self.root==nd: self.root=leftHeap._merge(self.root.left,self.root.right) else: prt = self._findPrt(self.root,nd,None) if prt is not None: if prt.left==nd: prt.left=leftHeap._merge(prt.left.left,prt.left.right) else: prt.right=leftHeap._merge(prt.right.left,prt.right.right) def find(self,nd): if not isinstance(nd,node):nd = node(nd) prt = self._findPrt(self.root,nd,self.root) if prt is None or prt==nd:return prt elif prt.left==nd:return prt.left else:return prt.right def _findPrt(self,root,nd,parent): if not isinstance(nd,node):nd = node(nd) if root is None or root&lt;nd:return None if root==nd:return parent l=self._findPrt(root.left,nd,root) return l if l is not None else self._findPrt(root.right,nd,root) def getTop(self): return self.root def pop(self): nd = self.root self.remove(self.root.val) return nd def levelTraverse(self): li = [(self.root,0)] cur=0 while li: nd,lv = li.pop(0) if cur&lt;lv: cur=lv print() print(nd,end=' ') else:print(nd,end=' ') if nd.left is not None:li.append((nd.left,lv+1)) if nd.right is not None:li.append((nd.right,lv+1))]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『数据结构』散列表]]></title>
    <url>%2FhashTable.html</url>
    <content type="text"><![CDATA[1. 关键字 2. 映射 2.1. 散列函数(hash) 2.1.1. 简单一致散列 2.1.2. 碰撞(collision) 2.1.3. str2int 的方法 2.2. 直接寻址法 2.3. 链接法 2.3.1. 全域散列(universal hashing) 2.3.1.1. 定义 2.3.1.2. 性质 2.3.1.3. 实现 2.4. 开放寻址法 2.4.1. 不成功查找的探查数的期望 2.4.1.1. 插入探查数的期望 2.4.1.2. 成功查找的探查数的期望 哈希表 (hash table) , 可以实现 $O(1)$ 的 read, write, update相对应 python 中的 dict, c语言中的 map 其实数组也能实现, 只是数组用来索引的关键字是下标, 是整数.而哈希表就是将各种关键字映射到数组下标的一种”数组” 1. 关键字由于关键字是用来索引数据的, 所以要求它不能变动(如果变动,实际上就是一个新的关键字插入了), 在python 中表现为 immutable. 常为字符串. 2. 映射 2.1. 散列函数(hash)将关键字 k 进行映射, 映射函数 $h$, 映射后的数组地址 $h(k)$. 2.1.1. 简单一致散列 简单一致假设:元素散列到每个链表的可能性是相同的, 且与其他已被散列的元素独立无关. 简单一致散列(simple uniform hashing): 满足简单一致假设的散列 好的散列函数应 满足简单一致假设例如 \begin{aligned} &(1) \text{除法散列} \quad h(k) = k \ mod\ m \\ &(2) \text{乘法散列} \quad h(k) = \lfloor {m(kA \ mod\ 1)\rfloor} \text{,(0< A< 1)}\\ &\quad\text{任何 A 都适用,最佳的选择与散列的数据特征有关.}\\ &\quad\text{ Knuth 认为,最理想的是黄金分割数}\frac{\sqrt{5} -1}{2} \approx 0.618 \end{aligned} 2.1.2. 碰撞(collision) 由于关键字值域大于映射后的地址值域, 所以可能出现两个关键字有相同的映射地址 2.1.3. str2int 的方法可以先用 ascii 值,然后 各位相加 两位叠加 循环移位 … 2.2. 直接寻址法将关键字直接对应到数组地址, 即 $h(k)=k$ 缺点: 如果关键字值域范围大, 但是数量小, 就会浪费空间, 有可能还不能储存这么大的值域范围. 2.3. 链接法通过链接法来解决碰撞 记有 m 个链表, n 个元素 $\alpha = \frac{n}{m}$ 为每个链表的期望元素个数(长度) 则查找成功,或者不成功的时间复杂度为 $\Theta(1+\alpha)$如果 $n=O(m), namely \quad \alpha=\frac{O(m)}{m}=O(1)$, 则上面的链接法满足 $O(1)$的速度 2.3.1. 全域散列(universal hashing) 随机地选择散列函数, 使之独立于要存储的关键字 2.3.1.1. 定义设一组散列函数 $H=\{h_1,h_2,\ldots,h_i\}$, 将 关键字域 U 映射到 $\{0,1,\ldots,m-1\}$ , 全域的函数组, 满足 for \ k \neq l \ \in U, h(k) = h(l), \text{这样的 h 的个数不超过}\frac{|H|}{m}即从 H 中任选一个散列函数, 当关键字不相等时, 发生碰撞的概率不超过 $\frac{1}{m}$ 2.3.1.2. 性质对于 m 个槽位的表, 只需 $\Theta(n)$的期望时间来处理 n 个元素的 insert, search, delete,其中 有$O(m)$个insert 操作 2.3.1.3. 实现选择足够大的 prime p, 记 $Z_p=\{0,1,\ldots,p-1\}$, $Z_p^{}=\{1,\ldots,p-1\}$令$h_{a,b}(k) = ((ak+b)mod\ p) mod\ m$则 $H_{p,m}=\{h_{a,b}|a\in Z_p^{},b\in Z_p\}$ 每一个散列函数 $h_{a,b}$ 都将 $Z_p$ 映射到 $Z_m$, m 可以是任意的, 不用是一个素数 2.4. 开放寻址法所有表项都在散列表中, 没有链表.且散列表装载因子$\alpha=\frac{n}{m}\leqslant1$这里散列函数再接受一个参数, 作为探测序号逐一试探 $h(k,0),h(k,1),\ldots,h(k,m-1)$,这要有满足的,就插入, 不再计算后面的 hash值 探测序列一般分有三种 线性$\ 0,1,\ldots,m-1$ 存在一次聚集问题 二次$\ 0,1,\ldots,(m-1)^2$ 存在二次聚集问题 双重探查 $h(k,i) = (h_1(k)+i*h_2(k))mod\ m$为了能查找整个表, 即要为模 m 的完系, 则 h_2(k)要与 m 互质.如可以取 $h_1(k) = k\ mod \ m,h_2(k) = 1+(k\ mod\ {m-1})$ 注意删除时, 不能直接删除掉(如果有元素插入在其后插入时探测过此地址,删除后就不能访问到那个元素了), 应该 只是做个标记为删除 2.4.1. 不成功查找的探查数的期望对于开放寻址散列表,且 $\alpha&lt;1$,一次不成功的查找,是这样的: 已经装填了 n 个, 总共有m 个,则空槽有 m-n 个.不成功的探查是这样的: 一直探查到已经装填的元素(但是不是要找的元素), 直到遇到没有装填的空槽. 所以这服从几何分布, 即 p(\text{不成功探查})=p(\text{第一次找到空槽})=\frac{m-n}{m} 有 E(\text{探查数})=\frac{1}{p}\leqslant \frac{1}{1-\alpha} 2.4.1.1. 插入探查数的期望所以, 插入一个关键字, 也最多需要 $\frac{1}{1-\alpha}$次, 因为插入过程就是前面都是被占用了的槽, 最后遇到一个空槽.与探查不成功是一样的过程 2.4.1.2. 成功查找的探查数的期望成功查找的探查过程与插入是一样的. 所以查找关键字 k 相当于 插入它, 设为第 i+1 个插入的(前面插入了i个,装载因子$\alpha=\frac{i}{m}$. 那么期望探查数就是 \frac{1}{1-\alpha}=\frac{1}{1-\frac{i}{m}}=\frac{m}{m-i}则成功查找的期望探查数为 \begin{aligned} \frac{1}{n}\sum_{i=0}^{n-1}\frac{m}{m-i}=\frac{m}{n}\sum_{i=0}^{n-1}\frac{1}{m-i} &= \frac{m}{n}\sum_{i=m-n+1}^{m}\frac{1}{i}\\ &\leqslant \frac{1}{\alpha} \int_{m-n}^m\frac{1}{x}dx\\ &=\frac{1}{\alpha}ln\frac{1}{1-\alpha} \end{aligned}代码 github地址1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class item: def __init__(self,key,val,nextItem=None): self.key = key self.val = val self.next = nextItem def to(self,it): self.next = it def __eq__(self,it): '''using keyword &lt;in&gt; ''' return self.key == it.key def __bool__(self): return self.key is not None def __str__(self): li = [] nd = self while nd: li.append(f'(&#123;nd.key&#125;:&#123;nd.val&#125;)') nd = nd.next return ' -&gt; '.join(li) def __repr__(self): return f'item(&#123;self.key&#125;,&#123;self.val&#125;)'class hashTable: def __init__(self,size=100): self.size = size self.slots=[item(None,None) for i in range(self.size)] def __setitem__(self,key,val): nd = self.slots[self.myhash(key)] while nd.next: if nd.key ==key: if nd.val!=val: nd.val=val return nd = nd.next nd.next = item(key,val) def myhash(self,key): if isinstance(key,str): key = sum(ord(i) for i in key) if not isinstance(key,int): key = hash(key) return key % self.size def __iter__(self): '''when using keyword &lt;in&gt;, such as ' if key in dic', the dic's __iter__ method will be called,(if hasn't, calls __getitem__ then ~iterate~ dic's keys to compare whether one equls to the key ''' for nd in self.slots: nd = nd.next while nd : yield nd.key nd = nd.next def __getitem__(self,key): nd =self.slots[ self.myhash(key)].next while nd: if nd.key==key: return nd.val nd = nd.next raise Exception(f'[KeyError]: &#123;self.__class__.__name__&#125; has no key &#123;key&#125;') def __delitem__(self,key): '''note that None item and item(None,None) differ with each other, which means you should take care of them and correctly cop with None item especially when deleting items ''' n = self.myhash(key) nd = self.slots[n].next if nd.key == key: if nd.next is None: self.slots[n] = item(None,None) # be careful else:self.slots[n] = nd.next return while nd: if nd.next is None: break # necessary if nd.next.key ==key: nd.next = nd.next.next nd = nd.next def __str__(self): li = ['\n\n'+'-'*5+'hashTable'+'-'*5] for i,nd in enumerate(self.slots): li.append(f'&#123;i&#125;: '+str(nd.next)) return '\n'.join(li)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『算法』排序]]></title>
    <url>%2Fsort.html</url>
    <content type="text"><![CDATA[1. 希尔排序(shellSort) 2. 堆排序(heapSort) 2.1. 建堆 2.2. 访问最元 2.3. 取出最元 2.4. 堆排序 3. 快速排序(quickSort) 3.1. partition的实现 3.2. 选择枢纽元 3.3. 快速排序的性能 3.3.1. 最坏情况 3.3.2. 最佳情况 3.3.3. 平衡的划分 3.4. 期望运行时间 3.5. 堆栈深度 3.6. 测试 4. 计数排序(countSort) 5. 基数排序(radixSort) 5.1. 原理 5.2. 实现 5.3. 扩展 5.4. 测试 6. 桶排序(bucketSort) 7. 选择问题(select) 排序的本质就是减少逆序数, 根据是否进行比较,可以分为如下两类. 比较排序 如希尔排序,堆排序, 快速排序, 合并排序等可以证明 比较排序的下界 是 $\Omega(nlogn)$ 非比较排序 如 计数排序, 桶排序, 基数排序 不依靠比较来进行排序的, 可以达到 线性时间的复杂度 1. 希尔排序(shellSort)希尔排序是选择排序的改进, 通过在较远的距离进行交换, 可以更快的减少逆序数. 这个距离即增量, 由自己选择一组, 从大到小进行, 而且最后一个增量必须是 1. 要选得到好的性能, 一般选择$2^k-1$123456789101112def shellSort(s,inc = None): if inc is None: inc = [1,3,5,7,11,13,17,19] num = len(s) inc.sort(reverse=True) for i in inc: for j in range(i,num): cur = j while cur&gt;=i and s[j] &gt; s[cur-i]: s[cur] = s[cur-i] cur-=i s[cur] = s[j] return s 可以证明 希尔排序时间复杂度可以达到$O(n^{\frac{4}{3}})$ 2. 堆排序(heapSort) 2.1. 建堆是将一个数组(列表) heapify 的过程. 方法就是对每一个结点, 都自底向上的比较,然后操作,这个过程称为 上浮.粗略的计算, 每个结点上浮的比较次数的上界是 层数, 即 logn, 则 n 个结点, 总的比较次数为 nlogn但是可以发现, 不同高度 h 的结点比较的次数不同, 上界实际上应该是 $O(h)$,每层结点数上界 $\lfloor 2^h \rfloor$则 总比较次数为 \begin{aligned} \sum_{h=1}^{\lfloor{log_2 n}\rfloor} O(h)\lceil 2^{h} \rceil & = \sum_{h=0}^{ {log_2 n}-1} O(h\frac{n}{2^h})\\ & = n*O(\sum_{h=0}^{log_2 n}\frac{h}{2^h}) \\ & = n*O(1) \\ & = O(n) \end{aligned} 2.2. 访问最元最大堆对应最大元,最小堆对于最小元, 可以 $O(1)$ 内实现 2.3. 取出最元最大堆取最大元,最小堆取最小元,由于元素取出了, 要进行调整.从堆顶开始, 依次和其两个孩子比较, 如果是最大堆, 就将此结点(父亲)的值赋为较大的孩子的值,最小堆反之.然后对那个孩子进行同样的操作,一直到达堆底,即最下面的一层. 这个过程称为 下滤.最后将最后一个元素与最下面一层那个元素(与上一层交换的)交换, 再删除最后一个元素.时间复杂度为 $O(logn)$ 2.4. 堆排序建立堆之后, 一直进行 取出最元操作, 即得有序序列 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from functools import partialclass heap: def __init__(self,lst,reverse = False): self.data= heapify(lst,reverse) self.cmp = partial(lambda i,j,r:cmp(self.data[i],self.data[j],r),r= reverse) def getTop(self): return self.data[0] def __getitem__(self,idx): return self.data[idx] def __bool__(self): return self.data != [] def popTop(self): ret = self.data[0] n = len(self.data) cur = 1 while cur * 2&lt;=n: chd = cur-1 r_idx = cur*2 l_idx = r_idx-1 if r_idx==n: self.data[chd] = self.data[l_idx] break j = l_idx if self.cmp(l_idx,r_idx)&lt;0 else r_idx self.data[chd] = self.data[j] cur = j+1 self.data[cur-1] = self.data[-1] self.data.pop() return ret def addNode(self,val): self.data.append(val) self.data = one_heapify(len(self.data)-1)def cmp(n1,n2,reverse=False): fac = -1 if reverse else 1 if n1 &lt; n2: return -fac elif n1 &gt; n2: return fac return 0def heapify(lst,reverse = False): for i in range(len(lst)): lst = one_heapify(lst,i,reverse) return lstdef one_heapify(lst,cur,reverse = False): cur +=1 while cur&gt;1: chd = cur-1 prt = cur//2-1 if cmp(lst[prt],lst[chd],reverse)&lt;0: break lst[prt],lst[chd] = lst[chd], lst[prt] cur = prt+1 return lstdef heapSort(lst,reverse = False): lst = lst.copy() hp = heap(lst,reverse) ret = [] while hp: ret.append(hp.popTop()) return retif __name__ == '__main__': from random import randint n = randint(10,20) lst = [randint(0,100) for i in range(n)] print('random : ', lst) print('small-heap: ', heapify(lst)) print('big-heap : ', heapify(lst,True)) print('ascend : ', heapSort(lst)) print('descend : ', heapSort(lst,True)) 3. 快速排序(quickSort)12345678def quickSort(lst): def _sort(a,b): if a&gt;=b:return CHOOSE PIVOT #选取适当的枢纽元, 一般是三数取中值 pos = partition(a,b) _sort(a,pos-1) _sort(pos+1,b) _sort(0,len(lst)) 快排大体结构就是这样,使用分治的思想, 在原地进行排列.关键就在于选择枢纽元. 这里的 partition 就是根据枢纽元,分别将 大于,小于或等于的枢纽元的元素放在列表两边, 分割开. 3.1. partition的实现partition 有不同的实现. 下面列出两种 第一种实现 12345678910111213def partition(a,b): pivot = lst[a] while a!=b: while a&lt;b and lst[b]&gt;pivot: b-=1 if a&lt;b: lst[a] = lst[b] a+=1 while a&lt;b and lst[a]&lt;pivot: a+=1 if a&lt;b: lst[b] = lst[a] b-=1 lst[a] = pivot return a 第二种实现 123456789def partition(a,b): pivot = lst[b] j = a-1 for i in range(a,b): if lst[i]&lt;=pivot: j+=1 if i!=j: lst[i], lst[j] = lst[j], lst[i] lst[j+1],lst[b] = lst[b],lst[j+1] return j+1 第二种是算法导论上的,可以发现,第二种交换赋值的次数比第一种要多,而且如果序列的逆序数较大,第二种一次交换减少的逆序数很少, 而第一种就比较多(交换的两个元素相距较远)然后我用随机数测试了一下, 确实是第一种较快, 特别是要排序的序列较长时,如在 5000 个元素时, 第一种要比第二种快几倍, Amazing! 完整代码1234567891011121314151617181920212223242526def quickSort(lst): '''A optimized version of Hoare partition''' def partition(a,b): pivot = lst[a] while a!=b: while a&lt;b and lst[b]&gt;pivot: b-=1 if a&lt;b: lst[a] = lst[b] a+=1 while a&lt;b and lst[a]&lt;pivot: a+=1 if a&lt;b: lst[b] = lst[a] b-=1 lst[a] = pivot return a def _sort(a,b): if a&gt;=b:return mid = (a+b)//2 # 三数取中值置于第一个作为 pivot if (lst[a]&lt;lst[mid]) ^ (lst[b]&lt;lst[mid]): lst[a],lst[mid] = lst[mid],lst[a] # lst[mid] 为中值 if (lst[a]&lt;lst[b]) ^ (lst[b]&gt;lst[mid]): lst[a],lst[b] = lst[b],lst[a] # lst[b] 为中值 i = partition(a,b) _sort(a,i-1) _sort(i+1,b) _sort(0,len(lst)-1) return lst 3.2. 选择枢纽元 端点或中点 随机 三数取中(两端点以及中点) 五数取中 3.3. 快速排序的性能快速排序性能取决于划分的对称性(即枢纽元的选择), 以及partition 的实现. 如果每次划分很对称(大概在当前序列的中位数为枢纽元), 则与合并算法一样快, 但是如果不对称,在渐近上就和插入算法一样慢 3.3.1. 最坏情况试想,如果每次划分两个区域分别包含 n-1, 1则易知时间复杂度为 $\Theta(n^2)$, 此外, 如果输入序序列已经排好序,且枢纽元没选好, 比如选的端点, 则同样是这样复杂, 而此时插入排序只需 $O(n)$. 3.3.2. 最佳情况有 $T(n) = 2T(\frac{n}{2})+\Theta(n)$则由主方法为$O(nlogn)$ 3.3.3. 平衡的划分如果每次 9:1, $T(n) = T(\frac{9n}{10})+T(\frac{n}{10})+\Theta(n)$用递归树求得在渐近上仍然是 $O(nlogn)$所以任何比值 k:1, 都有如上的渐近时间复杂度 然而每次划分是不可能完全相同的 3.4. 期望运行时间对于 randomized-quicksort, 即随机选择枢纽元设 n 个元素, 从小到大记为 $z_1,z_2,\ldots,z_n$,指示器变量 $X_{ij}$表示 $z_i,z_j$是否进行比较即 X_{ij} = \begin{cases} 1,\quad z_i,z_j\text{进行比较}\\ 0,\quad z_i,z_j\text{不进行比较} \end{cases}考察比较次数, 可以发现两个元素进行比较, 一定是一个是枢纽元的情况, 两个元素间不可能进行两次比较.所有总的比较次数不超过,$\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}X_{ij}$求均值 E(\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}X_{ij})=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}E(X_{ij})=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}P(z_i,z_j\text{进行比较})再分析,$z_i,z_j$ 在$Z_{ij} = \{z_i,z_{i+1},\ldots,z_j\} $中, 如果集合中的非此两元素,$z_k, i&lt; k&lt; j$作为了枢纽元, 则$z_k$将集合划分{z_i,z_{i+1},\ldots,z_{k-1}},{z_{k+1},\ldots,z_j}, 这两个集合中的元素都不会再和对方中的元素进行比较,所以要使 $z_i,z_j$进行比较, 则两者之一(只能是一个,即互斥)是 $Z_{ij}$上的枢纽元则 \begin{aligned} P(z_i,z_j\text{进行比较}) & = P(z_i,z_j\text{做为}Z_{ij}\text{上的枢纽元}) \\ & = P(z_j\text{做为}Z_{ij}\text{上的枢纽元})+P(z_i\text{做为}Z_{ij}\text{上的枢纽元})\\ & = \frac{1}{j-i+1}+\frac{1}{j-i+1} \\ & = \frac{2}{j-i+1}\\ \end{aligned}注意第二步是因为两事件互斥才可以直接概率相加 然后就可以将此概率代入求期望比较次数了,为 $O(nlogn)$ (由于是 O, 放缩一下就行) 3.5. 堆栈深度考察快速排序的堆栈深度,可以从递归树思考,实际上的堆栈变化过程就是前序访问二叉树, 所以深度为 $O(logn)$为了减少深度, 可以进行 尾递归优化, 将函数返回前的递归通过迭代完成123456QUICKSORT(A,a,b) while a&lt;b: #partition and sort left subarray pos = partition(a,b) QUICKSORT(A,a,pos-1) a = pos+1 3.6. 测试这是上面三个版本的简单测试结果,前面测试的是各函数用的时间, 后面打印出来的是体现正确性,用的另外的序列了 4. 计数排序(countSort)需要知道元素的取值范围, 而且应该是有限的, 最好范围不大 不过需要额外的存储空间.计算排序是稳定的: 具有相同值的元素在输出中是原来的相对顺序.123456789def countSort(lst,mn,mx): mark = [0]*(mx-mn+1) for i in lst: mark[i-mn]+=1 ret =[] for n,i in enumerate(mark): for j in range(i): ret.append(n+mn) return ret 5. 基数排序(radixSort) 5.1. 原理由我们平时的直觉, 我们比较两个数时, 是从最高位比较起, 一位一位比较, 直到不相等时就能判断大小,或者相等(位数比完了). 基数排序有点不一样, 它是从低位比到高位, 这样才能把相同位有相同值的不同数排序.对于 n 个数, 最高 d 位, 用下面的实现, 可时间复杂度为 $\Theta((n+d)*d)$ 5.2. 实现下面是一个整数版本的基数排序,比较容易实现1234567891011def radixSort(lst,radix=10): ls = [[] for i in range(radix)] mx = max(lst) weight = 1 while mx &gt;= weight: for i in lst: ls[(i // weight)%radix].append(i) weight *= radix lst = sum(ls,[]) ls = [[] for i in range(radix)] return lst 5.3. 扩展注意到如果有负数,要使用计数排序或者 基数排序,每个数需要加上最小值的相反数, 再排序, 最后再减去, 如果有浮点数, 就需要先乘以一个数, 使所有数变为整数. 我想过用 str 得到一个数的各位, 不过 str 可能比较慢. str 的实现应该也是先算术计算, 再生成 str 对象, 对于基数排序, 生成str 对象是多余的. 5.4. 测试下面是 基数排序与快速排序的比较,测试代码12345678910111213141516from time import timefrom random import randintdef timer(funcs,span,num=1000000): lst = [randint(0,span) for i in range(num)] print('range(&#123;&#125;), &#123;&#125; items'.format(span,num)) for func in funcs: data = lst.copy() t = time() func(data) t = time()-t print('&#123;&#125;: &#123;&#125;s'.format(func.__name__,t))if __name__ == '__main__': timer([quickSort,radixSort],1000000000,100000) timer([quickSort,radixSort],1000000000000,10000) timer([quickSort,radixSort],10000,100000) 6. 桶排序(bucketSort)适用于均匀分布的序列 设有 n 个元素, 则设立 n 个桶将各元素通过数值线性映射到桶地址,类似 hash 链表.然后在每个桶内, 进行插入排序($O(n_i^2)$)最后合并所有桶.这里的特点是 n 个桶实现了 $\Theta(n)$的时间复杂度, 但是耗费的空间 为 $\Theta(n)$ 证明 线性映射部分: $\Theta(n)$ 桶合并部分: $\Theta(n)$ 桶内插入排序部分: 设每个桶内的元素数为随机变量 $n_i$, 易知 $n_i \sim B(n,\frac{1}{n})$ 记 $p=\frac{1}{n}$ \begin{aligned} E(\sum_{i=1}^{n}n_i^2) &=\sum_{i=1}^{n}E(n_i^2) \\ &=\sum_{i=1}^{n}( Var(n_i)+E^2(n_i) ) \\ &= \sum_{i=1}^{n}( np(1-p)+ (np)^2 )\\ &= \sum_{i=1}^{n}( 2-\frac{1}{n} )\\ &= 2n-1 \end{aligned}将以上各部分加起来即得时间复杂度 $\Theta(n)$ 7. 选择问题(select)输入个序列 lst, 以及一个数 i, 输出 lst 中 第 i 小的数,即从小到大排列第 i 解决方法 全部排序, 取第 i 个, $O(nlogn)$ 长度为 i 的队列(这是得到 lst 中 前 i 个元素的方法) 仍然 $O(nlogn)$ randomized-select(仿造快排) 平均情况$O(n)$,最坏情况同上(快排), $\Theta(n^2)$ 1234567891011121314151617181920212223242526272829from random import randintdef select(lst,i): lst = lst.copy() def partition(a,b): pivot = lst[a] while a&lt;b: while a&lt;b and lst[b]&gt;pivot: b-=1 if a&lt;b: lst[a] = lst[b] a+=1 while a&lt;b and lst[a]&lt;pivot: a+=1 if a&lt;b: lst[b] = lst[a] b-=1 lst[a]= pivot return a def _select(a,b): if a&gt;=b: return lst[a] # randomized select n = randint(a,b) lst[a],lst[n] = lst[n],lst[a] pos = partition(a,b) if pos&gt;i: return _select(a,pos-1) elif pos&lt;i: return _select(pos+1,b) else:return lst[pos] return _select(0,len(lst)-1) github地址]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『计算机组成原理』总线]]></title>
    <url>%2Fbus.html</url>
    <content type="text"><![CDATA[总线 历史 分类 特性 性能指标 总线结构 总线控制 总线周期 总线标准 PCI USB 通信方式 同步 异步 半同步 分离式 引入 原理 特点 历史 以 ALU 为中心 以 MEM 为中心 总线 分类 根据数据传送方式: 串, 并 根据宽度: 8,16,32,64 根据使用范围: 计算机外设总线, 测控总线, 总线 根据连接部件 片内总线(芯片内) 系统总线: CPU, MEM, IO之间信息传输根据传递的信息功能分类 数据总线 地址总线 控制总线 特性 机械特性: 规定几何尺寸,形状,引脚等 电器特性: 信号方向, 电平范围等 功能特性: 多跟线不同的功能 时间特性: 时序 性能指标总线宽度：通常指数据总线的根数；总线带宽：总线的数据传输率，指单位时间内总线上传输数据的位数；总线复用：指同一条信号线可以分时传输不同的信号。总线的主设备（主模块）：指一次总线传输期间，拥有总线控制权的设备（模块）；总线的从设备（从模块）：指一次总线传输期间，配合主设备完成数据传输的设备（模块），它只能被动接受主设备发来的命令；总线的传输周期：指总线完成一次完整而可靠的传输所需时间；总线的通信控制：指总线传送过程中双方的时间配合方式。 总线结构 单总线 双总线(引入通道) 三总线1 IO总线, DMA 总线, 主存总线 三总线2 局部总线, 系统总线, 扩展总线 四总线 局部总线, 系统总线, 扩展总线, 高速总线 ( 适用高速 I/O 设备) 总线控制 判优 仲裁逻辑 链式查询 计数器定时查询 独立请求 比较 方式 每个设备用的总线数 实现 特点 原理 链式查询 2 简单 近的优先,对电路故障最敏感 BS总线忙,BR总线请求,BG总线同意.BG信号串行地从近到远传递到下一个IO接口, 如果此接口有总线请求, 总 BG 不再向下传,此接口得到总线使用权 计数器定时查询 ~log2n 稍复杂 平等,对故障不敏感 多了一组设备地址先,少了BG. 总线未被使用时,BS=0. 总线控制部件的计数器开始计数,然后通过设备地址先,向各设备发出一组地址信号. 到设备地址值与计数器值相同时,就获得总线使用权 独立请求 2n 很复杂 响应速度快,优先次序灵活(通过程序改变) 设备发出对应的请求信号,总线控制部件中有一个排队电路, 可根据优先次序确定响应设备. 通信 总线周期申请分配 -&gt; 寻址 -&gt; 传输/通信 -&gt; 结束 -&gt; 申请分配… 总线标准 PCI 高性能 不依附于 CPU 良好的兼容性 即插即用(Plug and Play) 每个 PCI 设备配有此设备的 reg, 供 BIOS 自动获取, 无需手动设置 USB 即插即用 通过 HUB 扩展连接 速度快 标准统一 有4根线, 两根信号, 两根电源 通信方式 同步通信双方由统一时标控制数据传送 异步允许各模块速度不一致,更加灵活. 没有公共的时钟标准,不一颗球所有部件严格统一操作时间, 而是应用应答方式(又称 握手方式) 不互锁 半互锁 全互锁半同步半同步通信既能像同步通信那样由统一时钟控制，又能像异步通信那样允许传输时间不一致，因此工作效率介于两者之间。分离式引入以上三种通信方式都是从主模块发出地址和读写命令开始，直到数据传输结输周期中，系统总线的使用权完全由占有使用权的主模块和由它选中的从模块占据。进一步分析读命令传输周期， 主模块通过传输总线向从模块发送地址和命令。 从模块按照命令进行读数据的必要准备。 从模块经数据总线向主模块提供数据。． 由第二点可见，对系统总线而言，从模块内部读数据过程并无实质性的信息传输，总线空闲。为了克服和利用这种消极等待，尤其在大型刘算机系统中，总线的负载已处于饱和状态，充分挖掘系统总线每瞬间的潜力，对提高系统性能起到极大作用。提出了“分离式”的通信方式 原理其基本思想是将一个传输周期（或总线周期）分解为两个子周期。在第一个子周期中，主模块A在得到总线使用权后将命令、地址以及其他有关信息，包括该主模块编号（当有多个主模块时，此号尤为重要）发到系统总线上，经总线传输后，由有关的从模块B接收下来。 主模块A向系统总线发布这些信息只占用总线很短的时间，一旦发送完，立即放弃总线使用权，以便其他模块使用。在第二个子周期中，当B模块收到A模块发来的有关命令信号后，经选择、译码、读取等一系列内部作，将A模块所需的数据准备好，使由B模块中请总线使用权，一旦获准，B模块便将A模块的号、B模块的地址、A模块所需的数据等一系列信息送到总线上，供A模块接收。很明显，上述两个传输子周期都只单方向的信息流，每个模块都变成了主模块。 特点 各模块欲占用总线使用权都必须提出串请。 在得到总线使用权后，主模块在限定的间内向对力传送信息，采用同步方式传送，不再 等待对方的回答信号。 各模块在准备数据的过程中都不占用总线，使总线可接受其他模块的请求。 总线被占用，或者通过它发送命令，或通过它传送数据，不存在空闲等待时间，充分地利用了总线的有效占用，从而实现了总线在多个主、从模块间进行信息交叉重叠并行式传送. 这种方式控制比较复杂，一般用于大型计算机系统]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『现代操作系统』IO设备]]></title>
    <url>%2FIO-device.html</url>
    <content type="text"><![CDATA[盘 硬件 磁盘 RAID CD-ROM 磁盘格式化 磁盘臂调度算法 错误处理 稳定存储器 目标 模型 原理 时钟 时钟硬件 构成 模式 时钟软件 软定时器 用户界面 键盘 键盘软件 模式, 回显 规范模式下的特殊字符 鼠标 硬件 原理 X Windows System 瘦客户机(thin client) 电源管理 思路 硬件问题 OS 问题 显示器 硬盘 CPU 内存 盘 硬件如磁盘, 硬盘, 软盘, 常作为辅助存储器. 磁记录, 根据每个小磁针的极性记录 0, 1. 写的时候, 改变电流方向利用电流的磁效应感性去磁性. 读的时候,利用电磁感应判断极性. 磁盘磁盘被组织成柱面, 每个柱面包含若干磁道,磁道数与垂直堆叠的磁头个数相同. 磁道被分成若干扇区. 重叠寻道(overlapped seek): 控制器同时操控多个驱动器进行寻道. 大多数磁盘都有一个虚拟的几何规格呈现给 OS, 控制器可以将虚拟的几何规格映射到实际的物理位置 RAID(Redundant Array of Inexpensive Disk) CPU 性能提升快于磁盘, 出现 并行 I/O 的思想—RAID ( 相对的, SLED(single large expensive disk)RAID 背后的思想是将一个装满了的磁盘盒子安装到计算机上, 用RAID 控制器替换磁盘控制器卡,将数据复制到整个RAID 上, 然后继续常规的操作 对 RAID 的并行操作, 目前有0级到7级 RAID. 层级这个名称或许用词不当, 这里没有分层结构,只是不同的组织形式而已 0 组成: 将 RAID 模拟的虚拟单个磁盘划分成 Stripe , 每个 stripe 带有 K个扇区, 0~ k-1扇区为 条带0, k~2k-1为条带1… 注意还未引入冗余, 实际上不是正真的 RAID 原理: 软件发出一条命令,如读取一个由四个连续 stripe 组成的数据块, 那么 RAID 控制器将命令分解为四个单独的命令, 每条命令对应每个磁盘块, 并行操作. 而软件并不知道这些 特点: 对于大量数据量的请求性能最好 1 真正的 RAID, 复制了所有的磁盘. 执行写, 每个 stripe 都被写了两次 执行读,可以任选一个副本. 具有很好的容错性(即时一个驱动器崩溃,有副本). 恢复简单:,安装一个新的驱动器复制到其上就可以了. 2 0和1操作的扇区条带, 而 2 是工作在字(甚至字节)的基础上. 如 将每个字节分割成 4位半字节对, 并形成 7 位的汉明码. 然后同步读写.效率高,(即时损失一位, 汉明码可以轻松处理).但是这要求所有驱动器旋转必须同步. 3 3 是 2 的简化, 为每个数据字计算奇偶校验位并写入即可. 4,5 使用stripe ,但是同样写有奇偶校验字., 然而计算 奇偶校验会降低效率. CD-ROM 磁盘格式化在磁盘使用之前,每个盘片必须经由软件完成低级格式化(low-level format). 格式化的磁盘容量约为物理容量 70%. 磁盘臂调度算法时间, 主要是寻到时间较长. 寻道时间 旋转延迟 实际数据传输时间 算法 FCFS 先来先服务: 很难优化寻道时间, SSF(Shortest Seek First) 最短寻道优先: 很可能在中间往返, 而不能处理靠边的请求, 响应时间很长 电梯算法(elevator algorithm): 电梯也是用的这种算法. 保存向一个方向移动直到向那个方向再没有服务请求到来. 由于寻道和旋转延迟太影响性能了, 所以一次只读一两个扇区效率低下,. 许多磁盘控制器常读出多个扇区并进行高速缓存(独立于操作系统的 高速缓存). 错误处理制造时的瑕疵可能出现坏扇区, 厂商需要设置控制器来处理坏区, 有如下方法, 控制器需要维护一个映射表来替换坏区 也可以由操作系统软件来处理, 首先要获得坏区列表,然后建立重映射表. 另外的问题: 备份操作系统要隐藏坏块, 使对备份应用程序不可见. AV盘🙈😮 稳定存储器 目标为了不丢失或损坏数据,保持磁盘的移植性,稳定存储器有必要的 它们是: 在写操作到来时, 要么成功执行, 要么对现有数据没有影响, 即时发生了磁盘或者 CPU 错误.并且是在软件中实现的 模型 在磁盘写一个块时, 写操作要么正确,要么错误,并且该错误可以在随后的读操作中通过检查 ECC 域检查出来 一个被正确写入的扇区可能会自发地变坏并且变得不可读(但是概率很小, 可以忽略) CPU 可能出现故障, 这时只能停机. 原理使用一对完全相同的磁盘,对应的块一同工作形成一个无差错的块. 定义如下三种操作 时钟既不是块设备, 也不是字符设备 时钟硬件 构成晶体震荡器, 计数器, 存储寄存器 模式 完成模式(one-shot mode): 当时钟启动时它把存储寄存器的值复制到计数器中，然后，来自晶体的每一个脉冲使计数器减1。当计數器变为0时．产生一个中断．并停止工作，直到软件再一次显式地启动它。 方波模式(square-wavemode): 当计数器变为0并且产生中断之后，存储寄存器的值自动复制到计数器中，并且整个过程无限期地再次重复下去。这些周期性的中断称为时忡滴答(clocktick). 可编程时钟的优点是其中断頻率可以由软件控制。可编程时钟芯片通常包含两个或三个独立的可编程时钟. 为了防止计算机的电源被切断时丢失当前时间，大多数计算机具有一个由电池供电的备份时钟，它是由在数字手表中使用的那种类型的低功耗电路实現的。电池时钟可以在系统启动的时候读出，如果不存在备份时钟，软件可能会向用户询问当前日期和时f对于一个连人网络的系统而言还有一种从远程主机获取当前时间的标群方法。无论是哪种情况，当前时间都要像UNIX所做的那样转换成自 1970 年 1 月 1 日 12 时 的UTC滴答数. 时钟软件时间硬件所做的只是根据已知时间间隔产生中断,其他与时间有关的工作都是软件—时钟驱动程序完成的. 如 维护日时间 因为 32 位的寄存器以滴答计数最多计数 2 年 防止进程超时运行 每启动一个进程,调度程序将一个计数器初始化为以滴答为单位的该进程的时间片取值. 每次时钟中断时,时钟驱动程序将时间片计数器减少1,当为 0 , 时钟驱动程序就 调用调度程序激活另一个进程 对 CPU 的使用情况记账 每启动一个程序, 需要对它使用的 CPU 时间计时, 使用一个辅助定时器, 全局变量维护一个指针(不太精确),指向进程表中当前运行的进程的表项,每一个 滴答, 就加 1 处理用户进程提出的 alarm 系统调用 为系统本身的各个部分提供监视定时器 完成概要剖析,监视和统计信息收集 注意: 在时钟中断期间, 时钟驱动程序需要做: 将实际时间加 1 将时间片减 1 并检查是否为0 对 CPU 记账 将报警计数器减 1 … 做很多事, 所以要仔细安排以加快速度 软定时器大多数计算机有辅助可编程时钟, 可以设置它以程序需要的任何速率引发定时器中断. 用户界面 键盘键盘包含一个嵌入式微处理器. 每按下一个键, 产生一个中断,释放键, 也产生一个中断. 键盘软件I/O 端口中段数字是键标号, 称为 扫描码(scan code),而不是 ASCII 码.键盘不超过128个, 所以只需7 个表示键编号, 第 8位为0 表示按下, 为 1 表示释放 模式, 非规范模式: 直接将扫描码传递给用户程序, 如 12 (这样过于原始, 且依赖机器 规范模式: 处理行内编辑, 如上面只需传递 2 回显键盘和监视器本来是两种 I/O 设备, 但用户的使用将他们联系起来, 即用户习惯 键入 , 然后在监视器上显示出来, 称为 echoing 回显 .这里就需考虑回显带来的问题, 一行超过 80 个字符, 换行? 制表符的处理 规范模式下的特殊字符 鼠标 硬件光学鼠标在其底部装备有一个或多个发光二极管和光电探瀏器。现代光学鼠标在其中有图像处理芯片并且获取处于它们下方的连续的低分辨率照片，寻找从图像到图像的变化。 鼠标可能具有一个，两个或者三个按钮,某些鼠标具有滚轮，可将额外的数据发送回计算机. 无线鼠标使用低功率无线电，例如使 Bluetooth将數据发这回计算机，而有线鼠标是通过导线将数据发送回。 原理当鼠标在随便哪个方向移动了一个确定的最小距离，或者按钮被接下或释放时。都会有一条消息发送给计算机。最小距离大约是0.1mm（尽管它可以在软件中设置）。有些人将这一单位称为一个鼠标步(mickey) 发送的消息为 (Δx,Δy,button). 通常，消息占3字节, 速度最多每秒40次．注意，鼠标仅仅指出位上的变化，而不是绝对位置本身。如果轻轻地拿起鼠标并且轻轻地放下而不导致橡皮球旋转．那么就不会有消息发出。某些GUI 区分单击与双击鼠标接钮。如果两次点击在空间上〈鼠标步）足够接近，并且在时间上(亳秒)也足够接近，那么就会发出双击信号。最大的“足够接近”是软件的事情，并且这两个参数通常是用户可设置的。 X Windows System几乎所有 UNIX 系统的用户界面都以 X 为基础. 如 GNOME, KDE 当 X 在一台机器上运行时, 采集键盘与鼠标输入并且输出到屏幕上的软件称为 X serverX server 常位于用户计算机的内部, 而 X 客户可能在远程计算服务器上. 注意 X 只是一个窗口系统, 不是一个完全的 GUI. 要获得完全的 GUI, 需要在器上运行其他软件层. 瘦客户机(thin client) 电源管理 思路 当计算机的某些部件(主要是 I/O 设备)不同的时候让 OS 关闭他们. 应用程序使用较少的能量 硬件问题计算机状态: 工作, 睡眠, 休眠, 关闭权衡: 消耗电量从左到右递减, 关闭状态不耗电量. 但是从睡眠, 休眠状态恢复到工作状态, 后者需要更多的时间和电量. OS 问题通过算法或者试探, 让 OS 对关于关闭什么设备以及何时关闭能够作出良好的决策 显示器一段时间后可以关闭屏幕(是睡眠,可以立即唤醒))改进: 将屏幕分成多个区域, 可以关闭当前窗口(或者用户自己定义)未覆盖的区域. 窗口管理器还可以使窗口与区域对齐, 进一步地, 部分照亮关闭的区域 硬盘即时不存在存取操作,硬盘也消耗大量的能量以保持高速旋转.(不然加速需要很长时间 呢(●ˇ∀ˇ●)). 但是注意 停止硬盘是休眠不是睡眠.此外,重新硬盘启动会消耗更多的能量.因此, 每个硬盘有一个特征时间 T, 为它的盈亏平衡点. 如果能预测将来多久才用到硬盘(可以基于存取历史), 那么如果将来时间讲个 ΔT &gt; T, 就可以关闭. CPU睡眠中的 CPU 几乎不耗电, 只需等待中断的到来才唤醒.CPU 电压可以用软件降低,但会降低时钟速度. 由于电能消耗与电压的平方成正比, 而电压与时钟速度成正比, 所以可以有降低的平衡点来盈利 内存 刷新然后关闭高速缓存 cache 可以重新加载且不损失信息, 而且速度快, 将主存内容写到磁盘上, 然后关闭主存本身.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『现代操作系统』IO硬件原理]]></title>
    <url>%2FIO-hardware.html</url>
    <content type="text"><![CDATA[I/O 硬件原理 0.1. I/O 设备 0.1.1. 块设备(block device) 0.1.2. 字符设备(character device) 0.2. 设备控制器(device controller / adapter) 0.3. 内存映射 I/O 0.3.1. 方案 0.3.2. 工作原理 0.3.3. 优点 0.3.4. 缺点 0.4. DMA(直接存储器存取, Direct Memory Access) 0.4.1. 工作原理 0.4.2. 对 CPU 的延迟 0.4.2.1. 周期窃取(Cycle Stealing) 0.4.2.2. 突发模式(burst mode) 0.5. 中断 0.5.1. 问题 0.5.1.1. 哪些信号需要保存? 0.5.1.2. 保存在哪里? 0.5.1.3. 谁来保存? 0.5.1.4. 考虑流水线,超标量(内部并行) 0.1. I/O 设备 0.1.1. 块设备(block device)把信息存储在固定大小的块中,每个块都有自己的地址. 每个块可以独立于其他块读写. 如 硬盘, CD-ROM , USB 盘 … 0.1.2. 字符设备(character device)字符设备以字符为单位发送或接收一个字符流, 而不考虑任何块结构. 它是不可寻址的.如打印机,网络接口, 鼠标(用作指点设备)… 0.2. 设备控制器(device controller / adapter)I/O 设备一般由两部分组成: 机械部分和电子部分.电子部分就是设备控制器. 常以插入(PCI)扩展槽中的印刷电路板的形式出现. 控制器与设备之间的接口是很低层次的接口. 它的任务就是把串行的位流转换为字节块,并进行必要的错误校正. 0.3. 内存映射 I/O每个控制器有几个寄存器, OS 可以读写来了解,更改设备的状态信息. 控制器还有 OS 可以读写的 数据缓冲区. 问题来了: CPU 如何与设备的控制寄存器和数据缓冲区通信. 0.3.1. 方案 方法一: 每个控制寄存器被分配一个 I/O 端口(所有端口形成端口空间,受保护不被普通用户访问). 然后可以设置指令来读写, 如 IN REG, PORT将读取控制器寄存器 PORT 中的内容到 CPU 寄存器 REG 方法二: 内存映射 I/O. 将所有控制寄存器映射到内存空间, 都被分配唯一的地址, 且这些内存地址不会再分配. 0.3.2. 工作原理CPU 读入一个字时, 不论是从内存还是 I/O 端口, 都将目的地址放在总线的地址线上, 总线控制线置 READ 信号看. 还要用一条线表明是 I/O 空间 还是内存空间. 如果是 I/O空间, I/O设备将响应请求. 0.3.3. 优点 如果需要特殊的 I/O 指令读写设备控制寄存器,那么访问这些寄存器需要使用汇编代码, 调用这样的过程需要增加开销, 对于`内存映射 I/O ,设备控制寄存器只是内存中的变量, 和其他变量一样寻址,可以用 C 语言编写驱动程序 对于内存映射 I/O , 不需要特殊的保护机制来阻止用户进程执行 I/O 操作. 操作系统只需注意不要将内存映射的地址映射到用户虚拟地址空间. 更有利的是, 如果有多个设备, 可以将内存映射 I/O 映射到不同的页, 可以分配特定的页给用户,使其使用驱动程序, 而且不担心各驱动程序之间的影响 0.3.4. 缺点 不能对设备控制器的寄存器进行 cache, 因为设备的状态改变, 软件将没有办法发现. 所以硬件必须对每个页面具备选择性的禁用 chche. 增加了复杂性 在内存映射机器上, 具有单独的内存总线会使 I/O 设备没有办法查看内存地址,因为内存地址旁路到内存总线上, 没有办法响应. 0.4. DMA(直接存储器存取, Direct Memory Access)独立于 CPU 访问系统总线 0.4.1. 工作原理 也就是不用浪费 CPU 处理缓冲区到内存的时间, 相当于另有一个” CPU “ 专门处理 磁盘 到 内存 的 I/O 0.4.2. 对 CPU 的延迟 0.4.2.1. 周期窃取(Cycle Stealing)注意 上面的操作是字模式传送, 在 DMA 请求传送一个字并且得到这个字时, CPU 不能使用总线,必须等待. 0.4.2.2. 突发模式(burst mode)上面是字传输模式, 对于块模式下的传送, DMA 会发起一连串的传送,然后才释放总线. 这比周期窃取效率更高. 上面 的模式是飞越模式(fly-by mode), 即 DMA 控制器直接通知设备控制器将数据传送到 主存, 只请求一次总线 某些 DMA 使用其他模式. 让设备控制器将字发送到 DMA, 然后 DMA 再 请求总线将数据发送到其他地方(其他设备, 主存…), 这样会多消耗一个总线周期, 但是更加灵活: 可以 设备-&gt;设备, 内存-&gt;内存(内存读, 然后 内存写) 不使用 DMA 的考虑: CPU 比 DMA 快得多,当限制因素不是 I/O 设备的读写速度时,没必要使用 DMA 去除 DMA 而用 CPU 使用软件做所有工作可以节省硬件的开销 0.5. 中断当一个 I/O 设备完成它的工作后,它就产生一个中断, 通过在分配给它的一条总线信号线上置起信号. 如果有多个中断请求, 按优先级, 如果还没有被处理, 设备一直发出中断知道得到 CPU 服务 中断控制器通过在地址先上放置一个数字(中断向量 interrupt vector)表明哪个设备需要关注,同时向 CPU 发出中断 中断信号导致 CPU 停止当前工作, 并处理其他事情. 根据中断向量跳转到需要的中断服务程序 0.5.1. 问题开始中断服务之前, 硬件需要保存信息 0.5.1.1. 哪些信号需要保存?至少程序计数器, 至多可见的寄存器, 一些内部寄存器… 0.5.1.2. 保存在哪里? 如果放在内部寄存器, 那么中断控制器之后无法得到应答,知道所有可能的相关信息被读出,以免第二个中断重写内部寄存器保存状态. 这样在中断被禁止时将导致长时间的死机,并可能丢失中断和数据 如果在堆栈中, 使用谁的堆栈? 如果使用当前堆栈, 可能是用户进程的,堆栈指针可能是不合法的. 可能指向一个页面的末端, 若干次内存写之后, 可能超出页面发生页面故障. 那么在何处保存状态以处理页面故障? 如果用内核堆栈. 切换到和心态可能要求改变 MMU 上下文, 并且可能使 cache 和 TLB 的大部分失效. 静态地或动态地重新状态所有东西将增加处理一个中断的时间,因而浪费 CPU 的时间0.5.1.3. 谁来保存?对谁可见就谁来保存 0.5.1.4. 考虑流水线,超标量(内部并行)在流水线满的时候,如果出现一个中断, 由于许多指令处于不同的正在执行的截断. 程序计数器可能无法正确反应已经执行的指令和未执行之间的边界.在超标量机器上, 指令可能分解成微操作, 为操作可能乱序执行 精确中断(precise interrupt):将机器留在一个明确状态 不精确中断(imprecise interrupt) 不满足上面的条件]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『现代操作系统』IO软件原理]]></title>
    <url>%2FIO-software.html</url>
    <content type="text"><![CDATA[IO软件目标 IO处理方式 IO软件层次 中断处理程序 设备驱动程序 位置 功能 运行 与设备无关的I/O软件 用户空间的IO软件 IO软件目标 设备独立性(device independence): 编写的程序能够访问任何设备而无需事先指定. 即程序的通用性 统一命名(uniform naming): 一个文件或一个设备的名字应该是一个简单的字符串或数字. 错误处理(error handling): 错误应该尽可能接近硬件得到处理. 处理不了再上传 同步(synchronous) 和 异步(asynchronous)(即中断驱动): 大都数物理 I/O 是 异步的 IO处理方式 程序控制 I/O 让 CPU 做全部 I/O工作,成为程序控制 I/OCPU 要不断地查询设备, 这成为 polling 或 busy waiting 中断驱动 I/O 缺点是 中断发生在每个事件上, 同样要花一些时间,如打印一个缓冲区的字符, 每个字符都要中断一次 使用DMA 需要特殊的硬件 DMA 控制器, 每个缓冲区中断一次 IO软件层次 中断处理程序 设备驱动程序每个连接到计算机上的 I/O 设备都需要某些设备特定的代码来对其进行控制 , 注意 设备控制器是硬件上的, 驱动程序是软件上的. 位置为了访问设备的硬件(即设备控制器的寄存器), 设备驱动程序需要是系统内核的一部分. 其实也可以构造运行在用户空间的驱动程序,使用系统调用来读写设备寄存器. 这样可以使内核与驱动程序, 驱动程序之间隔离, 消除驱动程序干扰内核造成的系统崩溃. 功能 接收来自其上方与设备无关的软件发出的抽象的读写请求 如果需要, 驱动程序 必须对设备进行初始化,还可能对电源需求和日志事件进行管理 运行驱动程序在执行期间动态地装在到系统 与设备无关的I/O软件功能 缓冲 错误报告 分配与释放专用设备 提供与设备无关的块大小 设备驱动程序的统一接口 用户空间的IO软件 C 语言中的 printf 假脱机(spoolilng) 如果一个进程打开它, 然后很长时间不使用, 则其他进程都无法打印 . 另外一种方法是 创建一个 守护进程(daemon) 和假脱机目录. 一个进程要打印一个文件时, 首先生成要打印的整个文件, 并且放在假脱机目录, 由守护进程打印该目录下的文件, ,,守护进程是唯一允许使用打印机特殊文件的进程.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『现代操作系统』操作系统引论]]></title>
    <url>%2Fos-general.html</url>
    <content type="text"><![CDATA[操作系统引论 位置 功能 向应用程序提供抽象—自顶向下 资源管理—自底向上 发展历史 第一代(1945-1955)—真空管和穿孔卡片 第二代(1955-1965)—晶体管和批处理系统 第三代(1965-1980)—集成电路芯片和多道程序设计 第四代(1980至今)—个人计算机 操作系统结构 单体结构 层次式系统 微内核 Client-Server模式 虚拟机 优点 条件 Ⅰ型管理程序 Ⅱ型管理程序 准虚拟化(paravirtualized) 位置 功能 向应用程序提供抽象—自顶向下抽象是管理复杂性的一个关键, 好的抽象可以把一个几乎不可能管理的任务划分为两个可管理的部分: 有关抽象的定义和实现 用这些抽象解决问题 资源管理—自底向上在相互竞争的程序之间有序地控制对处理器, 存储器以及其他 I/O 接口设备的分配 发展历史 第一代(1945-1955)—真空管和穿孔卡片ENIAC , 程序设计是用纯粹的机器语言, 使用: 程序员在墙上的机时表上预约一段时间,,然后到机房中将他的插件板接到计算机中,在接下来的几小时等待(计算的都是简单的数字运算, 如制作对数表) 第二代(1955-1965)—晶体管和批处理系统批处理系统(batch system), 在输入室中手机全部的作业 ,然后用一台相对便宜的计算机,读到磁带上. 磁带被送到机房里并装到磁带机上. 然后操作员装入一个特殊的程序(现代操作系统的前身), 它从磁带上读入第一个作业并运行. 如此反复 第三代(1965-1980)—集成电路芯片和多道程序设计多道程序设计(multiprogramming): 若当前作业因等待磁带或其他 I/O 操作而暂停时, 为了不让 CPU 一直等待这一个作业, 将内存分几个部分, 每一部分存放不同的作业, 在一个作业等待 I/O 时, 可以让另一个作业使用 CPU. 在内存中防止多个作业需要特殊的硬件来保护, 以免作业的信息被窃取或受到攻击. 程序员希望得到更快响应, 由此出现分时系统(timesharing). 第四代(1980至今)—个人计算机大规模集成电路(LSI)的发展, 晶体管个数在单位平方厘米面积的芯片上可达数千个. 逐步发展处 网络操作系统, 分布式操作系统 操作系统结构 单体结构 主程序: 处理服务过程请求 服务过程: 执行系统调用 实用过程: 辅助服务过程 层次式系统 微内核传统上,所有的层都在内核中, 但是这样并没有必要. 尽可能减少内核态中功能的做法更好. 要知道, 代码量越大, bug 越多. 思想为了实现高可靠性,将操作系统划分成更小的, 良好定义的模块. 只有其中一个模块—微内核 运行在内核态上. Client-Server模式将进程划分为两类, 服务器: 提供服务 客户端: 使用服务 通常在系统最底层是微内核 虚拟机 优点 节省硬件成本, 如不同服务器(web, ftp, mail…)可以在一台宿主机上 同时运行多个 OS 的需求(如软件开发过程, 运行在某些 OS 不支持的程序) 检查点, 虚拟机的迁移: 仅需移动内存映像 条件 敏感指令( sensitive instruction ).:有内核态和用户态的 CPU 的一组只能在内核态执行的指令集, 比如 I/O 指令, 改变 MMU 状态的指令等, 特权指令( privileged insttruction): 在用户态下执行会引起陷入 当 敏感指令是 特权指令的子集时, 机器才是可虚拟化的 解决的基本思想: 创建容器使得虚拟机在其内运行 Ⅰ型管理程序在其上的 OS 称为客户操作系统 虚拟机在用户态以用户进程的身份运行, 因此不允许执行敏感指令,否则崩溃 在支持VT技术的 CPU 上, 客户操作系统执行敏感指令会发生陷入. 管理程序分析指令 来自客户操作系统: 管理程序调度将要执行的指令 来自虚拟机中用户程序: 仿真面对运行在用户态的敏感指令时真是硬件的行为 Ⅱ型管理程序在其上的 OS 称为宿主操作系统,如上图 b VMware就是采用的这种管理程序: 当运行一个二进制文件, VMware 先浏览代码段以寻找基本块(basic block). 所谓基本块就是以 jump, call, trap 等改变控制流的指令结束的可顺序执行的指令序列, 而基本块中就不含其他改变 程序计数器 的指令 如果基本块中含有敏感指令, VMware 将其替换为相应的 VMware 过程调用, 基本块的最后一条指令也被过程调用替换 这种 找出, 仿真敏感指令 的技术称为 二进制翻译(binary translation) 所以, 即使在不可虚拟化的硬件上, Ⅱ型 也能正常: 因为所有的敏感指令被仿真, 不会被真正的硬件执行,管理程序的调用可以代替. 准虚拟化(paravirtualized)前面介绍的两种, 在其上的客户操作系统都是没有修改过的. 可以更改客户操作系统的源码, 将其中的敏感指令都转换为 管理程序调用. 这就要给管理 程序 定义 过程调用集合, 从而形成 API, 虽然这个接口是供客户 OS, 而不是 应用程序. 其实就将管理程序变成了一个微内核. 这种方法就是准虚拟化, 这样会使得虚拟机技术更容易被支持和使用 问题: 如果所有敏感指令都被代替, 操作系统不能在物理机器上运行 如果市场下有很多管理程序, 有不同的 API 接口 Amsden 的一个解决方案:当内核需要执行一些敏感指令操作时会调用特殊的例程(称为 VMI 虚拟机接口), VMI 形成的底层与硬件或管理程序进行交互. 将 VMI 设计得通用化, 不依赖硬件或特定的管理程序]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『Unix环境高级编程』linux 文件 I/O]]></title>
    <url>%2Flinux-file-io.html</url>
    <content type="text"><![CDATA[文件描述符非负整数, 默认使用最小的可用的整数0,1,2 对应 STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO 读写函数#include&lt;unistd.h&gt; int open(const char path,int oflag … /mode*/);flag: 必须选1: O_RDONLY, O_WRONLY, O_RDWR, O_SEARCH, O_EXEC 可选: O_APPEND, O_CREAT, O_EXCL, O_SYNC, O_TRUNC eg O_WDONLY | O_CREAT | O_TRUNC int close(int fd); off_t lseek(int fd, off_t offset, int whence)hence: SEEK_SET, SEEK_CUR, SEEK_END 错误则返回-1ffset 可负, 可以超过文件大小, 在超过文件大小后写,会形成空洞, 用\0填补,但是不占用磁盘块 ssize_t read(int fd, void *buf,size_t nbytes);ﬁ未到EOF,则读取nbytes,返回nbytes, 否则剩多少,读多少,返回多少(到EOF就是0) ssize_t write(int fd, void buf,size_t nbytes);io效率**: buf设置为4096及更大效率较高 进程文件结构![image.png](https://upload-images.jianshu.io/upload_images/7130568-41de9a42f1c26214.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ![image.png](https://upload-images.jianshu.io/upload_images/7130568-88491773353c7aa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 文件共享![image.png](https://upload-images.jianshu.io/upload_images/7130568-bb62bdea0df113e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 原子操作一般有多个函数的操作,, 不是原子操作, 多进程运行时可能出错,比如 12seek pointer to endwrite 单进程没有问题, 而多进程访问同一个文件, 而不是同一个文件描述符时, 比如a,b访问f 当a执行完seek到end后 ,写指针在n, b执行seek to end 然后写至x bytes,此时文件指针已经到n+x, 但是a会在n处继续执行写,然后就覆盖了bxx的内容 复制文件描述符dup dup212345#include&lt;unistd.h&gt; int dup(int fd); // copy fd int dup2(int fd,int fd2) // close fd2 and open fd, note it's an atomic op //if fd2==fd : return fd2 ![image.png](https://upload-images.jianshu.io/upload_images/7130568-5a24c92f20e687e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 参考资料: UNIX环境高级编程 W.Richard Stevens, Stephen A. Rago]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>读书笔记</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『现代操作系统』多处理机]]></title>
    <url>%2Fmultiprocessor.html</url>
    <content type="text"><![CDATA[多处理机简介 多处理机硬件 UMA(Uniform Memory Access) 基于总线的UMA多处理机体系结构 基于交叉开关的UMA多处理机 基于多级交换的UMA多处理机 NUMA(nonuniform memory access) 多核芯片 多处理机操作系统类型 每个 CPU 都有自己的操作系统 主从多处理机 对称多处理机(Symmetric MultiProcessor, SMP) 多处理机调度 分时 空间共享 群调度( Gang Scheduling) 基本思想 调度方法 参考资料 多处理机简介 共享存储器多处理机 每个cpu都可同样访问 消息传递多计算机 通过某种高速互联网络连接在一起, 每个存储器局部对应一个cpu, 且只能被该cpu访问,这些cpu 通过互联网络发送多字消息通信易于构建, 编程难 广域分布式系统 通过广域网连接,如Internet, 多处理机是共享存储器多处理机的简称,多个cpu共享一个公用的RAM. 多处理机硬件所以多处理机都具有每个cpu可访问全部存储器的性质,而有些多处理机有一些特性, UMA(Uniform Memory Access)读出每个存储器字的速度一样快 基于总线的UMA多处理机体系结构 基于交叉开关的UMA多处理机 基于多级交换的UMA多处理机 此开关检查module域来决定连入哪个存储器, 即连接x还是y 例如 Omega网络n个cpu/存储器, 有 log2n级, 每级只需n/2个开关, 比较: 网络 开关数 是否阻塞 交叉开关 n2 不阻塞 Omega网络 n/2*log2n 阻塞 NUMA(nonuniform memory access)特性: 具有对所有cpu都可见的单个地址空间 通过 LOAD 和 STORE 指令来访问运程存储器 访问远程存储器慢于访问本地存储器 基于文件的多处理机基本思想: 维护一个数据库来记录告诉缓存行的位置及其状态. 当一个高速缓存行被引用时,就查询数据库找出高速缓存行的位置以及它的dirty记录,(是否被修改过), 多核芯片每个核就是一个完整的 CPU , 可以共享内存, 但是 cache 不一定共享. 时常被成为 片级多处理机(Chip-level MultiProcessors, CMP). 与基于总线的多处理机和使用交换网络的多处理机的差别不大: 基于总线的 每个CPU 都有自己的cache CMP容错性低: 连接紧密, 一个共享模块的失效可能导致其他 CPU 出错 片上系统 (system on a chip)芯片包含多个核,但是同时还包含若干个专业核, 比如视频与音频解码器, 加密芯片,网络接口等 多处理机操作系统类型 每个 CPU 都有自己的操作系统优点: 共享操作系统代码 注意 在一个进程进行系统调用时,是在本机的 CPU 上被捕获并处理的,并使用操作系统表中的数据结构 因为每个操作系统都有自己的表,那么也有自己的进程集合, 通过自身调度这些进程,而没有进程共享. 如果一个用户登陆到 CPU1 , 那么他的进程全在 CPU1 上, 也就是可能导致其他CPU 空载 没有页面共享: 可能出现 CPU2 不断进行页面替换而 CPU1 却有多余的页面 cache 不一致 主从多处理机 问题如果有很多 CPU , 主 CPU 会成为瓶颈, 速度慢 对称多处理机(Symmetric MultiProcessor, SMP) 消除了主从处理机的不对称性, 在存储器中有操作系统的一个副本, 但任何 CPU 都可以运行它. 这个模型动态平衡进程和存储器, 因为它只有一套操作系统数据表.它存在的问题: 当两个或多个 CPU 同时运行操作系统代码时, 如请求同一个空闲存储器页面,这时应该使用互斥信号量(锁),使整个系统成为一大临界区. 这样在任一时刻只有一个 CPU 可运行操作系统 多处理机调度调度对象: 单进程还是多进程, 线程是内核进程还是用户线程. 用户线程: 对内核不可见,那么调度单个进程,. 内核线程: 调度单元是线程, 分时 先讨论调度独立线程的情况, 如果有 CPU 空闲则选择优先级队列中的最优先线程到此 CPU 缺点: 随着 CPU 数量增加引起对调度数据结构的潜在竞争 当线程在 I/O 阻塞时引起上下文切换的开销(overhead) 亲和调度: 基本思想, 尽量使一个线程在它前一次运行过的 CPU 上运行, 空间共享 当线程之间以某种方式彼此相关时, 可以使用此方法. 假设一组相关的线程是一次性创建的, 创建时, 检查是否有足够的空闲 CPU, 有 则 各自获得专用的 CPU, 否则等待, 优点: 消除了多道程序设计, 从而消除上下文切换开销缺点: 当CPU被阻塞或根本无事可做时时间被浪费了 群调度( Gang Scheduling) 基本思想让一个进程的所有线程一起运行, 这样互相通信更方便,在一个时间片内可以发送和接收大量的消息. 调度方法 把一组相关线程作为一个单位,即一个群, 一起调度 一个群中的所有成员在不同的分时 CPU 上同时运行 群中的所有成员共同开始和结束其时间片 参考资料 现代操作系统 Multi-Processor Systems | UCLA]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『linux』c 语言实现一个简易的 shell]]></title>
    <url>%2Fsimple-shell.html</url>
    <content type="text"><![CDATA[Table of Content Table of Content 1. 测试结果 2. 大致框架 3. 全局变量说明 3.1. cmdStr 3.2. cmdNum, varNum 3.3. envVar 3.4. cmd 结构 4. 解析命令字符串 5. 多条命令的解析—; 6. 实现后台运行—-&amp; 7. 处理变量—$ 8. 内建命令 8.1. 实现 ls 8.2. 实现 cd 8.3. 实现 pwd 8.4. 实现unset 8.5. 实现 export 9. 实现重定向与管道— &lt;,&gt;,&gt;&gt;,| 9.1. 文件重定向 9.2. 管道重定向 10. 外部命令 11. 其他 12. 完整代码 为了让用户可以控制系统，Linux 系统一般会运行一个 shell 程序。通常来说，shell 程序不会是系统启动后运行的第一个进程（也就是 init 进程), 下面通过c语言来实现一个简单的shell. 首先实现大致框架, 然后逐步增强,添加功能.它支持一些内部命令, 如 pwd, ls, cd, cat, env, export, unset 以及外部命令支持一些特色 features: \t support redundant blank(\t, spaces) &quot; &#39; support quote \ multi-line input | pipe &lt; &gt; &gt;&gt; redirect ; multi-cmd &amp; background $ support varible: echo “.. $VAR” 1. 测试结果先上结果 (。・∀・)ノ 2. 大致框架首先可以大致写出框架: 打印提示符, 解析命令, 执行内置命令, 执行外部命令. 循环 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//by osh助教#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;int main() &#123; /* 输入的命令行 */ char cmd[256]; /* 命令行拆解成的各部分，以空指针结尾 */ char *args[128]; while (1) &#123; /* 提示符 */ printf("# "); fflush(stdin); fgets(cmd, 256, stdin); /* 清理结尾的换行符 */ int i; for (i = 0; cmd[i] != '\n'; i++) ; cmd[i] = '\0'; /* 拆解命令行 */ args[0] = cmd; for (i = 0; *args[i]; i++) for (args[i+1] = args[i] + 1; *args[i+1]; args[i+1]++) if (*args[i+1] == ' ') &#123; *args[i+1] = '\0'; args[i+1]++; break; &#125; args[i] = NULL; /* 没有输入命令 */ if (!args[0]) continue; /* 内建命令 */ if (strcmp(args[0], "cd") == 0) &#123; if (args[1]) chdir(args[1]); continue; &#125; if (strcmp(args[0], "pwd") == 0) &#123; char wd[4096]; puts(getcwd(wd, 4096)); continue; &#125; if (strcmp(args[0], "exit") == 0) return 0; /* 外部命令 */ pid_t pid = fork(); if (pid == 0) &#123; /* 子进程 */ execvp(args[0], args); /* execvp失败 */ return 255; &#125; /* 父进程 */ wait(NULL); &#125;&#125; 上面的大致框架是助教写的示例, 下面我将一步步的改进, 我的完整代码见文末 3. 全局变量说明 3.1. cmdStr是用来接收输入的一个字符串数组 3.2. cmdNum, varNumcmdNum记录 以 ; 分开的命令数目,varNum 记录 每条命令中的变量 $ 的个数 3.3. envVar存储环境变量 3.4. cmd 结构123456789struct cmd&#123; struct cmd * next; int begin,end; // pos in cmdStr int argc; char lredir,rredir; //0:no redirect 1 &lt;,&gt; ; 2 &gt;&gt; char toFile[MAX_PATH_LENGTH],fromFile[MAX_PATH_LENGTH]; // redirect file path char *args[MAX_ARG_NUM]; char bgExec; //failExec&#125;; next 是用来指向管道的下一次指令, 而全局变量 cmdinfo 数组定义如下1struct cmd cmdinfo[MAX_CMD_NUM]; 是用来存放以 ; 分开的多条指令. 4. 解析命令字符串上面的大致框架简单实现中, 不够强壮, 比如命令字符串中不能连续多个空格等等. 所以在最后面的代码中, 重新实现解析命令字符串, 就是 parseArgs函数, 限于篇幅, 代码见文末. 这些函数解析命令字符串, 能支持多个空格, 支持多行输入, 支持了变量$, 支持引号&#39;,&quot;, 同时为重定向 &lt;,&gt;,&lt;&lt;,以及 管道 |,做好准备 5. 多条命令的解析—;parseCmds 函数解析多行输入,处理多个空格, \t 符号换为空格, 将多行命令通过命令结点形成链表.在这个函数中, 也解析后台运行&amp;符号, 如果有的话, 就设置命令头结点 的 head-&gt;bgEXec 6. 实现后台运行—-&amp;这只需在创建子进程的实现, 是否让父进程 wait这在 main 函数中可以看到1if(!pcmd-&gt;bgExec)wait(NULL); 7. 处理变量—$在 parseCmds 函数 解析命令字符串时, 调用 handleVar 函数解析变量, 其工作是指示是否有变量, 如果有就解析记录下变量的名字 8. 内建命令对于内建命令, 比如 ls, pwd, exit, env, unset 可以直接执行在代码中, 内建命令的实现都在 execInner 函数中, 如果不是内建命令, 则返回1, 然后会调用执行外部命令的函数 execOuter 8.1. 实现 ls1234567891011 int LS(char *path)&#123; DIR *dirp; struct dirent d,*dp = &amp;d; dirp = opendir(path); int ct=0; while((dp=readdir(dirp))!=NULL)&#123; printf("%s\n",dp-&gt;d_name);//,++ct%5==0?'\n':''); &#125; closedir(dirp); return 0;&#125; 8.2. 实现 cdpcmd-&gt;args[1] 是目的路径的指针12345678910struct stat st;if (pcmd-&gt;args[1])&#123; stat(pcmd-&gt;args[1],&amp;st); if (S_ISDIR(st.st_mode)) chdir(pcmd-&gt;args[1]); else&#123; printf("[Error]: cd '%s': No such directory\n",pcmd-&gt;args[1]); return -1; &#125;&#125; 8.3. 实现 pwd1printf("%s\n",getcwd(pcmd-&gt;args[1] , MAX_PATH_LENGTH)); 8.4. 实现unsetunsetenv 调用, pcmd-&gt;args[i]是命令的各个参数的指针, 注意从1开始, 第0个参数是命令程序自己1for(int i=1;i&lt;pcmd-&gt;argc;++i)unsetenv(pcmd-&gt;args[i]); 8.5. 实现 export1234567for(int i=1;i&lt;pcmd-&gt;argc;++i)&#123; //putenv( pcmd-&gt;args[i]); char *val,*p; for(p = pcmd-&gt;args[i];*p!='=';++p); *p='\0'; val = p+1; setenv(pcmd-&gt;args[i],val,1); &#125; 9. 实现重定向与管道— &lt;,&gt;,&gt;&gt;,|首先要知道一些关于linux文件I/O的知识, 可以看我这篇笔记 重定向的I/O 以及 管道的I/O, 我都放在 setIO 函数中处理,如下.这个函数接受的参数包括一个命令指针 pcmd (以;分隔的, 包括管道中的命令), 以及 一个输入文件描述符rfd,一个输出文件描述符wfd. 9.1. 文件重定向如果这条命令中( pcmd-&gt;rredir输出重定向) /( pcmd-&gt;lredir 输入重定向) 不为0, 就打开重定向的文件得到其文件描述符, 然后将标准 输出/输入文件描述符关闭, 再复制(用的dup2)到此文件描述符, 注意最后用完 此文件描述符 要用close关闭它. 9.2. 管道重定向分别检查 文件描述符参数 是否 是标准输入,输出, 如果不是, 说明传递的是管道, 新的文件描述符, 就将相应的 标准输入/输出 关闭 ,再复制到 rfd/wfd, 最后close rfd/wfd 1234567891011121314151617181920212223242526void setIO(struct cmd *pcmd,int rfd,int wfd)&#123; /* settle file and pipe redirect */ if(pcmd-&gt;rredir&gt;0)&#123; // &gt;, &gt;&gt; int flag ; if(pcmd-&gt;rredir==1)flag=O_WRONLY|O_TRUNC|O_CREAT; // &gt; note: trunc is necessary!!! else flag=O_WRONLY|O_APPEND|O_CREAT; // &gt;&gt; int wport = open(pcmd-&gt;toFile,flag); dup2(wport,STDOUT_FILENO); close(wport); &#125; if(pcmd-&gt;lredir&gt;0)&#123; //&lt;, &lt;&lt; int rport = open(pcmd-&gt;fromFile,O_RDONLY); dup2(rport,STDIN_FILENO); close(rport); &#125; /* pipe */ if(rfd!=STDIN_FILENO)&#123; dup2(rfd,STDIN_FILENO); close(rfd); &#125; if(wfd!=STDOUT_FILENO)&#123; dup2(wfd,STDOUT_FILENO); close(wfd); &#125;&#125; 10. 外部命令实现的函数是 execOuter, 里面包括了重定向, 管道, 下面再介绍对于外部命令, 应该 fork 一个 子进程, 让后让程序在子进程执行并返回, 可以使用 exec 家族的函数, 它会自动调用相应程序文, 件运行(忘了在哪个目录了��), 我用的 execvp 函数 如果当前命令 的 next 为 NULL, 即没有下一条管道命令, 那么直接将标准文件描述符传给 setIO 处理好文件 IO, 然后调用execvp 执行外部命令即可 如果不为NULL, 说明有管道, 建立管道 , 用fork来新建子进程 执行管道命令, 这时传递到 setIO 函数的 对应 是 管道文件描述符的 输入输出, 然后如果有多个管道, 可以递归地调用 execOuter函数, 如 cmd1 | cmd2 | cmd3…我的实现是子进程执行 cmd1, 然后 将 cmd2 | cmd3 做为一个新命令传给 execOuter递归执行, 由于是用链表将各管道命令连起来的, 所以 直接传递 pmcd-&gt;next 即可, 非常方便1234567891011121314151617181920212223int execOuter(struct cmd * pcmd)&#123; if(!pcmd-&gt;next)&#123; setIO(pcmd,STDIN_FILENO,STDOUT_FILENO); execvp(pcmd-&gt;args[0],pcmd-&gt;args); &#125; int fd[2]; pipe(fd); pid_t pid = fork(); if(pid&lt;0)&#123; Error(FORK_ERROR); &#125;else if (pid==0)&#123; close(fd[0]); setIO(pcmd,STDIN_FILENO,fd[1]); execvp(pcmd-&gt;args[0],pcmd-&gt;args); Error(EXEC_ERROR); &#125;else&#123; wait(NULL); pcmd = pcmd-&gt;next; //notice close(fd[1]); setIO(pcmd,fd[0],STDOUT_FILENO); execOuter(pcmd); &#125;&#125; 11. 其他一些初始化, 错误处理等代码, 我就不再介绍, 可以直接看代码, 代码中有注释, 很容易看懂 12. 完整代码访问 github 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411/************************************************************************ &gt; File Name: init.c &gt; Author: mbinary &gt; Mail: zhuheqin1@gmail.com &gt; Blog: https://mbinary.github.io &gt; Created Time: 2018-04-15 11:18 &gt; Function: implemented some shell cmds and features; including: cmds: pwd,ls, cd ,cat, env, export , unset, features:$ \ | &lt;&gt;&gt;&gt; ; &amp; " ' quote handle \t redundent blank ************************************************************************/#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;malloc.h&gt;#define MAX_CMD_LENGTH 255#define MAX_PATH_LENGTH 255#define MAX_BUF_SIZE 4096#define MAX_ARG_NUM 50#define MAX_VAR_NUM 50#define MAX_CMD_NUM 10#define MAX_VAR_LENGTH 500#define FORK_ERROR 2#define EXEC_ERROR 3struct cmd&#123; struct cmd * next; int begin,end; // pos in cmdStr int argc; char lredir,rredir; ////0:no redirect 1 &lt;,&gt; ; 2 &gt;&gt; char toFile[MAX_PATH_LENGTH],fromFile[MAX_PATH_LENGTH]; // redirect file path char *args[MAX_ARG_NUM]; char bgExec; //failExec&#125;;struct cmd cmdinfo[MAX_CMD_NUM];char cmdStr[MAX_CMD_LENGTH]; int cmdNum,varNum;char envVar[MAX_VAR_NUM][MAX_PATH_LENGTH];void Error(int );void debug(struct cmd*);void init(struct cmd*);void setIO(struct cmd*,int ,int );int getInput();int parseCmds(int);int handleVar(struct cmd *,int);int getItem(char *,char *,int);int parseArgs();int execInner(struct cmd*);int execOuter(struct cmd*);int main()&#123; while (1)&#123; cmdNum = varNum = 0; printf("# "); fflush(stdin); int n = getInput(); if(n&lt;=0)continue; parseCmds(n); if(parseArgs()&lt;0)continue; for(int i=0;i&lt;cmdNum;++i)&#123; struct cmd *pcmd=cmdinfo+i, * tmp; //debug(pcmd); //pcmd = reverse(pcmd); int status = execInner(pcmd); if(status==1)&#123; /*notice!!! Use child proc to execute outer cmd, bacause exec funcs won't return when successfully execed. */ pid_t pid = fork(); if(pid==0)execOuter(pcmd); else if(pid&lt;0)Error(FORK_ERROR); if(!pcmd-&gt;bgExec)wait(NULL); //background exec /* free malloced piep-cmd-node, and the first one is static , no need to free; */ pcmd=pcmd-&gt;next; while(pcmd)&#123; tmp = pcmd-&gt;next; free(pcmd); pcmd=tmp; &#125; &#125; &#125; &#125; return 0; &#125;/* funcs implementation */void init(struct cmd *pcmd)&#123; pcmd-&gt;bgExec=0; pcmd-&gt;argc=0; pcmd-&gt;lredir=pcmd-&gt;rredir=0; pcmd-&gt;next = NULL; pcmd-&gt;begin=pcmd-&gt;end=-1; /* // notice!!! Avoid using resudent args */ for(int i=0;i&lt;MAX_ARG_NUM;++i)pcmd-&gt;args[i]=NULL; &#125;void Error(int n)&#123; switch(n)&#123; case FORK_ERROR:printf("fork error\n");break; case EXEC_ERROR:printf("exec error\n");break;truetruedefault:printf("Error, exit ...\n"); &#125; exit(1);&#125;int getInput()&#123; /* multi line input */ int pCmdStr=0,cur; char newline = 1; while(newline)&#123; cur = MAX_CMD_LENGTH-pCmdStr; if(cur&lt;=0)&#123; printf("[Error]: You cmdStr is too long to exec.\n"); return -1;// return -1 if cmdStr size is bigger than LENGTH &#125; fgets(cmdStr+pCmdStr,cur,stdin); newline = 0; while(1)&#123; if(cmdStr[pCmdStr]=='\\'&amp;&amp;cmdStr[pCmdStr+1]=='\n')&#123; newline=1; cmdStr[pCmdStr++]='\0'; break; &#125; else if(cmdStr[pCmdStr]=='\n')&#123; break; &#125; ++pCmdStr; &#125; &#125; return pCmdStr;&#125;int parseCmds(int n)&#123; /* clean the cmdStr and get pos of each cmd in the cmdStr (OoO) */ char beginCmd=0; struct cmd * head; // use head cmd to mark background. for( int i=0;i&lt;=n;++i)&#123; switch(cmdStr[i])&#123; case '&amp;':&#123; if(cmdStr[i+1]=='\n'||cmdStr[i+1]==';')&#123; cmdStr[i]=' '; head-&gt;bgExec=1; &#125; &#125;truetruetruecase '\t':cmdStr[i]=' ';break; case ';':&#123;//including ';' a new cmdStr beginCmd = 0; cmdStr[i]='\0'; cmdinfo[cmdNum++].end=i; break; &#125; case '\n':&#123; cmdStr[i]='\0'; cmdinfo[cmdNum++].end =i; return 0; &#125; case ' ':break; default:if(!beginCmd)&#123; beginCmd=1; head = cmdinfo+cmdNum; cmdinfo[cmdNum].begin = i; &#125; &#125; &#125;&#125;int getItem(char *dst,char*src, int p)&#123; /* get redirect file path from the cmdStr */ int ct=0; while(src[++p]==' '); if(src[p]=='\n')return -1; //no file char c; while(c=dst[ct]=src[p])&#123; if(c==' '||c=='|'||c=='&lt;'||c=='&gt;'||c=='\n')break; ++ct,++p; &#125; dst[ct]='\0'; return p-1;&#125;int handleVar(struct cmd *pcmd,int n)&#123; char * arg = pcmd-&gt;args[n]; int p_arg=0,p_var=0; while(arg[p_arg])&#123; if((arg[p_arg]=='$')&amp;&amp;(arg[p_arg-1]!='\\'))&#123; if(arg[p_arg+1]=='&#123;')p_arg+=2; else p_arg+=1; char *tmp=&amp;envVar[varNum][p_var]; int ct=0; while(tmp[ct]=arg[p_arg])&#123; if(tmp[ct]=='&#125;')&#123; ++p_arg; break; &#125; if(tmp[ct]==' '||tmp[ct]=='\n'||tmp[ct]=='\0')break; ++ct,++p_arg; &#125; tmp[ct]='\0'; tmp = getenv(tmp); for(int i=0;envVar[varNum][p_var++]=tmp[i++];); p_var-=1; //necessary &#125; else envVar[varNum][p_var++]=arg[p_arg++]; &#125; envVar[varNum][p_var]='\0'; pcmd-&gt;args[n] = envVar[varNum++]; return 0;&#125;int parseArgs()&#123; /* get args of each cmd and create cmd-node seperated by pipe */ char beginItem=0,beginQuote=0,beginDoubleQuote=0,hasVar=0,c;trueint begin,end;truestruct cmd* pcmd; for(int p=0;p&lt;cmdNum;++p)&#123;truetrueif(beginQuote||beginItem||beginDoubleQuote)&#123;truetruetruereturn -1; // wrong cmdStrtruetrue&#125; pcmd=&amp;cmdinfo[p]; begin = pcmd-&gt;begin,end = pcmd-&gt;end; init(pcmd);// initalize for(int i=begin;i&lt;end;++i)&#123; c = cmdStr[i];truetruetrueif((c=='\"')&amp;&amp;(cmdStr[i-1]!='\\'&amp;&amp;(!beginQuote)))&#123;truetruetruetrueif(beginDoubleQuote)&#123;truetruetruetruetruecmdStr[i]=beginDoubleQuote=beginItem=0; if(hasVar)&#123; hasVar=0; handleVar(pcmd,pcmd-&gt;argc-1); //note that is argc-1, not argc &#125; &#125;else&#123;truetruetruetruetruebeginDoubleQuote=1;truetruetruetruetruepcmd-&gt;args[pcmd-&gt;argc++]=cmdStr+i+1;truetruetruetrue&#125; continue;truetruetrue&#125;else if(beginDoubleQuote)&#123; if((c=='$') &amp;&amp;(cmdStr[i-1]!='\\')&amp;&amp;(!hasVar))hasVar=1; continue; &#125; if((c=='\'')&amp;&amp;(cmdStr[i-1]!='\\'))&#123; if(beginQuote)&#123;truetruetruetruetruecmdStr[i]=beginQuote=beginItem=0; &#125;else&#123; beginQuote=1; pcmd-&gt;args[pcmd-&gt;argc++]=cmdStr+i+1; &#125; continue; &#125;else if(beginQuote) continue; if(c=='&lt;'||c=='&gt;'||c=='|')&#123; if(beginItem)beginItem=0; cmdStr[i]='\0'; &#125; if(c=='&lt;')&#123; if(cmdStr[i+1]=='&lt;')&#123; pcmd-&gt;lredir+=2; //&lt;&lt; cmdStr[i+1]=' '; &#125;else&#123; pcmd-&gt;lredir+=1; //&lt; &#125; int tmp = getItem(pcmd-&gt;fromFile,cmdStr,i); if(tmp&gt;0)i = tmp; &#125;else if(c=='&gt;')&#123; if(cmdStr[i+1]=='&gt;')&#123; pcmd-&gt;rredir+=2; //&gt;&gt; cmdStr[i+1]=' '; &#125;else&#123; pcmd-&gt;rredir+=1; //&gt; &#125; int tmp = getItem(pcmd-&gt;toFile,cmdStr,i); if(tmp&gt;0)i = tmp; &#125;else if (c=='|')&#123; /*when encountering pipe | , create new cmd node chained after the fommer one */ pcmd-&gt;end = i; pcmd-&gt;next = (struct cmd*)malloc(sizeof(struct cmd)); pcmd = pcmd-&gt;next; init(pcmd); &#125;else if(c==' '||c=='\0')&#123; if(beginItem)&#123; beginItem=0; cmdStr[i]='\0'; &#125; &#125;else&#123; if(pcmd-&gt;begin==-1)pcmd-&gt;begin=i; if(!beginItem)&#123; beginItem=1; if((c=='$') &amp;&amp;(cmdStr[i-1]!='\\')&amp;&amp;(!hasVar))hasVar=1; pcmd-&gt;args[pcmd-&gt;argc++]=cmdStr+i; &#125; &#125; if(hasVar)&#123; hasVar=0; handleVar(pcmd,pcmd-&gt;argc-1); //note that is argc-1, not argc &#125; &#125; pcmd-&gt;end=end; //printf("%dfrom:%s %dto:%s\n",pcmd-&gt;lredir,pcmd-&gt;fromFile,pcmd-&gt;rredir,pcmd-&gt;toFile); &#125;&#125;int execInner(struct cmd* pcmd)&#123; /*if inner cmd, &#123;exec, return 0&#125; else return 1 */ if (!pcmd-&gt;args[0]) return 0; if (strcmp(pcmd-&gt;args[0], "cd") == 0) &#123; struct stat st; if (pcmd-&gt;args[1])&#123; stat(pcmd-&gt;args[1],&amp;st); if (S_ISDIR(st.st_mode)) chdir(pcmd-&gt;args[1]); else&#123; printf("[Error]: cd '%s': No such directory\n",pcmd-&gt;args[1]); return -1; &#125; &#125; return 0; &#125; if (strcmp(pcmd-&gt;args[0], "pwd") == 0) &#123; printf("%s\n",getcwd(pcmd-&gt;args[1] , MAX_PATH_LENGTH)); return 0; &#125; if (strcmp(pcmd-&gt;args[0], "unset") == 0) &#123; for(int i=1;i&lt;pcmd-&gt;argc;++i)unsetenv(pcmd-&gt;args[i]); return 0; &#125; if (strcmp(pcmd-&gt;args[0], "export") == 0) &#123; for(int i=1;i&lt;pcmd-&gt;argc;++i)&#123; //putenv(pcmd-&gt;args[i]); char *val,*p; for(p = pcmd-&gt;args[i];*p!='=';++p); *p='\0'; val = p+1; setenv(pcmd-&gt;args[i],val,1); &#125; return 0; &#125; if (strcmp(pcmd-&gt;args[0], "exit") == 0) exit(0); return 1;&#125; void setIO(struct cmd *pcmd,int rfd,int wfd)&#123; /* settle file redirect */ if(pcmd-&gt;rredir&gt;0)&#123; // &gt;, &gt;&gt; int flag ; if(pcmd-&gt;rredir==1)flag=O_WRONLY|O_TRUNC|O_CREAT; // &gt; note: trunc is necessary!!! else flag=O_WRONLY|O_APPEND|O_CREAT; //&gt;&gt; int wport = open(pcmd-&gt;toFile,flag); dup2(wport,STDOUT_FILENO); close(wport); &#125; if(pcmd-&gt;lredir&gt;0)&#123; //&lt;, &lt;&lt; int rport = open(pcmd-&gt;fromFile,O_RDONLY); dup2(rport,STDIN_FILENO); close(rport); &#125; /* pipe */ if(rfd!=STDIN_FILENO)&#123; dup2(rfd,STDIN_FILENO); close(rfd); &#125; if(wfd!=STDOUT_FILENO)&#123; dup2(wfd,STDOUT_FILENO); close(wfd); &#125;&#125; int execOuter(struct cmd * pcmd)&#123; if(!pcmd-&gt;next)&#123; setIO(pcmd,STDIN_FILENO,STDOUT_FILENO); execvp(pcmd-&gt;args[0],pcmd-&gt;args); &#125; int fd[2]; pipe(fd); pid_t pid = fork(); if(pid&lt;0)&#123; Error(FORK_ERROR); &#125;else if (pid==0)&#123; close(fd[0]); setIO(pcmd,STDIN_FILENO,fd[1]); execvp(pcmd-&gt;args[0],pcmd-&gt;args); Error(EXEC_ERROR); &#125;else&#123; wait(NULL); pcmd = pcmd-&gt;next; //notice close(fd[1]); setIO(pcmd,fd[0],STDOUT_FILENO); execOuter(pcmd); &#125;&#125;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『现代操作系统』死锁]]></title>
    <url>%2Fdeadlock.html</url>
    <content type="text"><![CDATA[死锁定义 死锁建模—资源分配图 处理死锁 鸵鸟算法 检测并恢复 死锁检测 死锁恢复 利用抢占 利用回滚 杀死进程 死锁避免 资源轨迹图 安全区域与不安全区域 银行家算法 死锁预防 死锁条件 破坏互斥条件 破坏占有和等待条件 破坏不可抢占条件 破坏环路等待条件 类型: 资源死锁, 通信死锁 etc 根据 拥有资源的进程抢占而不产生副作用 可抢占资源 preemptable resource 不可抢占资源 non 使用资源的顺序: 请求 -&gt; 使用 -&gt; 释放 死锁定义如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的时间,那么,该进程集合是死锁的 死锁建模—资源分配图圆形表示进程, 方形表示资源, 进程 -&gt; 资源 表示请求, 进程 &lt;- 资源, 表示占有 处理死锁 鸵鸟算法忽略该问题 检测并恢复检测死锁并恢复 死锁检测 死锁恢复 利用抢占选择挂起某个进程, 取决于哪一个进程拥有比较容易收回的资源 利用回滚周期性地保存 检查点(checkpoint), 检查点应包括存储映像,资源状态(资源分给了哪些进程). 由于检查点不覆盖, 逐渐累积可能会占大量储存 杀死进程可以杀死环类的进程, 如果不行继续, 也可以杀死环外的进程(以释放环类进程需要的资源), 杀死的进程应该满足: 重新运行不会带来副作用, 比如编译进程可以, 但是数据库更新进程不行 死锁避免在分配资源时避免发生死锁 资源轨迹图 安全区域与不安全区域横坐标是A进程执行代码过程, 纵坐标是B进程执行代码的过程, 阴影部分需要使用相应资源. 在单cpu上, 虚线轨迹, 只能是向上或向右延伸. 阴影部分表明两个进程都使用了一个资源, 互斥规则决定不可能进入阴影区域. . 而在图中的虚线轨迹, 目前还有机会不形成死锁, 称为安全区域. 可以发现, 只要轨迹进入了I5,I6,I1,I2,围成的区域, 就一定会形成死锁, 这就是不安全区域 银行家算法Dijkstra提出, banker’s algorithm基本思路就是 每次满足一个进程的资源 请求前, 检测是否会造成死锁, 如果造成,就不满足其请求,否则满足.(死锁检测算法可以利用上文中的) 缺点: 很多进程在运行前是不知道其需要资源的最大值,而且进程数不断变化,原本的资源也可能突然间不可用(如磁带机可能会坏掉), 所以缺乏实用价值 , 极少有系统使用 死锁预防 死锁条件 互斥 占有和请求 不可抢占 环路等待针对死锁条件,由于是必要条件, 所以破坏其中一个就可以预防死锁的发生. 破坏互斥条件可以用虚拟技术使资源不被一个进程所独占, 如打印机的假脱机技术(spooling),还有一个思路: 避免分配那些不是绝对必要的资源,尽量做到尽可能少的进程可以真正请求资源 破坏占有和等待条件一种实现方法: 规定所有进程在开始执行前请求所需的全部资源缺点和银行家算法一样, 很多进程直到运行时才知道所需多少资源.另一种方案是当一个进程请求资源时,先释放其当前占有的所有资源 破坏不可抢占条件比如打印机假脱机技术, 但是不是所有资源都可以类似的虚拟化, 比如数据库的记录或者操作系统中的表都必须被锁定 破坏环路等待条件给资源编号, 进程只能按编号的顺序(升序)请求. 这样资源分配图不会出现环,.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信用卡持卡人风险预测]]></title>
    <url>%2Frisk-predict.html</url>
    <content type="text"><![CDATA[题目 介绍 目标 要求 提示 知识点 分析与解答 模型选择 读取数据 非数值特征处理 拟合预测 保存数据 总结与反思 代码 参考资料 参加实验楼的楼赛21期,关于机器学习的, 我以前没怎么接触过,所以是临时在网上查找资料解答的. 如果有一些错误或者是不完善的地方,欢迎指出. 题目 介绍题目提供一个来自某银行的真实数据集，数据集前 10 行预览如下： 其中： 第 1～6 列为客户近期历史账单信息。 第 7 列为该客户年龄。 第 8 列为该客户性别。（Female, Male） 第 9 列为该客户教育程度。（Graduate School, University, High School, Others) 第 10 列为该客户婚姻状况。（Married, Single, Others） 第 11 列为客户持卡风险状况 。（LOW, HIGH） 此外： 训练数据集 credit_risk_train.csv 总共有 20000 条数据。 测试数据集 credit_risk_test.csv 总共有 5000 条数据。 下载： 12wget http://labfile.oss.aliyuncs.com/courses/1109/credit_risk_train.csvwget http://labfile.oss.aliyuncs.com/courses/1109/credit_risk_test.csv 目标你需要使用训练数据集构建机器学习分类预测模型，并针对测试数据集进行预测，准确率 \displaystyle \geq 0.8≥0.8 即为合格。 要求 提交时，请将预测结果按测试数据集中每条数据的排列顺序，以单列数据的形式存入 credit_risk_pred.csv 数据文件中，列名为 RISK。 需要将 credit_risk_pred.csv 放置于 /home/shiyanlou/Code 路径下方。 credit_risk_pred.csv 数据文件仅存在 RISK 列，示例如下： 提示 你可能会用到 scikit-learn 提供的分类预测模型。 你可能会用到 Pandas 对数据进行预处理。 完成本题目可以自由使用第三方模块，在线环境 /home/shiyanlou/anaconda3/bin/python 路径下有 scikit-learn, pandas 等常用模块。 知识点 机器学习分类预测 分析与解答 模型选择首先要选出合适的模型, 最开始随便试了 SGDClassifier,LogisticRegression等模型, 都没有达到0.8的准确度然后上网查找,根据这张图选择了 svm 支持向量机模型1from sklearn.svm import SVC as MODEL 读取数据可以用 pandas 读取 csv 数据, 并进行一些预处理, 并分好训练数据集与测试数据集12345678910111213import pandas as pddef getData(): data = pd.read_csv(trainfile) test = pd.read_csv(testfile) #names = cols) #.replace(to_replace ='"',value = np.nan) data = label(data) test = label(test) x_train,y_train =data.iloc[:,:-1].as_matrix(), data.iloc[:,-1].as_matrix() x_test = test.iloc[:,:].as_matrix() y_test=None return x_train,y_train, x_test,y_test 非数值特征处理有些特征是非数值的, 需要进行编码, 比如 gender education 等, 编码有很多方式, 比如 onehotkey, 由于这里是字符串类型的, 可以用 labelencoder , 它可以将一个特征下的值集合一次编码为 0,1,2… 要想解码, 保存最后的预测结果. 我设置了一个全局变量 converetor , 来保存这个 encoder 1234567891011121314from sklearn.preprocessing import LabelEncoder as LEconvertor = None # result convertordef label(data): global convertor for col in data.columns: if data[col].dtype == 'object': le = LE() if col=='RISK': convertor = le le.fit(data[col]) data[col]= le.transform(data[col]) return data 拟合预测fit 函数拟合时, 不同的模型时间不一样, 适应的场景,数据也不一样, 准确度也不一样123456def predict(model=MODEL): predictor = model() x_train,y_train,x_test,_ = getData() predictor.fit(x_train,y_train) res = predictor.predict(x_test) save(res) 保存数据用 pandas 保存为 csv1234def save(result): result = convertor.inverse_transform(result) dataframe = pd.DataFrame(&#123;'RISK':result&#125;) dataframe.to_csv('credit_risk_pred.csv',index=False,sep=',') 总结与反思时间匆忙, 这个代码比较粗略,还有很多可以考虑的地方, 比如检验一些值的方差是否过大, 特征缩放, 评估模型的准确度等等 最后, 感觉这个网站,这个比赛挺有趣的, 如果想注册, 可以点这里, 邀请了:) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546import pandas as pdfrom sklearn.preprocessing import LabelEncoder as LEfrom sklearn.svm import SVC as MODELtrainfile = 'credit_risk_train.csv'testfile = 'credit_risk_test.csv'convertor = None # result convertordef label(data): global convertor for col in data.columns: if data[col].dtype == 'object': le = LE() if col=='RISK': convertor = le le.fit(data[col]) data[col]= le.transform(data[col]) return datadef getData(): data = pd.read_csv(trainfile) test = pd.read_csv(testfile) #names = cols) #.replace(to_replace ='"',value = np.nan) data = label(data) test = label(test) x_train,y_train =data.iloc[:,:-1].as_matrix(), data.iloc[:,-1].as_matrix() x_test = test.iloc[:,:].as_matrix() y_test=None return x_train,y_train, x_test,y_testdef save(result): result = convertor.inverse_transform(result) dataframe = pd.DataFrame(&#123;'RISK':result&#125;) dataframe.to_csv('credit_risk_pred.csv',index=False,sep=',')def predict(model=MODEL): predictor = model() x_train,y_train,x_test,_ = getData() predictor.fit(x_train,y_train) res = predictor.predict(x_test) save(res)if __name__=='__main__': predict() 参考资料[1] : 数据预处理中的数据编码问题 | python 数据挖掘思考笔记 (2)[2] : sklearn.preprocessing.LabelEncode[3] : sklearn: 选择正确的模型[4] : 利用 Scikit Learn 的 Python 数据预处理实战指南]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『小仓鼠漫画』熬夜的危害与防护]]></title>
    <url>%2Fcomics-about-staying-up.html</url>
    <content type="text"><![CDATA[以前做的两张图片, 2333]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『CTF』网络信息安全攻防实验室之基础关 writeup]]></title>
    <url>%2Fctf-basic.html</url>
    <content type="text"><![CDATA[使用的工具 chrome python3 md5 在线工具（可搜索到）) 第 1 题Key 在哪里？分值：100 过关地址http://lab1.xseclab.com/base1_4a4d993ed7bd7d467b27af52d2aaa800/index.php key 就在这里中，你能找到他吗？ 解答ctrl+U 查看源码即得 key：jflsjklejflkdsjfklds第 2 题再加密一次你就得到 key 啦~ 分值：150 加密之后的数据为 xrlvf23xfqwsxsqf 解答 最开始想到异或，但是不对呀，与谁异或，后来想到 rot13, caser 密码的一种，即 26 个字母移位即可 key23ksdjfkfds 第 3 题猜猜这是经过了多少次加密？ 分值：200 加密后的字符串为：Vm0wd2QyUXlVWGxWV0d4V1YwZ 太长省略一万字 解答结尾有=, 猜测很可能是 base64 编码，所以用 python 一直解码即可 s=&#39;....&#39;.encode(&#39;utf8&#39;) keyjkljdkl232jkljkdl2389 第 4 题据说 MD5 加密很安全，真的是么？ 分值：200 e0960851294d7b2253978ba858e24633 解答这题是 md5 解密由于 MD5 是信息摘要，不可逆的，要想解密，只有通过先生成明文与其 md5 的数据库，来查找搜索在线工具，md5,地址：http://www.cmd5.com/ 还要知道的是 MD5 有限对应无限的字符串，存在不同的字符串有相同的 md5 keybighp 第 5 题种族歧视 分值：300 小明同学今天访问了一个网站，竟然不允许中国人访问！太坑了，于是小明同学决心一定要进去一探究竟！通关地址： http://lab1.xseclab.com/base1_0ef337f3afbe42d5619d7a36c19c20ab/index.php 解答这个猜测是限制了请求头的语言所以用 python 的 requests 库构造请求头 注意到 requests 库的自身编码为：r.encoding = ‘ISO-8859-1’要转换为 utf8 才能显示中文，下一题也是这样 key*(TU687jksf6&amp;* 第六题HAHA 浏览器 分值：200 据说信息安全小组最近出了一款新的浏览器，叫 HAHA 浏览器，有些题目必须通过 HAHA 浏览器才能答对。小明同学坚决不要装 HAHA 浏览器，怕有后门，但是如何才能过这个需要安装 HAHA 浏览器才能过的题目呢？ 通关地址：http://lab1.xseclab.com/base6_6082c908819e105c378eb93b6631c4d3/index.php 只允许使用 HAHA 浏览器，请下载 HAHA 浏览器访问！ 解答同上，构造 User-Agent keymeiyouHAHAiiulanqi 第七题key 究竟在哪里呢？ 分值：200 上一次小明同学轻松找到了 key，感觉这么简单的题目多无聊，于是有了找 key 的加强版，那么 key 这次会藏在哪里呢？ 通关地址：http://lab1.xseclab.com/base7_eb68bd2f0d762faf70c89799b3c1cc52/index.php Key 就在这里，猜猜这里是哪里呢？(Web 找 key 加强版） 解答源码没有信息，很自然的想到请求返回的内容 keykjh%#$#%FDjjj 第 8 题key 又找不到了 分值：350 小明这次可真找不到 key 去哪里了，你能帮他找到 key 吗？ 通关地址 解答点击进入是一个链接 点击 search 那个链接，显示 发现网址是 http://hacklist.sinaapp.com/base8_0abd63aa54bef0464289d6a42465f354/index_no_key.php 说明重定向了 所以防止重定向就可以了，用 python requests 库，在 get 时传递参数allow_redirects=False url 为http://lab1.xseclab.com/base8_0abd63aa54bef0464289d6a42465f354/search_key.php get 两次就发现了 keyohHTTP302dd 第 9 题冒充登陆用户 分值：200 小明来到一个网站，还是想要 key，但是却怎么逗登陆不了，你能帮他登陆吗？ 通关地址：http://lab1.xseclab.com/base9_ab629d778e3a29540dfd60f2e548a5eb/index.php 解答网页中的内容为：您还没有登陆呢！ F12发现 cookie 有一个键值是 Login=0, 猜测只要传递 Login=1 即可 key`` 第 10 题比较数字大小 分值：100 只要比服务器上的数字大就可以了！ 通关地址：http://lab1.xseclab.com/base10_0b4e4866096913ac9c3a2272dde27215/index.php 解答进入网页，查看源码，有 maxlength 限制，这是网页限制的，用 python 就不用担心这些，直接 post 一个很的数 key768HKyu678567&amp;*&amp;K 第 11 题本地的诱惑 分值：200 小明扫描了他心爱的小红的电脑，发现开放了一个 80 端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的 80 端口到底隐藏着什么秘密 (key)？ 通关地址：http://lab1.xseclab.com/base11_0f8e35973f552d69a02047694c27a8c9/index.php 网页内容：必须从本地访问 解答查看源码，emmmmmmmmmmm 如果正常来做的话，是在请求头传入’x-forwarded-for’:’127.0.0.1’ 来识别为本地 ip key^&amp;*(UIHKJjkadshf 第 12 题就不让你访问 分值：150 小明设计了一个网站，因为总是遭受黑客攻击后台，所以这次他把后台放到了一个无论是什么人都找不到的地方…. 可最后还是被黑客找到了，并被放置了一个黑页，写到：find you ,no more than 3 secs! 通关地址：http://lab1.xseclab.com/base12_44f0d8a96eed21afdc4823a0bf1a316b/index.php 网页内容：I am index.php , I am not the admin page ,key is in admin page. 解答这里用到爬虫协议这是介绍 Robots 协议（也称为爬虫协议、机器人协议等）的全称是 “网络爬虫排除标准”（Robots Exclusion Protocol），网站通过 Robots 协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。 进入http://lab1.xseclab.com/base12_44f0d8a96eed21afdc4823a0bf1a316b/robots.txt 可以看到123456789User-agent: *Disallow: /Crawl-delay: 120Disallow: /9fb97531fe95594603aff7e794ab2f5f/Sitemap: http://www.hackinglab.sinaapp.com/sitemap.xml disallow 就是爬虫不能搜索的 进入那个地址 http://lab1.xseclab.com/base12_44f0d8a96eed21afdc4823a0bf1a316b/9fb97531fe95594603aff7e794ab2f5 提示不是 login 页面，再进入 login.php 页面http://lab1.xseclab.com/base12_44f0d8a96eed21afdc4823a0bf1a316b/9fb97531fe95594603aff7e794ab2f5/login.php就找到了 keyUIJ%%IOOqweqwsdf 总结哇，用来整个下午的时间，挺有趣的]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『WEB』用 python 发送 csdn 博客]]></title>
    <url>%2Fsend-blog-automatically.html</url>
    <content type="text"><![CDATA[我有个基于 github pages 的博客, 又在很多其他网站上发博客。比如 csdn . 为了避免重复操作，想用程序实现自动发博客。今天上午就试了一下 csdn 这个网站 方法一 — 用 api 来发送博客进入开发者文档 可以看到 注册开发者，使用文档中的方式获得 access_token 来获取授权 然后就可以 post 了，比如这篇文章, 方法二 — 模拟登陆用 python 来模拟登陆，为了简单，可以使用 cookies 来利用浏览器的会话 cookie 登陆 保存 cookie用 chrome, 点击进入发文章的页面，可以看到 保存下来，等会在 python 脚本中使用 抓包寻找 post, 提交内容的网址，我最开始一直以为是https://mp.csdn.net/mdeditor/, 返回的页面是成功的但是刷新博客页面，并没有发表文章， 后来用 fiddler 抓包才找到正确的网址 元数据然后构造发表的文章的元数据，在 fiddler 中可以发现 就是这样的一个字典， 123456789101112data = &#123;"title":"do you know my name?", "markdowncontent":'# emm', "content": '''&lt;h1&gt;hello, world~&lt;/h1&gt;''', "categories":"默认分类", "channel":33, "tags":"python", 'type':'original', "artideedittype":1, "private":0, "status":0 #"id": 修改已有文章 &#125; 那个 channel 就是要发表到的栏目，可以在网页右键审查元素发现各个值的含义 发表最后就可以发送了，第一次失败 显示的是 unicode,, 应该打印 json 就行，然后知道是标题不能为空，添加标题就可以了 尝试了多次，都成功了，这是返回的 json 由于不支持 markdown, 我又下载安装了 python markdown 模块，可以转成 html,这样使用12345678910111213141516def md2html(s): exts = ['markdown.extensions.extra', 'markdown.extensions.codehilite','markdown.extensions.tables','markdown.extensions.toc'] html = ''' &lt;html lang="zh-cn"&gt; &lt;head&gt; &lt;meta content="text/html; charset=utf-8" http-equiv="content-type" /&gt; &lt;/head&gt; &lt;body&gt; &#123;mdstr&#125; &lt;/body&gt; &lt;/html&gt; ''' mdstr = markdown.markdown(s,extensions=exts) return html.format(mdstr = mdstr) 这是 html 结果 当我沉浸在成功的喜悦中时，准备发一系列文章时，才知道 csdn 有限制 QAQ本来还想发表这些文章的 那以后发吧 以下配置文件，最新完整的代码见 github, 欢迎 star, 如果想添加其他功能，欢迎 fork &amp; PR123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#coding: utf-8'''************************************************************************ &gt; File Name: config.py &gt; Author: mbinary &gt; Mail: zhuheqin1@gmail.com &gt; Created Time: Fri 06 Apr 2018 11:06:16 AM DST ************************************************************************'''# python 变量 配置参数# 两者二选一# CSDN_AUTH_DATA 在 使用 api 需要在 http://open.csdn.net/wiki/api/ 注册开发者，得到 cliet_id 和 client_secret# CSDN_COOKIE 在发博客页面获取 cookie,CSDN_AUTH_DATA = &#123;'client_id' :'1100668', 'client_secret': '********************************', 'grant_type': 'password', 'username': 'marvellousbinary', 'password': 'R**********' &#125;CSDN_COOKIE = ''' '''# markdown 语法，需 pip install markdownMDON = True# xdefault configurationDEFAULT_DATA = &#123; "title":"do you know my name?", "content": '''&lt;h1&gt;hello, world~&lt;/h1&gt;''', "categories":"默认分类", "channel":33, "tags":"python,tag2", &#125;'''channel 各个值的含义1: 移动开发2: 云计算大数据3: 研发管理6: 数据库12: 运维14: 前端15: 架构16: 编程语言28: 人工智能29: 物联网30: 游戏开发31: 后端32: 安全33: 程序人生34: 区块链35: 音视频开发36: 资讯37: 计算机理论与基础''']]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用机械键盘的室友]]></title>
    <url>%2Fthe-roommate-that-uses-mechanical-keyboard.html</url>
    <content type="text"><![CDATA[刚上完跆拳道课回来，已是晚上十点多。哇，明天还要交 cod 作业，可是我一章的内容还没有看呢！赶紧抓起书看。流水线，让我思考思考…忽然耳边传来噼里啪啦的声音… 哦，是室友的机械键盘。哎，自己太不专心了，怎么能受这点声音的影响呢，想想爱因斯坦能在嘈杂的环境思考. 再专心一点。流水线有三种冒险，数据冒险…噼里啪啦，怎么又听到这声音了？?? 先来介绍一下我们寝室吧：键盘室友，游戏室友，室友 A, 我 一直以来键盘室友敲机械键盘的声音打扰着我，我以前跟他提过两次，他都是在当时小声地敲来解决. 我以前认为是自己太不专心了，尽量地忍耐，可是还是不行。我后来知道，有的时候我们能在有声音的环境下不受打扰, 那是因为声音是白噪声, 即功率密度变化不大的声音.如下雨的声音,在这种环境下,还更不易被打扰.然而敲机械键盘的声音不是。我最开始还去网上搜索，看看别人的看法，寻找认同感。后来想想，我不需要认同感，这个机械键盘的声音确实影响着我，这就是事实依据。 有的人觉得应该体谅室友 我体谅了的. 可是在看书，看论文的时候确实受不了这种声音，我也不喜欢戴耳塞。而且我感觉键盘室友不怎么有礼貌，说了几次，还是那样子。比如游戏室友，爱打王者荣耀，可是每次他都戴着耳机，而且很少发出声音。我很感谢他，也很尊重他，比如他起的很晚，那么我早上吃零食就会到寝室外面吃，以免影响他睡觉。而键盘室友最先起床，有时我们都在睡觉，他用剃须刀刮胡子… 我以前想过，学校分宿舍确实无作为，不考虑后果。我认为分宿舍应该以生活习惯来分，比如打呼噜的在一个寝室，比如夜猫子在一个寝室，比如敲机械键盘的在一个寝室… 不要提什么随便分寝室，互相包容，体验不同地区的文化… 有些矛盾是不可调和的（比如有同学常在空间抱怨自己打呼噜的室友，几近失眠，还寻找解决失眠的办法）, 而且有时调和会花很多精力，甚至在室友间产生隔阂… 有的人觉得你为什么偏要在宿舍呢？ 我在寝室学习有以下原因 我们寝室比较安静，大家都愿意打造一个学习的环境. 可以说有时比图书馆还安静，图书馆人来人往，移动凳子，.. 我喜欢在私人空间，比较自在，图书馆公共空间人太多，感觉不舒服 我有难言之隐（可以克服） 有的人觉得程序员就应该用大屏幕，机械键盘，这样效率高。 首先在寝室这种共享的私人空间, 我想大家的共识应该是在尽量不影响其他人的情况下，各自保持自己喜欢的状态, 当然，这个共识也可以由你来定义，只要遵守平等,对集体有利的原则。绝对的平等很难达到，也不应该达到，毕竟人本来就是各不相同的。对集体有利是必须的，不然你觉得大家都吵闹，虽然平等了，但是对大家都不好。 对于这个共识，不影响其他人，可操作性的定义一方面可以是在声音上 — 不产生噪音。噪声的定义大家可以查查。首先是人耳可听见的，如果声音较小，我们也不会认为是噪声，可是机械键盘的声音确实有点大。还有就是无规则，频率，音色都在变化。如果你敲机械键盘是一个频率，一个音色，音量虽然可听但是较小，那也不会被认为是噪音；或者说你敲出旋律来也行。 然后再说说效率。我也是程序员，我没用过，以下只是分析与猜测。可能机械键盘的效率是高，我以前想买过，但是想到那声音，就怕打扰到其他人。机械键盘携带不方便，键盘室友也只能在寝室看看大屏幕，敲敲机械键盘，他不会去图书馆敲的. 还有大屏幕这点，我觉得，在阅读时，我眼睛能大致看完整个屏幕，不用调整头部姿势，只需视线移动，就能浏览整个屏幕，这样效率才高。而大屏幕，屏幕很大，有些地方你还需要移动头部才能看到（当然这点可以通过调整离屏幕的垂直距离避免，但是大多数人不会坐得太远）.其实我曾经也想提高打字速度，然后就去学了 dvorak, 后来发现，作为程序员，而不是打字员，我脑袋想代码的速度，已经赶不上我打代码的速度了。 快到 0 点了，内容还是没看多少，说实话，此时很焦急，愤怒。我想过去买一个机械键盘来敲给他听. 但是后来想想，太小肚鸡肠了，不能这样睚眦必报，而且不一定能解决问题. 还是直面问题，协商解决 第二天，我召集整个寝室，提出大家对谁有什么不满都可以说出来，不要藏在心里，说出来大家想办法解决. 在谈到他的机械键盘的问题，我说”你的键盘影响 到我了，我建议你在某个时间段用，或者用电脑自带的键盘”. 然而他没回答，而是说”你打呼噜也影响到我了，你怎么不想办法解决，比如吃药”, 我知道打呼噜很令人难受，我以前坐火车，也被旁边的大妈打呼噜吵得睡不着，我那时就问所有室友，我打呼噜影响到他们没，要不要想方法解决，当时只有游戏室友说影响到了，不过他说他可以戴耳塞. 然后我就没放在心上了。这次键盘室友气鼓鼓的提到这个，那好，我下周就去看医生。 后来，键盘室友的键盘声照常响起. 我还有什么话可说呢？我懂得衰亡民族之所以没落…, 我无 fuck 说 后记游戏室友对我说的 老朱啊，你对寝室是什么似乎还缺少一种认识。那就是我们四个人住在一起既不是因为缘分也不是因为什么感情，纯粹是因为我们无力负担一个人独居所需要的花费，所以不得不四个人共享这十几平方米。这十几个平方是给我们提供最基本的生活保障而不是别的什么。所以要求大家在这个环境下做事都合乎自己的心意是一种低效率的行为。最好的办法是不要长时间与其他人挤在这十几个平方内。否则矛盾是自然会激发的。 每个人都有自己的生活习惯，有自己的性格，与别的人长时间挤在狭小的空间内而又没有感情作为依托，再大的包容也会被消磨，暂时的解决了一个矛盾可能又会有另一个矛盾，从根源上远离才是最好的办法。 其实除了这点，我们在其他方面都是很好的，跟那个键盘室友关系还不错. 我就是不想把关系闹僵，才提出来大家讨论，协商。可是他的态度确是那样，所以，我以后尽量去外面学习了，但是晚上 10 到 0 点这个时间段，只有忍受了。]]></content>
      <categories>
        <category>生活</category>
        <category>人际交往</category>
      </categories>
      <tags>
        <tag>机械键盘</tag>
        <tag>人际交往</tag>
        <tag>室友</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP-BOMB-LAB]]></title>
    <url>%2Fcsapp-bomb-lab-report.html</url>
    <content type="text"><![CDATA[这是 2016 版的 bomb 下载得到 bomb.tar 文件，解压后只有 bomb 二进制文件，以及一个 bomb.c 文件，bomb.c 没有对应的头文件。所有思路只有是反汇编 bomb, 分析汇编代码。 这里用到两个非常强大的工具 objdump,gdb objdump 用来反汇编的，-d 参数得到 x86 汇编，-M 参数还可以选择不同的汇编形式，比如 -M 8086 得到 8086 汇编，详细内容可以 man objdump. gdb 是强大的 GNU DEBUGGER 用法如下 1234567891011121314151617(gdb) b（breakpoint）: 用法：b 函数名 ：对此函数进行中断 ；b 文件名：行号；(gdb) run：启动程序，运行至程序的断点或者结束；(gdb) l(list): 用法：l funcname，制定函数的源码(gdb) s(step): 进入函数，逐语句运行；(gdb) n(next): 不进入函数，逐过程运行；(gdb) c（continue）：继续运行，跳至下一个断点；(gdb) p（print）：打印显示变量值；(gdb) set variable=value, 为变量赋值；(gdb) kill：终止调试的程序；(gdb) h（help）：列出 gdb 详细命令帮助列表；(gdb) clear filename.c:30：清除 30 行处的断点；(gdb) info break：显示断点信息；(gdb) delete 断点编号：断点编号是 info break 后显示出来的；(gdb) bt（backtrace）：回溯到段出错的位置；(gdb) frame 帧号：帧号是 bt 命令产生的堆栈针；(gdb) q：退出；(gdb) x(examine)：查看内存中的值等 // 详细内容在 gdb 中输入 help x 查看 下面开始拆 &#x1f4a3; 之旅 general观察汇编代码，可以看到有 main, phase1—6, 等，重点看这几个函数，从 main 开始，结合 bomb.c, 可以明白程序的控制流，每个阶段用 phase 函数判断输入是否正确，不正确就 boon, 结束程序 phase1来到 phase1, 第一行准备栈帧，第二行就是将地址存入 $esi, 这是一个字符串的地址，可以猜测下面 string_not_equal 就是比较这个字符串与输入字符串是否相等的函数.（最开始我还去分析了这个函数的汇编代码，确实是那样，先比较长度，然后逐一比较。所以找到这个地址0x402400存储的字符串就行了，在 asm 文件中搜索，没有，所以要在程序运行时才可以到达这个虚拟地址，未来 address space 的堆中。这时就要用到强大的 gdb 了， 切换到 bomb 文件夹，依次输入123gdb(gdb) file bomb(gdb) x /s 0x402400 # x(examine) s 参数是 string 的意思 即得Border relations with Canada have never been better. phase2 所以答案是 1 2 4 8 16 32 phase3123456789101112131415161718192021222324252627282930313233343536370000000000400f43 &lt;phase_3&gt;: 400f43: sub $0x18,%rsp 400f47: lea 0xc(%rsp),%rcx 400f4c: lea 0x8(%rsp),%rdx 400f51: mov $0x4025cf,%esi # 又是一个字符串，可以用 gdb 查看，得到`"%d %d", 格式化字符串，说明输入两个数字 400f56: mov $0x0,%eax 400f5b: callq 400bf0 &lt;__isoc99_sscanf@plt&gt; # 输入 400f60: cmp $0x1,%eax # 判断输入成功 400f63: jg 400f6a &lt;phase_3+0x27&gt; 400f65: callq 40143a &lt;explode_bomb&gt; 400f6a: cmpl $0x7,0x8(%rsp) # 第一个参数是否小于等于 7, 大于则 boom 400f6f: ja 400fad &lt;phase_3+0x6a&gt; 400f71: mov 0x8(%rsp),%eax 400f75: jmpq *0x402470(,%rax,8) # 以下是 switch, 根据 rax, 即第一个输入的参数跳转 400f7c: mov $0xcf,%eax # 由此容易得到答案，比如这里是 rax=0 时，则 另一个参数为 0xcf = 207 400f81: jmp 400fbe &lt;phase_3+0x7b&gt; 400f83: mov $0x2c3,%eax 400f88: jmp 400fbe &lt;phase_3+0x7b&gt; 400f8a: mov $0x100,%eax 400f8f: jmp 400fbe &lt;phase_3+0x7b&gt; 400f91: mov $0x185,%eax 400f96: jmp 400fbe &lt;phase_3+0x7b&gt; 400f98: mov $0xce,%eax 400f9d: jmp 400fbe &lt;phase_3+0x7b&gt; 400f9f: mov $0x2aa,%eax 400fa4: jmp 400fbe &lt;phase_3+0x7b&gt; 400fa6: mov $0x147,%eax 400fab: jmp 400fbe &lt;phase_3+0x7b&gt; 400fad: callq 40143a &lt;explode_bomb&gt; 400fb2: mov $0x0,%eax 400fb7: jmp 400fbe &lt;phase_3+0x7b&gt; 400fb9: mov $0x137,%eax 400fbe: cmp 0xc(%rsp),%eax 400fc2: je 400fc9 &lt;phase_3+0x86&gt; 400fc4: callq 40143a &lt;explode_bomb&gt; 400fc9: add $0x18,%rsp 400fcd: retq swith 跳转表%rax 跳转地址 0xc(%rsp)0 0x0000000000400f7c 0xcf 2071 0x0000000000400fb9 0x137 3112 0x0000000000400f83 0x2c3 7073 0x0000000000400f8a 0x100 2564 0x0000000000400f91 0x185 3895 0x0000000000400f98 0xce 2066 0x0000000000400f9f 0x2aa 6827 0x0000000000400fa6 0x147 327所以结果为0 207 … phase41234567891011121314151617181920212223000000000040100c &lt;phase_4&gt;: 40100c: sub $0x18,%rsp 401010: lea 0xc(%rsp),%rcx 401015: lea 0x8(%rsp),%rdx 40101a: mov $0x4025cf,%esi #同样，gdb 中 x /s 知道输入两个数字 40101f: mov $0x0,%eax 401024: callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 401029: cmp $0x2,%eax # 判断是否输入两个数 40102c: jne 401035 &lt;phase_4+0x29&gt; 40102e: cmpl $0xe,0x8(%rsp) # 判断每个数是否≤14 , 大于则 boom 401033: jbe 40103a &lt;phase_4+0x2e&gt; # 跳转 401035: callq 40143a &lt;explode_bomb&gt; 40103a: mov $0xe,%edx # 构造 func4 的参数 (phase4 调用的） 40103f: mov $0x0,%esi # 构造 func4 的参数 401044: mov 0x8(%rsp),%edi # 构造 func4 的参数 401048: callq 400fce &lt;func4&gt; 40104d: test %eax,%eax # 测试，func4 返回 0, 若不，则 boom 40104f: jne 401058 &lt;phase_4+0x4c&gt; 401051: cmpl $0x0,0xc(%rsp) 401056: je 40105d &lt;phase_4+0x51&gt; 401058: callq 40143a &lt;explode_bomb&gt; 40105d: add $0x18,%rsp 401061: retq 将 func4 转换为 c 语言，并用 0—14 测试，这点很难，需要翻译汇编语言，花很多时间，得熟悉汇编代码才行 123456789101112131415161718192021222324252627282930313233343536373839 int func4(int a, int b, int c)&#123; int result; result = c; result = result - b; int tmp = result; tmp = (unsigned)tmp &gt;&gt; 31; result = result + tmp; result = result / 2; tmp = result + b; if(tmp &gt; a) &#123; c = tmp - 1; result = func4(a, b, c); return (2 * result); &#125; result = 0; if(tmp &lt; a) &#123; b = tmp + 1; result = func4(a, b, c); return (1 + 2 * result); &#125; return result;&#125;// 测试从 0~14 范围内满足条件的值int main()&#123; for(int input = 0; input &lt; 15; ++input) &#123; int result = func4(input, 0, 14); if(result == 0) &#123; printf("input = %d, func4 = %d\n", input, result); &#125; &#125; return 0;&#125; 得到可行解因此 phase4 可能结果为：0 01 03 07 0 phase5嗯，加油，还有两关了。(●ˇˇ●)12345678910111213141516171819202122232425262728293031323334353637383940410000000000401062 &lt;phase_5&gt;: 401062: push %rbx 401063: sub $0x20,%rsp 401067: mov %rdi,%rbx 40106a: mov %fs:0x28,%rax 401071: 401073: mov %rax,0x18(%rsp) 401078: xor %eax,%eax 40107a: callq 40131b &lt;string_length&gt; 40107f: cmp $0x6,%eax # 说明输入是六个字符 401082: je 4010d2 &lt;phase_5+0x70&gt; 401084: callq 40143a &lt;explode_bomb&gt; 401089: jmp 4010d2 &lt;phase_5+0x70&gt; 40108b: movzbl (%rbx,%rax,1),%ecx # 从栈帧中取出各个字符，记为 x 40108f: mov %cl,(%rsp) 401092: mov (%rsp),%rdx 401096: and $0xf,%edx # y=0xf &amp; x, 即将一个 byte 的高 4 位置 0 401099: movzbl 0x4024b0(%rdx),%edx # 用 gdb 查看 x /s 0x4024b0 得到字符串&quot;maduiersnfotvbyl&quot;, 所以这一行是以 y 作为偏移量，取字符数组的第几个字符 4010a0: mov %dl,0x10(%rsp,%rax,1) # 将取得的存于栈帧中 // 后面用 string_not_equl 比较 4010a4: add $0x1,%rax 4010a8: cmp $0x6,%rax # 循环 6 次 4010ac: jne 40108b &lt;phase_5+0x29&gt; 4010ae: movb $0x0,0x16(%rsp) 4010b3: mov $0x40245e,%esi # 这是要比较的字符串，同样用 gdb 查看得到 &quot;flyers&quot; 4010b8: lea 0x10(%rsp),%rdi 4010bd: callq 401338 &lt;strings_not_equal&gt; 4010c2: test %eax,%eax 4010c4: je 4010d9 &lt;phase_5+0x77&gt; 4010c6: callq 40143a &lt;explode_bomb&gt; 4010cb: nopl 0x0(%rax,%rax,1) 4010d0: jmp 4010d9 &lt;phase_5+0x77&gt; 4010d2: mov $0x0,%eax 4010d7: jmp 40108b &lt;phase_5+0x29&gt; 4010d9: mov 0x18(%rsp),%rax 4010de: xor %fs:0x28,%rax 4010e5: 4010e7: je 4010ee &lt;phase_5+0x8c&gt; 4010e9: callq 400b30 &lt;__stack_chk_fail@plt&gt; 4010ee: add $0x20,%rsp 4010f2: pop %rbx 4010f3: retq 解释在上面，反向得到需要的输入的思路是：对 flyers 的每个字符，得到在字符数组中的 index, 也就是输入的字符的后 4 位 bit, 而键盘输入一般是字母，所以很可能有两种可能，字符 byte 的高四位为0100或0110, 而且可以发现刚好这是大写字母 / 小写字母开始的前一个 ascii, 所以用 python 算一下即得”ionefg”或是”IONEFG” phase6 phase6 很难了，这真的要熟练汇编语言，我翻译到前面，知道输入的是六个不相同的数字，而且≤6 ,所以可以试全排列了, 后面的实在看不下去了，在网上找到这份解析这是链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129 (gdb) disas phase_6Dump of assembler code for function phase_6: 0x00000000004010f4 &lt;+0&gt;: push %r14 将被调用者保存寄存器压入栈 0x00000000004010f6 &lt;+2&gt;: push %r13 0x00000000004010f8 &lt;+4&gt;: push %r12 0x00000000004010fa &lt;+6&gt;: push %rbp 0x00000000004010fb &lt;+7&gt;: push %rbx %rsp = 0x7fffffffe2c0 0x00000000004010fc &lt;+8&gt;: sub $0x50,%rsp 分配栈空间 %rsp = 0x7fffffffe270 0x0000000000401100 &lt;+12&gt;: mov %rsp,%r13 0x0000000000401103 &lt;+15&gt;: mov %rsp,%rsi 0x0000000000401106 &lt;+18&gt;: callq 0x40145c &lt;read_six_numbers&gt; 读入 6 个值，保存至从 %rsi 开始的地址 0x000000000040110b &lt;+23&gt;: mov %rsp,%r14 0x000000000040110e &lt;+26&gt;: mov $0x0,%r12d %r12 置 0, 并且 %r13 %r14 %rbp 均和 %rsp 指向相同地址 0x7fffffffe270 0x0000000000401114 &lt;+32&gt;: mov %r13,%rbp 0x0000000000401117 &lt;+35&gt;: mov 0x0(%r13),%eax 将第 %r13 指向的输入数复制到 %eax 0x000000000040111b &lt;+39&gt;: sub $0x1,%eax 将输入数减 1 0x000000000040111e &lt;+42&gt;: cmp $0x5,%eax 判断输入数是否小于等于 6, 因为上一步中减 1 操作 0x0000000000401121 &lt;+45&gt;: jbe 0x401128 &lt;phase_6+52&gt; 若大于 6, 则调用 explode_bomb 0x0000000000401123 &lt;+47&gt;: callq 0x40143a &lt;explode_bomb&gt;========================================================================================================================================================= 0x0000000000401128 &lt;+52&gt;: add $0x1,%r12d 将 %r12 加 1 0x000000000040112c &lt;+56&gt;: cmp $0x6,%r12d 判断 %r12 是否等于 6 0x0000000000401130 &lt;+60&gt;: je 0x401153 &lt;phase_6+95&gt; 若等于 6, 跳转，否则继续执行 0x0000000000401132 &lt;+62&gt;: mov %r12d,%ebx 将 %r12 复制到 %ebx 0x0000000000401135 &lt;+65&gt;: movslq %ebx,%rax 将 %ebx 符号位扩展复制到 %rax 0x0000000000401138 &lt;+68&gt;: mov (%rsp,%rax,4),%eax 将第 %ebx 输入数复制到 %eax 0x000000000040113b &lt;+71&gt;: cmp %eax,0x0(%rbp) 比较 %r13 指向的输入数和 第 %ebx 输入数 是否相等 0x000000000040113e &lt;+74&gt;: jne 0x401145 &lt;phase_6+81&gt; 如果相等，则调用 explode_bomb 0x0000000000401140 &lt;+76&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000401145 &lt;+81&gt;: add $0x1,%ebx 将 %ebx 加 1 0x0000000000401148 &lt;+84&gt;: cmp $0x5,%ebx 判断 %ebx 是否小于等于 5 0x000000000040114b &lt;+87&gt;: jle 0x401135 &lt;phase_6+65&gt; 若小于等于，跳转，否则继续执行；该循环判断 %r13 指向的数据和其后输入数不相等 0x000000000040114d &lt;+89&gt;: add $0x4,%r13 将 %r13 指向下一个输入数，该循环判断所有的输入数全部不相等 0x0000000000401151 &lt;+93&gt;: jmp 0x401114 &lt;phase_6+32&gt;========================================================================================================================================================= 0x0000000000401153 &lt;+95&gt;: lea 0x18(%rsp),%rsi 将 %rsi 指向栈中跳过读入数据位置作为结束标记，并且 %r14 仍和 %rsp 指向同一个位置 0x0000000000401158 &lt;+100&gt;: mov %r14,%rax 将 %r14 复制到 %rax 0x000000000040115b &lt;+103&gt;: mov $0x7,%ecx 0x0000000000401160 &lt;+108&gt;: mov %ecx,%edx 将立即数 0x7 复制到 %edx 0x0000000000401162 &lt;+110&gt;: sub (%rax),%edx 立即数 7 减去 %r14 指向的数据 0x0000000000401164 &lt;+112&gt;: mov %edx,(%rax) 将 7 减的结果存回 %r14 执行的内存单元 0x0000000000401166 &lt;+114&gt;: add $0x4,%rax %rax 指向下一个输入数 0x000000000040116a &lt;+118&gt;: cmp %rsi,%rax 比较是否达到输入数组的末尾， 0x000000000040116d &lt;+121&gt;: jne 0x401160 &lt;phase_6+108&gt; 该循环使用立即数 7 减去每个输入数据========================================================================================================================================================== 0x000000000040116f &lt;+123&gt;: mov $0x0,%esi 将 %rsi 置 0 0x0000000000401174 &lt;+128&gt;: jmp 0x401197 &lt;phase_6+163&gt; 0x0000000000401176 &lt;+130&gt;: mov 0x8(%rdx),%rdx 将 0x8(%rdx) 指向内存单元的内容复制到 %rdx, 指向链表下一个元素 0x000000000040117a &lt;+134&gt;: add $0x1,%eax 将 %eax 加 1 0x000000000040117d &lt;+137&gt;: cmp %ecx,%eax 比较 %ecx 和 %eax 是否相等 0x000000000040117f &lt;+139&gt;: jne 0x401176 &lt;phase_6+130&gt; 不相等，继续遍历链表，最终 %rdx 指向链表的第 %ecx 个节点 0x0000000000401181 &lt;+141&gt;: jmp 0x401188 &lt;phase_6+148&gt; 0x0000000000401183 &lt;+143&gt;: mov $0x6032d0,%edx 重置链表首地址 0x0000000000401188 &lt;+148&gt;: mov %rdx,0x20(%rsp,%rsi,2) 0x000000000040118d &lt;+153&gt;: add $0x4,%rsi 0x0000000000401191 &lt;+157&gt;: cmp $0x18,%rsi 0x0000000000401195 &lt;+161&gt;: je 0x4011ab &lt;phase_6+183&gt; 0x0000000000401197 &lt;+163&gt;: mov (%rsp,%rsi,1),%ecx 将 (%rsp + %rsi) 指向的数据复制到 %ecx 0x000000000040119a &lt;+166&gt;: cmp $0x1,%ecx 比较 %ecx 是否小于等于 1 0x000000000040119d &lt;+169&gt;: jle 0x401183 &lt;phase_6+143&gt; 若小于等于，跳转，否则继续执行，等于 1, %edx 直接指向链表首地址 0x000000000040119f &lt;+171&gt;: mov $0x1,%eax 将 %eax 置 1 0x00000000004011a4 &lt;+176&gt;: mov $0x6032d0,%edx 将 %rdx 指向内存单元 0x6032d0 0x00000000004011a9 &lt;+181&gt;: jmp 0x401176 &lt;phase_6+130&gt; 跳转；该循环根据输入数将链表中对应的第输入数个节点的地址复制到 0x20(%rsp) 开始的栈中 ========================================================================================================================================================== 0x00000000004011ab &lt;+183&gt;: mov 0x20(%rsp),%rbx 将 0x20(%rsp) 的链表节点地址复制到 %rbx 0x00000000004011b0 &lt;+188&gt;: lea 0x28(%rsp),%rax 将 %rax 指向栈中下一个链表节点的地址 0x00000000004011b5 &lt;+193&gt;: lea 0x50(%rsp),%rsi 将 %rsi 指向保存的链表节点地址的末尾 0x00000000004011ba &lt;+198&gt;: mov %rbx,%rcx 0x00000000004011bd &lt;+201&gt;: mov (%rax),%rdx 0x00000000004011c0 &lt;+204&gt;: mov %rdx,0x8(%rcx) 将栈中指向的后一个节点的地址复制到前一个节点的地址位置 0x00000000004011c4 &lt;+208&gt;: add $0x8,%rax 移动到下一个节点 0x00000000004011c8 &lt;+212&gt;: cmp %rsi,%rax 判断 6 个节点是否遍历完毕 0x00000000004011cb &lt;+215&gt;: je 0x4011d2 &lt;phase_6+222&gt; 0x00000000004011cd &lt;+217&gt;: mov %rdx,%rcx 0x00000000004011d0 &lt;+220&gt;: jmp 0x4011bd &lt;phase_6+201&gt; 0x00000000004011d2 &lt;+222&gt;: movq $0x0,0x8(%rdx) 该循环按照 7 减去输入数据的索引重新调整链表========================================================================================================================================================== 0x00000000004011da &lt;+230&gt;: mov $0x5,%ebp 0x00000000004011df &lt;+235&gt;: mov 0x8(%rbx),%rax 将 %rax 指向 %rbx 下一个链表节点 0x00000000004011e3 &lt;+239&gt;: mov (%rax),%eax 0x00000000004011e5 &lt;+241&gt;: cmp %eax,(%rbx) 比较链表节点中第一个字段值的大小，如果前一个节点值大于后一个节点值，跳转 0x00000000004011e7 &lt;+243&gt;: jge 0x4011ee &lt;phase_6+250&gt; 0x00000000004011e9 &lt;+245&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x00000000004011ee &lt;+250&gt;: mov 0x8(%rbx),%rbx 将 %rbx 向后移动，指向栈中下一个链表节点的地址 0x00000000004011f2 &lt;+254&gt;: sub $0x1,%ebp 判断循环是否结束，该循环判断栈中重新调整后的链表节点是否按照降序排列 0x00000000004011f5 &lt;+257&gt;: jne 0x4011df &lt;phase_6+235&gt; 0x00000000004011f7 &lt;+259&gt;: add $0x50,%rsp 0x00000000004011fb &lt;+263&gt;: pop %rbx 0x00000000004011fc &lt;+264&gt;: pop %rbp 0x00000000004011fd &lt;+265&gt;: pop %r12 0x00000000004011ff &lt;+267&gt;: pop %r13 0x0000000000401201 &lt;+269&gt;: pop %r14 0x0000000000401203 &lt;+271&gt;: retqEnd of assembler dump.(gdb) disas read_six_numbers%rsi 存储调用者 phase_2 栈帧的局部变量开始地址%rdx = %rsi + 0%rcx = %rsi + 4%r8 = %rsi + 8%r9 = %rsi + 12(%rsp) = %rsi + 168(%rsp) = %rsi + 20Dump of assembler code for function read_six_numbers: 0x000000000040145c &lt;+0&gt;: sub $0x18,%rsp 0x0000000000401460 &lt;+4&gt;: mov %rsi,%rdx 0x0000000000401463 &lt;+7&gt;: lea 0x4(%rsi),%rcx 0x0000000000401467 &lt;+11&gt;: lea 0x14(%rsi),%rax 0x000000000040146b &lt;+15&gt;: mov %rax,0x8(%rsp) 0x0000000000401470 &lt;+20&gt;: lea 0x10(%rsi),%rax 0x0000000000401474 &lt;+24&gt;: mov %rax,(%rsp) 0x0000000000401478 &lt;+28&gt;: lea 0xc(%rsi),%r9 0x000000000040147c &lt;+32&gt;: lea 0x8(%rsi),%r8 0x0000000000401480 &lt;+36&gt;: mov $0x4025c3,%esi 0x0000000000401485 &lt;+41&gt;: mov $0x0,%eax 0x000000000040148a &lt;+46&gt;: callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt; 0x000000000040148f &lt;+51&gt;: cmp $0x5,%eax 0x0000000000401492 &lt;+54&gt;: jg 0x401499 &lt;read_six_numbers+61&gt; 0x0000000000401494 &lt;+56&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000401499 &lt;+61&gt;: add $0x18,%rsp 0x000000000040149d &lt;+65&gt;: retq %rbp %rbx %r12~%15 被调用者保存寄存器%r10 %r11 调用者保存寄存器%rdi %rsi %rdx %rcx %r8 %r9 依次保存输入数 1~6 假设输入数据为 4 3 2 1 6 5 猜测 0x6032d8 为链表首地址，链表中每个节点占用 12 个 Byte, 前 8 字节保存两个 4 字 Byte 的整型数，剩余的 4Byte 存放下个节点地址 GDB 查看使用 7 减去对应的输入后的数据(gdb) p /x $rsp$1 = 0x7fffffffe270(gdb) x/6dw 0x7fffffffe2700x7fffffffe270: 3 4 5 60x7fffffffe280: 1 2 重新调整链表前的链表的结构(gdb) x/24xw 0x006032d00x6032d0 : 0x0000014c 0x00000001 0x006032e0 0x000000000x6032e0 : 0x000000a8 0x00000002 0x006032f0 0x000000000x6032f0 : 0x0000039c 0x00000003 0x00603300 0x000000000x603300 : 0x000002b3 0x00000004 0x00603310 0x000000000x603310 : 0x000001dd 0x00000005 0x00603320 0x000000000x603320 : 0x000001bb 0x00000006 0x00000000 0x00000000 保存在栈中链表节点信息(gdb) x/6xg 0x7fffffffe2900x7fffffffe290: 0x00000000006032f0 0x00000000006033000x7fffffffe2a0: 0x0000000000603310 0x00000000006033200x7fffffffe2b0: 0x00000000006032d0 0x00000000006032e0 按照 7 减去对应的输入后重新调整链表后的链表结构，索引顺序为 3 4 5 6 1 2(gdb) x/24xw 0x006032d00x6032d0 : 0x0000014c 0x00000001 0x006032e0 0x000000000x6032e0 : 0x000000a8 0x00000002 0x00000000 0x000000000x6032f0 : 0x0000039c 0x00000003 0x00603300 0x000000000x603300 : 0x000002b3 0x00000004 0x00603310 0x000000000x603310 : 0x000001dd 0x00000005 0x00603320 0x000000000x603320 : 0x000001bb 0x00000006 0x006032d0 0x00000000 破解思路：将链表中每个节点按照前 4 字节降序排序3 4 5 6 1 2因为在前面使用 7 减去对应的值，所以破解密码4 3 2 1 6 5 final 啊，终于拆除💣了，╰(°▽°)╯等等，还漏了什么`? 在 asm 中，可以看到还有 secret_phase 这个函数，可是这个函数的调用是有技巧的，追踪发现是在 phase_defused 中调用的，同样，查看字符串，发现比较了”DrEvil”, 以及一个格式串”%d %d %s”, 可能是 phase3,phase4 的数字加上 DrEvil 输入. 可是最后我试了很多次都没有试出来。后来发现是最后才出现，那是第七关，我以为是在输入 DrEvil 就出现。而且试了是在第四关后 方法二，gdb 中设置断点’b phase_defused’, 然后jump secret_phase 最后得到答案是 22 summary通过这个 lab, 学到了 gdb,objdump 等工具的使用，对汇编语言更熟悉，对函数调用中栈帧的变化，动态变量的理解更加深刻不得不佩服国外教学的质量，以及这个 lab 的有趣与实用]]></content>
      <categories>
        <category>程序设计</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习与遗忘]]></title>
    <url>%2Flearning-and-forgetting.html</url>
    <content type="text"><![CDATA[今天一位17级同学问我一道电磁学c的题,作为一个认真修过电磁A的人,我竟然完全不知怎么解答,大多数知识都忘了.这引起了我的思考 为何遗忘?任何东西都是会遗忘的,准确的说是后天习得的知识,技能,再准确一些,遗忘的量,时间与学习的过程,复习巩固的次数,时间有关. (插播一些东西: 我不能随便下断言,我没有足够的证据,这只是我的经验???. 前段时间看了&lt;&lt;批判性思维&gt;&gt; , 我深知下断言,得结论是要谨慎,有理有据的. 我作为信息传播者, 这是我给自己的要求. 当然, 这样我说之前应该思考,一些不确定的言论不能表达. 我需要谨言慎行. 而作为信息接收者的我, 在听到别人的各种断言与结论时, 我不能要求别人给出充足的论据, 他们的目的或许不是来说服我. 我要做的是思考, 持怀疑态度, 检验论据.) 我到时学电磁A学得很认真, 虽然物理是我的弱项,但是最终得了优秀. 而因为我的兴趣不在那, 且对电磁学的优先级低, 这之后再没有接触电磁学相关的内容(当然不是说的日常的电池电压). 遗忘是我的大脑本应遵循的规律. 遗忘了什么?(还记得什么?)电磁学大部分细节我都忘了,一道简单的求电压我也忘了.我记得的东西有: 电磁学可以分为电学,磁学,两部分内容研究模式都一样,基本载荷粒子,然后是对应的力学作用定律,然后研究能量.最后电学,磁学通过麦克斯韦方程统一起来,揭示了电磁学的本质,以及电磁波,就是光. 不是电磁学一个特例:又如化学原理,我当时也是认认真真学了,还刷了一些题,可现在能记起来的东西也很少,化学需要记的东西很多,我记得有元素周期律,包括原子的各种特性:电负性,电离能,电子排布… 当然,最开始是根据构造原理,能量最低原理,hond规则死记硬背的,后面学了轨道理论,通过波函数,波函数的耦合,分子轨道的能量等原理层面来学习.原子学清楚了,后面可以聚类地学习原子,分子参与的反应,对应的性质 这遗忘了很多.看来记得的就是原理与思想了.有研究认为(这里应该放个参考链接),不是遗忘了,而是没有适合的刺激来找回那些记忆深处的知识,从生物角度来说就是突触的建立与消失.不过,既然再次回想起那些’遗忘’的知识也会花很多精力,可以认为是不属于我了,是无用的信息了. 那么,学习的意义?这里的隐含的推理是, 我学习是有目的的,遗忘了知识是与我目的相背的,为了达到我的目的,我该怎么学,我该学什么,学习的意义是什么? 我学习肯定是有目的的,比如看各种专业书学习技能提高自己的能力, 学各种技术的目的好像是为了装x?算是一个方面吧,但还有各种技术带来的乐趣,便利… 比如,我不喜欢物理,也是因为学校强迫学习,而当前看来没有多大价值的东西(至少对我来说), 要知道,大物就是写实验报告,算算不确定度. 这些没有多大价值的东西(这个价值由我来评估,而不是打好数理基础,以后必然有用这种不可证的断言),也就没有学习的动力,也不会反反复复记忆,训练,而是混过水过,所以我现在已经忘光了:D . 有的同学会说,哈,我认认真真做了大物,收获很大. 我不去探究对他到底收获大不大,我想说的是同一事物对不同人的价值本来就不一样. 我天天写实验报告, 不如用来练几行代码,我是计算机学院的, 不是物理学院的. 当然,我们也得考虑性价比,就如同当主席,当清洁工都能创造价值,但是价值有大小之分. 两家一远一近的超市,价格质量相差不大时,我买东西肯定会去近的一家, 为了节省时间. 所以,我以后学习应该学习更加基础,原理的东西,而不是各种花哨的,包装了的,需要大量记忆的知识. 比如爬虫, 这很有趣,但是只是学学基本的抓取资源,不如用专门的软件来的快与好,而不是花大量时间来记住那些api的调用. 我有时也会陷入这种短期的,低思考密度的诱惑陷阱,比如做做oj的题,比如看了很多语言的hello world 部分,比如沉浸于过去的成果,比如看一篇篇低质量的博文… 真正有用的知识的获得从来不是一个轻松的过程,必须经过重重思考与记忆. 还要考虑用到的频率. 我们或许都觉得学很多的知识,为将来做充足的准备. 可是这样真的有用吗? 就如splay tree 的原理, 访问了的结点,很可能下次还会访问, 或者与其临近的结点被访问.这是概率统计上的原理. 所以现在很少用到的知识,以后也很少用用到,现在需要学吗? 当然,有的人说,如果真被用到,又来不及了. 我认为,快速学习也是一种能力,而且,当你遗忘得差不多时,同样要花大量精力来温习. 这就是’惰性学习’了. 我不是说不学绝大多数知识,而是学习的方向,应该是原理与思想,而不是各种条条框框,各种包装. 毕竟,遗忘了我当时辛辛苦苦学的知识,挺难受的,我以后要把时间,精力用对,用好才行.]]></content>
      <categories>
        <category>阅读与思考</category>
      </categories>
      <tags>
        <tag>惰性学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 年，20 岁，大二寒假总结与感悟]]></title>
    <url>%2F20-years-old-summary.html</url>
    <content type="text"><![CDATA[今天成了奔三的人了，20 岁了。标题写这么多也是方便以后查看，刚好新年伊始，我的生日也在初六。既可以做个年终总结，再展望未来，也可以做个年龄变化的标志。如今我到了弱冠之年，古人行冠礼，给自己取字。我认为，人要克制自己的欲望，要戒除一些东西。 一戒杀生，二戒偷盗，三戒淫，四戒妄语，五戒饮酒，六戒着香华，七戒坐卧高广大床，八戒非时食。 八关戒斋的简称。佛教指在家男女信徒于一日一夜中所受的八种斋戒法。据《法苑珠林》卷一 0 六为： 1、无杀意，慈念众生，不得残害蠕动之类； 2、无贪意，思念布施，却悭贪意； 3、无淫意，不念房室，修治梵行，不为邪欲； 4、无妄语，思念至诚，言不为诈，心口相应； 5、不饮酒，不醉迷，去入逸意； 6、无求安，不著华（花）香，不傅脂粉，不为歌舞倡乐； 7、无求安，不卧好床，卑床草席，捐除睡卧，思念经道； 8、奉法，时过中不食。这八种中，前七为戒，后一为斋，总称八戒 嗯，字八戒好了，大家可以叫我朱八戒。 等等，上面这段划去 我名字有个勤字，可是有时也非常懒呢，我还差得远呢，要一直努力才行，取个“懋”字，懋（音同貌），勤奋努力的意思。还有，学习的目标应该专一，正如 志在顶峰的人，绝不会因留恋半山腰的奇花异草而停止攀登的步伐 —- 高尔基 我时常学这学那，都感兴趣，但是杂而不精，不够专一，所以我也应该专一地学习。取个“一” 那就字懋一吧， 大家可以叫我朱懋一，以此勉励自己，一直努力，专一学习，不可懈怠。因为我想和全世界顶尖的高手在一起，做对世界有利的事呢。 下面开始总结与感悟 2017 年总结关键词应该就是计算机专业，成绩，爱情 追求爱情了。 计算机专业想起我转到计算机专业，是很偶然的。去年寒假的时候，才考虑转专业。当不知道转什么专业的时候，当时和 zml 大神聊了会，他说了计算机学院的一些好处，意思就是推荐计算机专业嘛（不过现在经常黑计院）。我以前没想过，也没接触过，在那之后才关注计算机专业，然后决定转的。在哪里看到的一段话，不知道作者了，我觉得写得很好 人只能在自己认知范围内做出选择，很多时候不是选择无能，而是根本不知道，不了解，不考虑某个选项。认知圈的扩大，才能做出不拘泥低水平竞争的选择。开放能够带来好运。你认识的每一个人，建立的每一个连接，都有可能在未来的每一个结点，向你展示另一种人生的可能。 去年 3 月份我才开始看《简明 python 教程》，时间过得真快呀！ 后来，或许是出于对这个专业的热爱，或许是自认为为了别人好，或许是觉得其他专业待遇不好，劝了一些好朋友转计算机专业。结果嘛，几乎都失败啦 ！现在想想真是狭隘与无知。一味地劝导别人，有没有想过，别人愿意转专业吗？别人喜欢这个专业吗？别人能克服变化带来的困难吗？别人的认知能被你几句话就改变吗？…… 我总是自以为是地认为对别人好而去做事，虽然都是对我重要的朋友（对于陌生人，我才不肯做费力不讨好的事），但这样会令人讨厌，事与愿违。 例如对于转专业这件事上，认知不同，反应差距很大。我当时是想转专业，我也主动地到处去搜集信息，决定转专业后我就全心投入。那时大一下还在化院，我缓修了两门课，然后自己看一些计算机书。所以以后我如果被问及转专业的事，我应该尽量客观地提供信息，选择是由他们来做，即使是亲近的人，我也最好不要极力诱导。后来我成功地引导两个学弟转计算机专业。 成绩是否感觉到科气袭来？ 这一年成绩波动挺大的，与我的学习态度，考试态度，我的未来规划相关性很大。在大一下，好好地刷了很多题，想进英才班嘛，嗯，还算好，大二刚好进了。进了英才班发现确实是所谓的 gpa 班，并无多大的不同，科大的培养是想趋同化，统一化，工厂模式化。 大二上就比较任性了。首先想到 gpa 不重要，技术最重要。然后对于不喜欢的课基本上就混过去，比如所有物理课。有些课就是考前突击（然而突击能力不行，sigh) 的。大多数课没去听课，都是自己看的。这样好坏参半，虽然很自由，有自己的节奏，但是多自己要求太低了，有些没理解的东西可能略过了，有些深刻的东西可能没体会到。主要毛病是太追求速度，太想在短时间内学习更多知识。也就是心浮气躁？嗯，得改正了。 我知道，我要为我的选择承担后果，为我自己负责。不过，学期结束，总 gpa 下降了 0.16，真是吓到我了，我开四方了，以后不敢这么猖狂了。英语 72，警醒我该花些时间在英语上了，这一年多都没怎么用心学英语呢。 爱情围观的吃瓜群众可以散开了，这里没戏 QwQ//to do 寒假总结在家里作息不规律，很难受。学习效率低，一个多月都没做多少事。我得承认我意志力还不够强，有时也抵挡不住各种诱惑，如零食等。最好的方法，还是远离诱惑源。看过一篇文章，我赞同里面的观点：意志力是需要能量的，当面对持续的诱惑，能坚持的能量就逐渐消耗。所以不要考验自己的意志力，想办法远离诱惑，利用习惯的力量（当然是形成好习惯，而不是坏习惯）。 看到爸妈整天忙于工作，有时工作到凌晨 2 点多，早上七点多又起床，很不珍惜自己地身体健康，我感到很痛心与失望，我劝导他们以身体为重，同时应该学习理财（最近看了《富爸爸，穷爸爸》，深受感触）。这一个多月来，我瘦了 3 斤左右，现在 64.6kg, 目标 60kg。我觉得在正常范围内，尽量瘦点是对身体健康有益处的。 说说今天生日我做了什么吧，上午与晚上写总结与感悟，下午和朋友 xyy 去健身房，然后又去操场跑了几圈，很充实啊。接下来去给未来 5 年，十年后的自己写邮件了，用 qqmail 吧，那个时候 tencent 应该还没有倒闭。 对了，再说说为什么写作？ 我认为写作是很好的思考方式，是对记忆的整理，对知识的运用。这里写作可以之很多形式，比如日记，总结，感受，博客等等。]]></content>
      <categories>
        <category>生活</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『WEB』从网易云音乐缓存文件得到MP3]]></title>
    <url>%2Fdecrypt-netease-music.html</url>
    <content type="text"><![CDATA[最近想获取几首好听的网易云音乐文件，但是不是会员，只有缓存文件，而且经过加工了的。以前获取过某k歌的缓存文件，直接修改后缀名就行了，但是网易云音乐不行，sigh 下面开始探索网易云音乐之旅:D 解密缓存文件 获得歌曲信息 获取歌词 lyric文件 利用API获取歌词 成果 完整代码 感想 注意 And finally 解密缓存文件在手机上的缓存文件在 netease/cloudmusic/Cache/Music1里观察可以发现，歌曲缓存文件包括两个，一个是index文件.idx!，另一个是歌曲文件，index文件和歌词文件(歌曲id命名)都是txt文件，可以直接打开，而歌曲文件.uc!打开错误。缓存文件是修改过的。如图: 进一步地，缓存文件和源文件大小一样大，所以没有经过压缩，最简单的想法是异或运算，这样最简单，加密，解密一样的操作。逐个尝试，发现每字节和0xa3异或即可，得到正确的文件，可以播放，哈哈 &#x1f603; 下面是代码，注意用bytearray修改bytes 123456with open (fileName,'rb') as f: btay = bytearray(f.read())with open(newFile,'wb') as out: for i,j in enumerate(btay): btay[i] = j ^ 0xa3 out.write(bytes(btay)) 获得歌曲信息为了给歌曲文件正确命名，我想获得歌曲题目和歌手信息。虽然.idx!索引文件包含一些属性，但是没有歌曲标题和歌手，不过重要的是musicId，这是歌曲的唯一标识。然后发现.idx! .uc!文件都是以id开头的，且歌词文件是id命名的。 可以用这个 api 来获取信息https://api.imjad.cn/cloudmusic/?type=detail&amp;id=1234132 还有另一种方法，mp3等文件格式有一些metadata (元素据)，mp3文件的 id3 tag里面就包含标题，歌手。这是wiki的介绍 然后找python模块，网上说eyeD3比较好用，但是我安装好后提示libmagic找不到，搜索问题未能解决（如果你有解决办法，请告诉我，十分感谢）， 然后用的mutagen模块，这个模块能操作很多格式的文件，这是效果 获取歌词有两种方法 lyric文件这是歌词文件内容 从这个文件中读取。 解析这个文件，由于没有统一的键,所以可以用正则表达式r&#39;(lyric|lrc|klyric|kalaokLyric|tlyric)\s*[\&#39;\&quot;]:\s*[\&#39;\&quot;]\s*\[&#39;)来检查是否有歌词内容123456789# self.hasLrcPt= re.compile(r'(lyric|lrc|klyric|kalaokLyric|tlyric)\s*[\'\"]:\s*[\'\"]\s*\[')# self.lrcKey = 'lyric|lrc|klyric|kalaokLyric|tlyric'.split('|')def noLrc(self,s): '''judge if a dict or a string has lyrics''' if isinstance(s,str): return self.hasLrcPt.search(s) is None else: return not reduce(or_,[i in s and s[i]!='' for i in self.lrcKey]) 检查到有歌词后，可以发现每句是这样的 [0:09.000]平安夜，亵渎的夜晚\n 最开始用的r&#39;\[\d+,\d+\](\(\d+,\d+\)(\w))+\n&#39;)，然而总是匹配不到，在交互模式又匹配得很精确，在这里浪费了很多时间，最后发现是\n的问题，在正则表达式中要用\\n,作为字符串在交互模式下打印出来只显示了\n， &#x1f629; ， 心累 ，改为r&#39;\[\d+:\d+\.\d+\](.*?)\\n&#39;. 利用API获取歌词利用上面的 api , 传递 lyric 参数即可 注意由于是缓存文件，有极少的音乐可能id3 tag以及 api 都没有信息，对于这些，我直接用的id命名 成果 展示 运行输出 歌词 MP3 完整代码github 感想&#x1f633; (羞涩有时看书有点没有耐心，想实践，然而如果没有掌握好知识，实践的话就会踩很多坑，甚至可能还爬不起来有些坑。 还差得远呢，还得加油哦！ 注意 有极少数的缓存文件 在 api 中没有信息, 在 id3 tag 中也没有, 这些歌曲我用的 id 来命令 最新更新都在github上, 博客很少更新, 所以使用前最好去读一下 github 的 readme And finally（学习使用异或加密 &#x1f648;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『数据结构』inc,dec,getMin,getMax 均为 O(1)]]></title>
    <url>%2Fall-one-data-structure.html</url>
    <content type="text"><![CDATA[做 leetcode 题时遇到这样一道题，挺有趣的数据结构，所以记下来：) 1. All O`one Data Structure —leetcode 432Implement a data structure supporting the following operations: Inc(Key) - Inserts a new key with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string. Dec(Key) - If Key’s value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string. GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string “”. GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string “”. Challenge: Perform all these in O(1) time complexity. 2. 想法我们知道 hashmap 插入，删除，更改是 O(1) 的，为了得到最值也是 O(1)，关键是实现一个双向链表，同时利用到增减都为单位量。下面详细解释各部分 2.1. node双向链表的结点，每个结点记录一个 val, 以及值为 val 的键的字典，val&gt;0 pre: 双向链表，指向前一结点 next：双向链表，指向后一结点 val: 关键字对应的值，可以看作频率，通过这个将不同值的关键值分组，类似分块查找， keys: 一个 dict, 用来容纳 val 相同的键值，查找插入删除都为 O(1) 2.2. 双向链表有头指针，尾指针。有一个 val=0 的结点，初始化时头尾指针指向此头结点。还有一个 dict，键为 val, 值为对应 val 的结点，以便在 O(1) 内找到结点。 如果结点中不含任何关键字，则去掉此结点。如果还存在 key, 头指针指向 val 最小的除 0 的结点（必有关键字）, 尾指针则指向最大的结点，这样 getMin,getMax 都为 O(1)。如果没有任何 key, 则只有一个不含关键字的头节点 node(0)，初始化时也是这样，则头尾指针都指向它 在增减时，需更新头尾指针（最值），可以发现，只有在增加结点或删除结点时才需更新 incTo(self,key,val): 判断 val 结点是否存在，若不，则创建此结点 使 node(val) 包含关键字 key 如果前一结点（可以保证一定存在）含此关键字，则删除此关键字 由上一步，如果删除了前一结点的关键字后，前一结点不再含任何关键字，则删除此结点 dccTo(self,key,val): 判断 val 结点是否存在，若不，则创建此结点 使 node(val) 包含关键字 key 后一结点（可以保证一定存在）一定含此关键字，删除此关键字 由上一步，如果删除了后一结点的关键字后，后一结点不再含任何关键字，则删除此结点 addNode(self,val): 注意 inc,dec 时代码不一样，但思路是一样的 1. 将结点注册到双向链表的 access_mp，既给此 dict, 增加键值对`val:node(val)` 2. 修改链连接 3. 更新头尾指针指向的结点（由于 inc,dec 改变的是单位量，所以可以直接找到前一结点或后一节点，这是 O(1) 的 delNode(self,val): 修改链连接 更新头尾指针指向的结点（由于 inc,dec 改变的是单位量，所以可以直接找到此次 dec 后的最大值或最小值，即若上次最小值是 val 的话，则新的最小值为 node(val).next，即下一节点（循环链表，如果为空时会自动指向头节点 node(0), 代码很简洁，同理可得上次最大值为 val 更新尾指针） 在 access_mp 中删除此结点 2.3. AllOne:这个结构包含一个上述的双向链表和一个 (key:val) 键值对字典，通过此字典来增减关键字的 val，同时在双向链表中找到对应结点，再找到对应的 key 3. 总结这有点像 chain_map 了，不过 python 中的 chain_map 只是简单的连接起来，方便操作多个 map(dict), 而这个数据结构通过双向链表将相同的 val 的 key 字典连接。由于增减的是单位量，所以更新时，更新最值可以通过链表在 O(1) 时间找到。所以此结构可以用在更新关键字频繁且最好是单位量的地方，而且数据量很大时，查找最值也更有效。（不然创建删除结点费时间） 4. 测试做了测试，与 hashmap 比较了一下（这里设定 hashmap 当值&lt;=0 则删除该键，然后找最大值，最小值用 O(n) 时间）测试是随机产生一些字符串，然后随机产生操作，inc,dec,getMin,getMax, 以及对应的数据（参数），默认产生 1000 个操作，然后重复 1000 次，取总时间 allOne hashMap ratio 增减区间：[1,10]增减与取最值操作的比例：1：1 2.83s 1.67s 1.69 增减区间：[1,5]增减与取最值操作的比例：1：1 4.06s 1.65s 2.44 增减区间：[1,5]增减与取最值操作的比例：1：5 1.59s 2.21s 0.72 4.1. 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from allOoneDS import AllOnefrom time import timefrom random import choice,sample,randintclass hashMap: def __init__(self): self.op = &#123;"inc":self.inc,"dec":self.dec,"getMaxKey":self.getMaxKey,"getMinKey":self.getMinKey&#125; self.mp=&#123;'':0&#125; def inc(self,key,n=1): if key in self.mp:self.mp[key]+=n else:self.mp[key]=n def dec(self,key,n=1): if key not in self.mp:return if self.mp[key]&lt;=n:del self.mp[key] else: self.mp[key]-=n def getMinKey(self): return min(list(self.mp.keys()),key=lambda key:self.mp[key]) def getMaxKey(self): return max(list(self.mp.keys()),key=lambda key:self.mp[key])op_origin = ['inc','dec','getMinKey','getMaxKey','getMinKey','getMaxKey','getMinKey','getMaxKey','getMinKey','getMaxKey','getMinKey','getMaxKey']ch=list('qwertyuiopasdfghjklzxcvbnm')keys =[ ''.join(sample(ch,i)) for j in range(10) for i in range(1,20,5)]def testCase(n=1000): ops=[] data=[] for i in range(n): p = randint(0,len(op_origin)-1) ops.append(op_origin[p]) if p&lt;2: data.append([randint(1,10)]) else:data.append([]) return ops,datadef test(repeat=1000): t1,t2=0,0 for i in range(repeat): allOne = AllOne() hsmp = hashMap() ops,data = testCase() t1-=time() for op,datum in zip(ops,data): allOne.op[op](*datum) t1+=time() t2-=time() for op,datum in zip(ops,data): hsmp.op[op](*datum) t2+=time() return t1,t2if __name__=='__main__': t1,t2= test() print(t1,t2) 5. allOne 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134class node: def __init__(self,val=None,data_mp=None,pre=None,next=None): self.val=val self.data_mp = &#123;&#125; if data_mp is None else data_mp self.pre=pre self.next=next def __lt__(self,nd): return self.val&lt;nd.val def getOne(self): if not self.data_mp: return '' else:return list(self.data_mp.items())[0][0] def __getitem__(self,key): return self.data_mp[key] def __iter__(self): return iter(self.data_mp) def __delitem__(self,key): del self.data_mp[key] def __setitem__(self,key,val): self.data_mp[key]= val def isEmpty(self): return self.data_mp==&#123;&#125; def __repr__(self): return 'node(&#123;&#125;,&#123;&#125;)'.format(self.val,self.data_mp)class doubleLinkedList: def __init__(self): self.head= self.tail = node(0) self.head.next = self.head self.head.pre = self.head self.chain_mp=&#123;0:self.head&#125; def __str__(self): li = list(self.chain_mp.values()) li = [str(i) for i in li] return 'min:&#123;&#125;, max:&#123;&#125;\n'.format(self.head.val,self.tail.val) \ + '\n'.join(li) def getMax(self): return self.tail.getOne() def getMin(self): return self.head.getOne() def addIncNode(self,val): # when adding a node,inc 1, so it's guranted that node(val-1) exists self.chain_mp[val].pre= self.chain_mp[val-1] self.chain_mp[val].next= self.chain_mp[val-1].next self.chain_mp[val-1].next.pre = self.chain_mp[val-1].next = self.chain_mp[val] def addDecNode(self,val): # when adding a node,dec 1, so it's guranted that node(val+1) exists self.chain_mp[val].next= self.chain_mp[val+1] self.chain_mp[val].pre= self.chain_mp[val+1].pre self.chain_mp[val+1].pre.next = self.chain_mp[val+1].pre = self.chain_mp[val] def addNode(self,val,dec=False): self.chain_mp[val] = node(val) if dec:self.addDecNode(val) else:self.addIncNode(val) if self.tail.val&lt;val:self.tail = self.chain_mp[val] if self.head.val&gt;val or self.head.val==0:self.head= self.chain_mp[val] def delNode(self,val): self.chain_mp[val].next.pre = self.chain_mp[val].pre self.chain_mp[val].pre.next = self.chain_mp[val].next if self.tail.val==val:self.tail = self.chain_mp[val].pre if self.head.val==val:self.head = self.chain_mp[val].next del self.chain_mp[val] def incTo(self,key,val): if val not in self.chain_mp: self.addNode(val) self.chain_mp[val][key] = val if val!=1 : # key in the pre node del self.chain_mp[val-1][key] #print(self.chain_mp[val-1]) if self.chain_mp[val-1].isEmpty(): #print('*'*20) self.delNode(val-1) def decTo(self,key,val): if val not in self.chain_mp: self.addNode(val,dec=True) # notice that the headnode(0) shouldn't add key if val!=0: self.chain_mp[val][key] = val del self.chain_mp[val+1][key] if self.chain_mp[val+1].isEmpty(): self.delNode(val+1)class AllOne: def __init__(self): """ Initialize your data structure here. """ self.op = &#123;"inc":self.inc,"dec":self.dec,"getMaxKey":self.getMaxKey,"getMinKey":self.getMinKey&#125; self.mp = &#123;&#125; self.dll = doubleLinkedList() def __str__(self): return str(self.dll) def __getitem__(self,key): return self.mp[key] def __delitem__(self,key): del self.mp[key] def __setitem__(self,key,val): self.mp[key]= val def __iter__(self): return iter(self.mp) def inc(self, key,n=1): """ Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. :type key: str :rtype: void """ if key in self: self[key]+=n else:self[key]=n for i in range(n): self.dll.incTo(key, self[key]) def dec(self, key,n=1): """ Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. :type key: str :rtype: void """ if key in self.mp: mn = min( self[key],n) for i in range(mn): self.dll.decTo(key, self[key]-i-1) if self[key] == n: del self[key] else: self[key] = self[key]-n def getMaxKey(self): """ Returns one of the keys with maximal value. :rtype: str """ return self.dll.getMax() def getMinKey(self): """ Returns one of the keys with Minimal value. :rtype: str """ return self.dll.getMin()]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[影视作品观后感]]></title>
    <url>%2Fvideo.html</url>
    <content type="text"><![CDATA[我有时会看一些动漫，电影来打发时间，以这种娱乐方式来放松。然而这只是一种被动的接收信息的形式，只是输入。想到花费了很 多时间，所有得写个观后感来记录一下，这是输出。以前也写过，但是断断续续，而且也并没坚持。现在打算都记录在这篇文章中。目录 2018-8-23 To be or not to be豆瓣9.2 故事背景：1939 年 8 月， 德国入侵波兰前不久非常好的一部喜剧, 密集的笑点, 但是自然, 不做作. 借用别人的一句话: 喜剧电影分两种：一种是刘别谦玩过的，一种是刘别谦玩 剩下的.剧情跌宕起伏, 一波三折, 成功吸引了注意力. 这部剧刻画出戏团成员的爱国, 机智与勇敢. 主角间的感情关系是奇特的三角恋, 但 却合情合理, 在大难面前, 一致对外, 以国家为重.耐人寻味处很多, 首先就是电影名 To be or not to be. 这也是主角演哈姆勒特时的台词, 也是 Sobinski 在主角丈夫 Joseph 演出时 幽会 Maria 的时机, 丈夫从最开始的以为自己演戏没有吸引力到了解了事实后的嗔怒与无奈, 在结尾处表现得淋漓尽致.然后就是伪装角色这一部分, 首先是伪装成上将 防止机密信息泄露, 本来一切顺利时, 却因为 Joseph 担心妻子而被识破, 最终击毙了 教授.剧情也顺水推舟地开始让 Joseph 伪装成教授, 在第一次访问上将时, 也很多有趣的地方, 不是直白的笑点, 但是明白后, 意味深长, 会心一笑. 比如 “我不想元首毁灭你”, 以及最有趣的是 Joseph 以教授身份从上将口中套取 Sobinski 的信息中体现出的满满醋意.第二次访问上将, Joseph 的机智与冷静, 胆识过人, 但又来了个转折, 戏团的人员又伪装了元首的一批人马, 戏中有戏, 骗得智商不高的上将团团转, 但是上将的手下 斯库兹还是有点警惕.女主 Maria 在与教授, 斯库兹, 以及 上将 的戏份中也非常聪明与细致, 多个回合的对话试探, 充分体现出她的随机应变, 心思缜密后面的是伪装的元首, 上将见到伪装的元首, 又批评了斯库兹, 引得斯库兹自杀, 真是愚蠢的上将, 赤胆忠心的手下.还有很多耐人寻味的地方, 比如 Joseph 和 Sobinski 告别 Maria 时, Joseph 允许他去告别, 但是听到他叫她 Maria 后, 走过去, Sobinski 又改口 Ms Tura . 以及最后带上门也是 Joseph .逃走后 在飞机上, 元首让士兵跳下飞机, 士兵义无反顾, 没有思想, 令人可笑.最后贴上精彩的对白A: 你是怎么到这里的 ?B: 我出生在这里A: 是什么让你决定死在这里?B: 他 (指希特勒）A: 你想从元首这里得到什么 ?B: 他想从我们这里得到什么?他想从波兰得到什么? 为什么 ? 为什么?我们不是人吗 ? 我们没有眼睛吗? 没有手吗…器官 感觉 尺度 影响 热情吃同样的东西 被同样的武器伤害…受到同样的疾病的折磨 以同样的方法治愈有同样寒冷的冬天 和温暖的夏天如果你刺穿我们 我们不会流血吗?如果你给我们挠痒痒 我们不会发笑吗?如果你给我们下毒 我们不会死掉吗?如果你错误地对待我们 我们能不报复吗? 2018-7-19 一人之下豆瓣8.6 这部动漫首先吸引我的就是它夹杂着四川话的配音了, 因为我也出四川人, 所以有种亲切感. 然后就是武侠,魔法(动漫中称为 练 炁, 查了一下: 同”气”,指构成人体及维持生命活动的最基本能量和生理机能。)这种题材, 夸张的刻画与无厘头, 也有搞笑, 一小点黄暴的地方. 当看到徐四教冯宝宝的那些名词后,真的忍俊不禁, 比如阿威十八式.塑造的人物都个性鲜明, 比如纯真,呆萌的冯宝宝, 机智流氓的张楚岚… 2018-7-9 我不是药神豆瓣9.0 生命就是金钱 世界上只有一种病,那就是穷病 他才 20 岁, 他只是想活下去,他有什么罪 程勇为了赚钱,为了救活更多病人而贩卖印度药, 警察为了维护程序正义而进行抓捕, 公司代表为了维护自身利益而维权, 病人为了活下去而买药, 各方都没有错, 但是却矛盾重重. 如今的医药体制值得我们深思. 程勇的两次转变是剧中的华点, 从开始为了赚钱,到后来为了救人,到后来为了救人救己. 永远都有更穷的人,不可能一直将价格降低下去.张长林贩卖假药十几年都没有被抓, 但是把价格上涨到 2万就出事了. 可以推测, 一些穷人在买不起更贵的药,生活无望后, 就会有反动的行为, 这里就是:既然我买不起药,那其他人也别想用这便宜药,即有人举报 所以如果完全杜绝了假药, 使病人陷入绝望, 无法生存, 必然会造成社会动荡. 2018-7-4 灵能百分百豆瓣9.3 灵幻除了会除灵外,什么都会. 确实是茂夫的人生导师.当你承受不住的时候, 你不想迫于压力去做的时候, 就不要去做. 拥有超能力并不使你成为别人的中心, 让别人尊重你.即使茂夫拥有超能力, 他不会对普通人使用, 他也需要用心,努力去追求他想要的—小蕾,肌肉. 这部漫画打破了以往人们对超能力的看法, 因为主角 茂夫(龙套) 只是一个初中生,他时常反思自己做的事有不有意义, 超能力并不有别于其他能力. 下面摘抄一下失控的杏鲍菇评价,与&lt;&lt;一拳超人&gt;&gt;的对比(别人写的太好啦,我太弱了.gif)琦玉老师的实力在一拳里是碾压级的，这种碾压意味着他站着不动让最终 BOSS 打上一套组合拳，都不会被擦破一点皮；而他解决绝 大多数反派时，只需要一记普通拳而已。可能这样的战斗日常确实让他太无聊，琦玉战斗时几乎不存在任何感情，愤怒、悲伤、恐惧 、兴奋，他不会感受到也完全不需要这些…… 他也不真正在乎世人对自己的看法，只是一直在做兴趣使然的事，哪怕千夫所指也不以为意。英雄协会曾评价道 “他的身体里寄宿者神明”，其实琦玉的内心也与神明无异，他用上帝视角打量着这个世界，面无表情地轻松击溃着可能毁灭一座城市的怪人，凡人的嘲讽与挑拨绝不会让他出离愤怒、堕入魔道，带有恶意的陌生信件也只会让他吐槽一句 “闲人 真多”。哪怕身边没有认同自己的徒弟杰诺斯，老师自己的心也早已强大到不用理会世间可笑的一切…… 当然，他还是希望稍微涨几个 粉。 而龙套完全不一样，他只有 14 岁，正是一个懵懂少年感情最丰富细腻的大好中二时光。他会疑惑自己现在做的事情有没有意义，自 己真正想要做的事是什么，思考灵和人类的存在意义孰轻孰重。他看似没有感情，实则是为了防止超能力失控而一直在抑制自己的感 情。他同样有碾压级的实力，但反派的队伍里强者一样很多，龙套会在战斗的过程中不断受伤，甚至被扰乱心智、堕入恶灵布置的幻 象陷阱里…… 大 BOSS 最上启示营造的假想世界，展示了龙套日常生活的另一种可能性——这里的龙套没有超能力，没有人生导师灵幻，没有可以交流的朋友，没有肉体改造部热血仗义的兄弟们，优秀的弟弟是陌生人，等待着龙套的只是日复一日的霸凌…… 是的，现实世界对龙套太过温暖善良了，只要稍有偏差，他就有可能颠覆三观，瞬间成为最强反派。这是龙套相对于琦玉的脆弱之处，也是他得以 在故事中被世界的温暖所引导，逐渐学会自己思考、战斗、一步步成长的诱因。感情上的变化与成长——这是《灵能》始终在说，而《 一拳》不曾提起的话题。 2018-6-30 凸变英雄 BABA- 豆瓣8.7 我的父亲是英雄 凸变英雄 有两季, BABA, LEAF, 剧情上关联不大BABA 就说明主题是 父亲, LEAF 就是主角花语叶 这一季主题就是父亲对女儿的爱. 同样, 前面10集都是活在梦里. 各种无厘头的搞笑与夸张. 玩了不少梗最后面的转折, 转弯有点猛, 但是还是很感人的. 小时候, 我们都会认为自己的父亲无所不能, 无所不知, 是我们的英雄. 但是, 随着我们长大, 成熟, 我们知道父亲并不是那么完美, 甚至还有很多缺点, 但是父亲对我们的爱仍然会使我们泪眼朦胧. 2018-6-30 凸变英雄 LEAF -豆瓣 8.9 你就是照亮这个世界唯一的光 剧情非常有趣, 曲折离奇, 跌宕起伏. 搞笑的地方也很多, 不过有些有点俗,但确实好笑啊 2333 .前面几集都是在梦里, 女主角梦到到了另外一个世界, 通过脱衣服召唤服魂进行战斗.有很多隐喻, 伏笔, 看到后面几集就会发现前面的伏笔确实很精彩 不仅如此, 动漫后面的情节也十分感人.为了正义, 沙天真英勇献身为了保护孩子, 沙小光的母亲装疯卖傻, 花语叶的父亲昧着良心选择躲避. 2018-6-29 一拳超人-豆瓣 9.3 我变秃了, 也变强了 地球就由我来守护 看到这个名字, 以为一拳就能解决的, 不会有什么精彩的打斗, 可能不好看. 然后还是看了, 非常搞笑,夸张,有趣.哪个男孩子没有一个当英雄的梦想呢? 埼玉在求职失败, 为了救下被怪物追杀的小孩, 下定决心做一个兴趣使然的英雄.他的训练方式是锻炼身体,2333, 这是强调锻炼身体的重要性吗? 最有同感的地方是做一个英雄的孤独. 纵使除了杰克斯外, 没有人理解他, 没有人记得他, 他仍然相信自己, 坚持走下去. 他也会逐 渐失去对生活的激情与斗志, 但他不会忘记, 他还能重新点燃斗志. 动漫里面的英雄协会挺有意思的, 英雄也要注册登记, 才好安排任务, 便于出名与升级. 这体现任何事物都要有个良好的管理运作方 式, 才能更加高效 2018-2-13 萤火虫之墓 -豆瓣 8.7 如果你能看到我的世界里那些渐渐消逝的美好，你就能体会到现在所拥有的幸福。 我最开始觉得那个阿姨有错，对兄妹很刻薄，给家人盛饭，而给兄妹俩盛汤。不过我觉得男孩应该苟且偷生，至少为了妹妹，为了活 下去，忍气吞声也是值得的，而不至于最后去偷盗，特别是在空袭到来时趁火打劫。 可是在那种情况，人人自保，两者的做法也是可以理解的， 罪恶的源头就是战争了。 看着美好的人，事物逝去，真的很伤心，多么可爱的节子啊。 2018-2-8 穿越时空的少女 -豆瓣 8.6 Time waits for no one! 本来不屑于看这种穿越剧的，但是实在是比较闲，可能想吃狗粮了吧，又鉴于评分比较高，就看了。每个人都有一段青涩的校园青春呐。不过这部影片表现得一点也不造作，很自然，穿越的部分逻辑上自洽。女主为了挽回过失而一次 次穿越到过去，却没想到可能会造成更大的错误。所有我们做事前应该考虑一下后果是什么，该怎样为自己的选择与行为负责。 2018-2-5 夏日大作战 -豆瓣 8.5 不要灰心！不要泄气，让我看看你的骨气！这个是战斗，我也会做点什么的！重要的是要像以前一样，人与人之间相互关照和交流。但是生命仅有一次不是吗？成千上万的人处于困境之中啊，现在不加油，什么时候加油？不要放弃啊，永不言弃才是最重要的！这个 是只有你才能做到的啊！你的话一定可以做到的！能行的！ 看介绍是关于程序，人工智能，爱情的才看的。不过没有预想的那样好看。最大感受是关于 OZ 系统，一个账号就关联一个人， 通过这个系统，日常的工作，衣食住行都在账号的记录下，受其控制，管理。我想这或许可能是未来的趋势，人的一切都数据化，由 统一的系统管理。同时体现信息安全的重要性。不过该片中的口算解密，并不应该推崇。要知道，人的脑力是有限的，而计算机能力 强大，最终应该是人利用计算机来控制万物。 2018-2-2 瑞克与莫蒂 -豆瓣 9.6 人们所谓的爱情，只不过是为了促使人类繁衍后代的化学反应，爱情来的猛烈，莫蒂，但是它会悄悄地溜走，把你留在一场失败 的婚姻中。 NOBODY EXISTS ON PURPOSE． “当你把你的思想放到这个年轻的身体的时候，这个年轻的大脑干了年轻人最常干的事情：把不好的想法藏起来，在周围砌一堵墙自欺欺人。但是这些不好的想法才是真正的你：意识到自己的衰老，意识到每个人都会死，意识到宇宙那么大，没有任何事情是有意 义的。” 这部剧已经有 3 季了，每一季评分都很高，而且确实很好看。看之前，网上介绍说比较黄暴，确实这样，但是写的外公与外孙的冒险，充满了科幻与亲情。由于我没见到我外公，然后就来看这部动漫了。很多暴力，奇幻，荒诞的镜头（人确实追求刺激呢），涉及到很多主题，亲情，人生的意义，善与恶… 有很多此 Morty 因为善良而救下一些人或做了什么事，多造成了更加严重的后果。或许从某种意义上我们不应该改变事物发展的规律，善恶并不是自己想的那么单纯。这显得无为与消极，不过导演也说了，正是感到到人生的意义的迷茫后才会从小角度在意身边的点 点滴滴。 当 Rick and Morty 穿越时空，杀死那个时空的自己并埋了的时候，Morty 很伤感与恐惧，世事无常，强者取代弱者，适者生存。 当 Jerry 对自己极度不自信需要别人的肯定时，明白自信的重要，不在乎外界的评价，不受外界的干扰，明白自己的厉害不需要，不是所在平台，所属集体的衬托。， 当 Rick 在时空错乱时愿意舍弃生命拯救 Morty 时，当他知道 Jerry 想去揭发他给银河联邦，他主动去投降时，我们可以看到他对 家人的爱，虽然表面上说着 I don’t give a fuck,(不在乎任何东西) 在大屠杀之夜那一集，虽然后来把所有富人都杀了，但是结局还是和以前一样。这说明一个和谐社会的建议要有领导与制度，不然一 群庸人只会形成原始社会。 另外，原本一直善良正直，坚守原则的莫蒂验证了斯坦福监狱实验得出的路西法效应，在这个可以正当 杀人的夜晚动手后大开杀戒，事后清醒后又自责不已。毕竟，有些时候，即使是上帝最宠爱的天使路西法，也可能会堕落成恶魔。坦 然面对自己心中的恶，接受它，不要可疑避免，不然在某个环境是会大爆发的。 在费城 (Citadel of Rick) 那一集（第三季第 7 集），在满是 Rick 的国度，聪明无敌的化身，却没建立乌托邦，而是地狱。我认 为原因是社会的组成单一，当都是聪明的 Rick, 却做着不同的职业，得到不同的待遇，形成不同的阶层。可见，社会形成应该是多元化的，人们各司其职，能者多得。这一集很经典，有很多暗喻，比如黑人白人，种族歧视，川普，总统竞选，吸毒… 详细分析可以看这里。结尾曲优雅动听 For the damaged coda 2018-1-26 我是江小白 -豆瓣 8.3 世间有很多事情，人们无法从它寂静的表象，猜测到暗涌，就像一个人和另一个人的相遇。 这部动漫 B 站评分 9.6, 而且取材是重庆。而且是都市爱情剧（为什么单身狗还特爱看爱情剧呢？） 剧情委婉曲折，跌宕起伏。整个剧从失忆的男主到记起以前的所有事，几条线穿插着，以及记忆的碎片拼凑起来。最开始我也认为女 主是夕雨。不过两次车祸都这么凑巧，感觉上现实不会这样，编剧过于追求情节与悬念了。 画面很美丽，很喜欢这种画风。也很期待爱情。bgm 也很好听，比如 fly- 民谣版]]></content>
      <categories>
        <category>生活</category>
        <category>娱乐</category>
      </categories>
      <tags>
        <tag>娱乐</tag>
        <tag>影视</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书籍总结与推荐]]></title>
    <url>%2Fbooks.html</url>
    <content type="text"><![CDATA[我将所有书籍的电子版放在百度云了,可以点这里 ——-2019———未来世界的幸存者 戳我在线阅读 对于标题未来世界的幸存者,”未来” 既有已经到来的未来: VR, 基因编辑, 换头术, 一些工作机器取代人类等, 还有很遥远的未来: 社会的平等, 人类的进化, 熵增最后走向混乱等. 对于”幸存”, 从小的方面指个人的生活质量, 工作, 财富积累等, 从大的, 长远的方面看指人类社会结构, 人类生存方面的问题. 作者阮一峰在得知 AlphaGo 战胜世界冠军李世石(2016年3月)后, 意识到 机器人, 自动化, 人工智能正在变得比人类更强大. 最终技术可能淘汰人类. 因此开始撰写此书. 这本书讲了作者对未来的思考与忧虑, 着重写了技术对人类发展, 个人发展的影响. 从长远看, 技术影响历史发展, 而不是政治, 经济(不完全归纳). 技术加剧了人与人之间的不平等(在获得财富方面), 而又使人们在享受技术时更加平等(比如手机, 以前的马车, VR 体验等). 作者有很多悲观的预测, 如 未来只有两种途径可以改变人生, 一种是学习技术, 另一种是购买彩票 作者对技术的发展有悲观的看法. 技术正变得越来越先进, 越来越难懂, 越来越复杂, 大多数人都不理解技术了. 很多时候都是黑箱操作. 这里有个前提, 你使用黑箱时, 你不能保证黑箱它不出错, 它没有后门等等. 作者思考技术是否有边界, 正如美国经济学家熊彼特所说:”资本主义最终将因为无法承受其快速膨胀带来的能量, 而崩溃自身的规模”, 那么技术是否会如此呢? 书中有一篇文章为什么你可以不用上大学, 提到现在信息化时代. 很多知识都可以自学. “大学课程是为了那些不知道学什么的人设计的，千万不要因为自己找不到方向，而被这些课程画地为牢限制住。你要主动去接触和学习，那些自己感兴趣的东西。” 我开始反思自己在大学的学习, 很多时候就是考前突击, 应付考试了, 我始终认为兴趣是最好的老师, 学习不等于考试 学习就应该以兴趣, 深度为重, 而考试应该刷题, 反复练习. 这里还有一篇文章,东亚教育浪费了太多生命 批判应试教育制度的. 这里有一个关于学习观的视频 说到上大学, 我就想到了西游记, 我就想到了一部纪录片高十. 主人公为了考取名校(科大), 复读了很多年. 挺同情他的. 我知道 有怎样的认知就会做出怎样的选择. 我尊重他的选择, 尊重他追求梦想 — 考名校的坚韧品质.但是他应该了解更多一些, 认识世界, 认识自己更多一些: 考名校只是手段, 他的目的 (我想) 应该是以后有好的出路, 找好工作. 这些完全可以通过学一门技术, 积累经验达成. 复读了这么多年, 考的分数虽然在增加, 但是还是太低. 说明他学习并没有掌握方法与技巧, 没有在一次次考试中总结, 得到经验. 这样下去很难有质的变化 即使考上了, 他很可能难以跟上大学课程 (上条说到没有找到学习方法, 资质差). 虽然可以从考这么多年高考可以看出他内心还是很强大的, 但是由于, 梦想的实现, 前后的落差, 或者是心理压抑太久很可能走上抑郁, 堕落, 厌学等的失败道路 对于个人工作方面, 简单的, 重复的工作必将被机器取代, 高度自动化, (比如 以前的税务顾问, 银行取前 ATM等), 所以要发展难以被机器取代的能力: 如 人格魅力, 创意, 决策与领导力等. 技术发展迅速, 我们应该学习基础的, 不变的内容, 而不是各种应用(比如过时的 flash). 而且雇佣制度对劳工不利, 作者鼓励创业(想起 Paul Graham以及 YC), 以及准备好人生的 Plan B. 另外说到 API (这里不是指 Application Programming Interface, 而是公司的组织架构). 比如外卖送餐员没有领导, 直接从 API 接收任务, 再把结果回报给 API. 长期来看, 未来只有两种工作, API 之上的工作和 API 之下的工作. 这两种工作的特点就是 API 之下的工作更多, 更累, 报酬更低. API 之上的反之, 而作为 API 的 是 自动化, 机器化的. 才疏学浅, 欢迎讨论 ——-2018———意志力：关于自控、专注和效率的心理学 这本书通过一些生动有趣的例子, 以及相应的学术研究, 说明了 意志力就像一种能量, 是会消耗掉的(叫做自我损耗). 如同肌肉使用久了, 会疲劳. 而”补充” 意志力的一种方法就是补充糖分. 书中建议, 我们不要挑战自己的意志力, 即远离诱惑, 而不是抵 制诱惑. 另外, 形成一些习惯也能加强意志力.书中的两个观点: 意志力有限, 使用就会消耗 从同一账户提取意志力用于不同的任务. 即意志力只有一个账户, 而不是一个用于工作, 一个用于饮食, 一个用于运动等等.而且意志力是可以消耗的, 那么做一些事情的先后顺序就会使意志力变化, 影响到事情的结果. 例如 护理人员为了不让病人关注病痛, 跟病人持续交谈. 抵制巧克力影响解几何题 甄别间谍的方法: 怀疑一个人是苏联间谍, 直接问他会不会说俄语不管用, 但是如果让他确认俄语单词的字体颜色, 他花的时间比 较长且回答正确的话, 说明他会说俄语. 有句俗语是 “上班受气, 回家踢狗”. 不过, 现代人一般不会如此虐待宠物, 而是更可能对家人恶语相向. 这也是为什么工作压力最大时婚姻往往出问题: 人们在工作上用完了意志力.(所以建议在工作还剩些精力时就下班回家) 考试季节, 学生自制力消耗过大,各种好习惯更可能被打破. 比如更可能与朋友出去玩, 而不是学习. 睡过头, 乱花钱的行为都有所增加. 脾气变坏, 更容易动怒或沮丧. 或许他们认为是压力过大, 然而, 压力真正做的是损耗意志力, 从而更难控制情绪. 下面是一些建议 身体抱恙的同学会影响考试. (身体上的痛苦影响注意力, 耗费意志力) 累了, 就睡 (睡眠剥夺可能损害葡糖糖的加工, 会导致自制力下降) 为了保持稳定的自制力, 最好吃血糖指数低的食物，如蔬菜,坚果,水果,鱼,肉等. 养成习惯, 无意识地做出自律的行为, 减少意志力的消耗 干净, 整洁的环境有助于养成良好的习惯. 因为葡萄糖影响意志力, 所以有一些有趣的建议, 比如: 午餐过后 4小时, 不要与上司争论. 还没有吃晚餐, 就不要与伴侣讨论严肃 话题. 更有研究表明, 低血糖患者与一般人相比,更难集中精力, 更难控制情绪. 在罪犯暴力分子中, 低血糖体征不是一般的普遍, 有的律 师用低血糖为嫌犯辩护. 对伪心理说不 书中, 作者首先举例说明心理学的研究范围,人们的刻板印象等等. 然后就论述心理学是一门科学, 通过科学的特性,以及定义出的可 操作性定义 来辩证.这本书不是你想的那样, 包含什么占星术, 或者能读懂别人的心理等等. 主要是对人的心理的认识, 比如一些偏见, 一些自我的心理理论, 一些非理性的想法等等.下面是具体的内容概括 心理学应具有可证伪原则 (科学的必要性) 操作性定义的概念 利用可测量,可观察的操作来表述的概念定义. 操作性定义使得科学知识变得公开可检验,而不是像”直觉”,非经验性定义那样,只属于 特定个体. 如智力, 其实大家都有自己的定义(或者说概念,但是表达不出来), 需要有操作性定义, 比如智力检测题(当然可以不同, 只要合理, 能为绝大多数人接受) 见证和个案研究证据 由于见证和个案对于当事人具有鲜活性(与当事人联系更紧密), 人们会倾向于相信个案, 而不是统计规律.如安慰剂效应, 总有提出证实其疗效的个人见证. 相关和因果 不要混淆这两种关系. 虽然概念容易分辨, 但到了真实场景就很可能混淆. 还有选择性偏差造成很多虚假的相关. 人们在一定程度上选择了他们的环境, 认为的创造了行为特性和环境变量之间的相关. 控制变量法 聚合性证据 说明了科学的发展模式是一步步变化的, 不是 跃进的. 每个实验不能完全正确, 但是每一个实验可以进步一点, 它必须满足关联性原则: 新的理论不仅要能解释新的科学数据,还必须能解释已有的数据 多重原因与主要原因 概率 了解概念的规律,比如条件概率, 明白事件发生都是在概率下进行的. 比如 有人 声称能预言股票走势,你确实连续收到它发给你的股 票走势都是正确的. 然而事实是: 比如, 他第一个月向 1000 个 人 中的 500 个发送股票上涨, 另外一半发送股票下跌, 然而结果是股票下跌, 那么下一个月对发送股票下跌的500人进行同样的操作. 连续几次后, 总有人在概率下都”预测”正确了的 偶然 同样的, 用概率的角度来看待事件的发生. 那么也能理解偶然事件的发生, 而不是事件具有相关性.人们常常有 解释偶然事件的倾向(然而只是概率上的偶然,没什么好解释的). 心理学家 Ray Hyman有过如下讨论 我们不得不运用自己原有的知识和期望以获得对世界万物的理解.在大多数的一般情景中,这种对于只是背景和记忆的运用让我们正确的阐释一些主张,并对此提供必要的推论.但是这一机制在原本没有承载任何信息的情景中偏离正轨.有些本是能够轻而易举就识别出来的随机性噪音,我们却不懈地从中寻找意义 人们倾向于个人能力可以影响偶然事件的结果: 比如买彩票, 人们更愿意自己去抽取, 而不是雇员直接给你. 这通常叫做 “参与 性抽彩”.另外, 公平世界假设: 人们倾向于相信世界是公平的,每个人都得到应得的东西, 俗语就是”好人有好报,坏人有坏报”.当得知一个平时非常善良的人遭遇横祸,会认为上天不公; 他们也相信坏人迟早是会遭报应的.** 别做正常的傻瓜 这本书中讲到我们在生活中的各种抉择,看似正常, 可是却不理性,分析后就发现我们做的选择竟然会自相矛盾, 这是因为心理学的作 用.比如: 心理账户: 不同的消费有不同的账户, 设想两个场景, 1. 某电影上映,你弄丢了价值100元的电影票,你是否还会重买一张 2. 同样 的电影, 正准备去买电影票,但是你弄丢了与电影票价值相同的手表, 你是否还要买电影票 收入来源不同,风险偏好不同: 正常人倾向于把赢来的钱消费掉,而把赚来的钱存起来 正常人通常在交易中会收到无关参考值的影响,过多考虑参考价格和商品实际价格的差额: 要知道,商品的价值只有它的实际价格与 对你的用途有关, 而与折扣, 昂贵..无关. 也就是说,你买打折了的商品是因为对你有用吗?还是因为折扣. 再例: 普通被子比超大被子便宜,你正好想买被子,且普通被子刚好适合你的床. 可是这天有优惠,两种被子一样的价格. 你买了超大被子,后来发现被子常常掉 在地上,体验非常不好 买了钱去做不愿做的事情(沉没成本): 你通过广告买了一个非常昂贵的领带, 到手后发现一点都不喜欢, 但是你舍不得扔掉,继续使用,可是这给你带来不好的体验 期望:来看看两个场景的对比 1. 你有两个选择: A.确定性地得到10000 B.50%得到20000,50%得0 2. 你有两个选择: A.100%损失10000 B.50%损失20000, 50%不损失. 大部分人可能1A,2B 前景理论: 对于上面的期望例子,理应来说期望一样,可是人的选择却不同,一个有风险,一个没风险. 这是因为: 正常人在面临获得 时是风险规避的,在面临损失时是风险喜好的… 这个得与失是通过差值确定的,所以高边参照点就能改变人对得失的判断,改变他们对风险的态度 损失规避性 赋予效应: 在得到东西时觉得不怎么有价值,而一旦拥有后再失去时就会感到这种东西的重要性. 比如商家利用这点 让顾客免费 体验 安于现状: 这个就很常见了, 变化是未知的, 是需要精力来适应的, 且很可能带来损失, 由于人们的损失规避性, 人们常常安于 现状. 比如对于转专业这件事. 忽略未得利益: 本来可以得到却没有得到的利益, 也称为机会成本. 正常人往往只注意到一般的损失, 而对未得利益不敏感. 定位效应: 人们估计一个值时, 常常受到一个锚点的影响(也是先入为主), 然后在其上下 小范围的调整.比如回答如下问题, 你的手机后三位是? 你猜测手机后三位数字比罗马帝国灭亡的年代的数字大还是小? 再猜测罗马是哪一年灭亡 的.虽然都知道这两者毫不相关, 但是你猜测的数字还出受到你手机后3三的影响, 是以它为锚点, 小幅度调整的结果.再如, 商家利用这个开一个很高的价钱, 即时可以砍价, 也是在这个价钱小幅度范围. 先入为主: 人们被第一印象框住后,以后接收的信息都会带有主观的偏向性, 对于之后获得的信息往往会偏向于用以证明自己的第一判断, 而忽视甚至扭曲一些可以纠正自己先验判断的信息. 比较判断与单独判断: 在单独判断时,有的特征是容易评价的,有的则难, 人们常受容易评价的特征的影响而做出欠理性的决策, 而 很多情况下难评价的特征可能对评价人更有价值; 在比较判断时, 所以特征都容易评价. 如 有两本字典, 特点是第一本有 1万条词汇,全新 第二本有两万条, 有些许破损, 不影响查阅. 现在让做比较判断, 很多人都会选 择后者, 因为我们看重的是查阅的能力. 而单独判断时, 很多人都会选择前者, 因为人们不知道 1万条词汇是怎样的概念, 是难以评价的特征, 而关注了容易评价的特征 是否破损, 所有选择了前者, 但是词汇量是对评价人更有价值的特征.这个还有一种应用, 比如相亲时是否带你的闺蜜/基友当你美 ta 丑, 带;当你丑 ta 美, 不带当都美, 不带当都丑, 带同样的,也可以应用到与对手竞争时的场景. 送礼的智慧 要知道, 你送礼物在选择时是比较判断, 而 对方 只收到这个礼物, 是单独判断, 所以要以单独判断的思维去选择礼物. 在一个不太昂贵的礼物类别中选择一个比较贵的礼物, 要比在比较昂贵的礼物类别中选一个比较便宜的效果好. 因为对方收到礼 物会和 ta 之前见过的同类物品进行比较. 有用的不如无用的. 最好的礼物应该是吃不掉,用不掉,仍不掉的. 管理的智慧 小奖不如没奖, 小惩不如没惩. 人们往往做事是出于自己的内在动力了, 而一旦与奖励挂钩, 就变成了一个经济交易. 晚说不如早说. 在有好的事情时, 早点说, 别人期待的就越久 传递消息的智慧 多个好消息要分开说 多个坏消息要一起说 好消息大, 坏消息小,可以一起说 好消息小, 坏消息大, 不要一起说 非常好的一本书,非常喜欢 &#x1f603; 批判性思维 本书从基础的断言，论题，论证(前提, 推理, 结论) 说起，讲了怎么演绎推理（这学期正好在上数理逻辑）, 非演绎推理(类比, 归纳, 特殊)，怎样识别推理中的谬误（很多类），虽然有 些看起来很简单，但平时易走进思维误区，被修辞手法迷惑，误导。本书也谈及了道德中的推理，法律上的推理，美学上的推理，含 有主观成分，有时也很难抉择。 进行推理时, 需要分清那些是逻辑之外的装饰物, eg: 煽动情绪的语言, 阻碍客观中立的评价 表达含糊不清: 模糊, 歧义, 抽象, 未界定术语 我们也要警觉信息来源的可靠性, 可信度, 是否利益相关. 我们要注意不能对人的相关属性做无关的暗示性评价, 比如性别, 宗教, 种族. 推理判断会受修辞的影响: 委婉语 刻板映射(sterotype) 暗示 夸张 褒贬 闪烁其词(可能, 大概) 替代证明(有关数据显示, 研究表明) 误导的比较 推理中很可能出现的谬误: 基于情感的推理: 一旦语言被用于唤起人们的情感，要考虑每个结论是否有证据支持eg恐惧，同情，负疚，希望（placebo），怒（此时，人易变得不和逻辑，常将愤怒的情绪当成引起愤怒的对象的证据）负 易受阿谀奉承（apple polishing） 诉诸公众的论证的谬误 ：大多数人认为是事实，并不能成为它是事实的证据 诉诸司空见惯 同辈压力（peer pressure argument）大多数人都渴望被社交圈接受，不愿被本已接受的人冷漠，此心理，促使我们接受某判断，而不是此判断自身的特点 群体思维的谬误： 荣誉感 集体感。。。 主观主义 相对主义：一方面认为自己族群的道德观点普遍适用，同时又坚持认为（而不是“知道”）该标准不适用哪些不接受该标准的群体 “two wrongs make a right” fallacy 区分 合法的惩罚 &amp; 非法的报复 转移注意力，/烟雾弹 诉诸人身 ：把提出某断言的主体的特征与断言本身的特征混淆eg 他经常说谎，所以他这句话是假的 毒化井水：Eg a告诉你关于b的一些无关的负面信息，你倾向于拒绝接受b的言论 稻草人的谬误： 试图修改某断言，或谈及一相近的易于被驳斥的断言 false delema： 在还有其他选项时，却在断言中只给出两个选项完美主义的谬误：若a不能达成某目标，则否定 拒绝a划界谬误 ： 不该划界却划界 错置举证责任证责任： 1。 初信度低的一方 2. 肯定方げ 法律为保障权利， 除非证明有罪，否则无罪 我们应该留意生活中的各种结论是否有依据，需要进行思考，而不至于被语言文字误导。 富爸爸，穷爸爸 关于投资理财的书。对比了两个爸爸，一个代表富人，一个代表穷人（实为中产阶级，但是没有财商），的观念，思考习惯，金融行 为等，来强调培养财商，掌握金钱运作规律的重要性，以脱离“老鼠赛跑”的陷阱，实现财务自由。 作者有很多独特新颖的观点与思想。能引发思想上的碰撞，启蒙你在投资理财，贫富差异，工作生活，金钱运作规律等方面的知识。 比如对学校的教育问题，重点在技能的培养上面，而几乎没有关于人理财方面的知识。比如富人与穷人的差别，在收入与支出上面，富人购入资产，穷人购入负债；在对待金钱的看法上面，穷人认为金钱是万恶之源，认 为敛财是贪婪罪恶的体现。以及相关的各种思想与见解，比如当初税收是中产阶级，穷人等惩罚富人，让富人纳税而发明出来的，但是现在纳税的主体却是中产 阶级，富人通过公司等手段可以减少纳税。 我们整天忙于工作，这是我为钱工作，而投资理财，就是让钱为我工作。而即使穷人可能有了储蓄，他们也更可能为了提高生活质量 等消费而动用储蓄，这就是作者所说的负债，购入负债，能用来投资，生钱的资产就减少了。 关于付出与收获，作者说道 当你感到手头“短缺”或“需要”什么时，首先要想到给予，只有先“予”，你才会在将来“取”得回报，无论金钱、微笑、爱情还是友谊，都是这样。我知道人们常常会这件事放在最后，但事实证明这样做对我总是大有种益的。我相信互利互惠的原则是正确的，我为自己 想要的东西付出成本。 腾讯传 腾讯公司的发展历史，是中国互联网的发展历史的一个体现。 在这本书中，你可以看到互联网给人们生活带来的变化，了解大公司对产品的理念，对产品运维的艰难，对用户体验的重视，对商业竞争的战略，如何将大流量变现，公司的投资与并购，中西的文化差异下不同的消费观，对虚拟生活的体验，引发对移动互联网时代的未来发展，对模仿抄袭与创新，开放与封闭，垄断与合作等问题的思考。 马化腾从传呼机起家，“意外”做起 IM，并依靠其巨大的流量，触手伸向互联网的各个领域：电商，搜索，安全卫士，娱乐（网游，音乐，视频，动漫，网文），金融等等。 腾讯的成功有很多因素 马化腾团队胆识与勇气，运气 马化腾互联网的理解（互联网 +，在线生活…） 独特的管理（内部赛马机制，qzone,wechat 等的成功） 对人才的重视与吸纳（刘炽平，张小龙，熊明华…） … 在经历 3Q 大战后，腾讯开始反思，接收外来的意见与批评，做出一些战略调整，逐步走向开放，并活跃与公益事业等。 腾讯确实是一个令人佩服的公司 资源链接；腾讯传 https://pan.baidu.com/s/1kWbQtH9 （排版不好看） 黑客与画家 作者当过画家，后来又是程序员。作者格雷汉姆比较了画家与黑客的共同点，都是创造性的工作，还介绍了一些黑客的特点。并推崇 lisp。这里是详细的读书笔记]]></content>
      <categories>
        <category>阅读与思考</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『common lisp』宏及函数的实现]]></title>
    <url>%2Fcommon-lisp-macro.html</url>
    <content type="text"><![CDATA[1. macros1.1. once-onlylisp123456(defmacro once-only ((&amp;rest names) &amp;body body) (let ((gensyms (loop for n in names collect (gensym)))) `(let (,@(for i in gensyms collect `(,i (gensym)))) `(let (,,@(loop for g in gensyms for n in names collect ``(,,g ,,n))) ,(let (,@(loop for n in namws for g in gensyms collect `(,n ,g))) ,@body))))) 1.2. with-gensymlisp123(defmacro with-gensym (vars &amp;rest body) `(let ( ,@(loop for i in vars collect `(,i (gensym)))) ,@body)) 用法: (defmacro a-macro ((&amp;rest vars) &amp;body, body) (with-gensym ((somevars) `(......) ,@body)) 1.3. 测试框架lisp12345678910111213141516171819(defmacro combine-rsts (&amp;rest cases) (with-gensym (rst) `(let ((,rst t)) ,@(loop for i in cases collect `(unless ,i (setf ,rst nil))) ,rst)))(defmacro check (&amp;rest cases) `(combine-rsts ,@(loop for case in cases collect `(report ,case &apos;,case) )))(defmacro with-gensym ((&amp;rest vars) &amp;rest body) `(let ,(loop for i in vars collect `(,i (gensym))) ,@body))(defun report (expr form) (format t &quot;~:[wrong ~;correct~] --- ~a~%&quot; expr form) expr) (check (= (+ 3 5)8 ) (zerop (- 8 7)))correct --- (= (+ 3 5) 8)wrong --- (ZEROP (- 8 7)) 1.3.1. 更高层次的抽象lisp1234567(defvar *fun-name* nil)(defmacro deftest (name parameters &amp;body body ) `(defun ,name ,parameters (let ((*fun-name* &apos;(append *fun-name* (list &apos;,name))) ,@body))) (deftest test ()&emsp;(check&emsp;&emsp;(= (+ 3 5)8 )&emsp;&emsp;(zerop (- 8 7)))) 1.4. cond1234(defmacro my-cond (&amp;rest body) (let ((rst nil) (body (reverse body))) (dolist (i body rst) (setf rst `(if ,(car i),(second i),rst))))) 2. functions2.1. primeplisp12345678910111213141516171819(defun primep (x) (when (&gt; x 1) (loop for fac from 2 to (sqrt x) never (zerop (mod x fac)))))(defun next-prime (x) (loop for i from x when (primep i) return i))(defmacro do-prime ((p begin end) &amp;rest body) (let ((end-val end)) ;end-val will evalute many times, so make it certaintrue `(do ((,p (next-prime ,begin) (next-prime (1+ ,p))))truetrue((&gt; ,p ,end-val)) ,@body)))(defun cp-tree (li)true (if (null li) niltrue (let ((x (car li))) (if (atom x) (cons x (cp-tree (cdr li))) (cons (cp-tree x) (cp-tree (cdr li))))))]]></content>
      <categories>
        <category>程序设计</category>
        <category>common lisp</category>
      </categories>
      <tags>
        <tag>common lisp</tag>
        <tag>macro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『读书笔记』黑客与画家]]></title>
    <url>%2Fhacker-and-painter.html</url>
    <content type="text"><![CDATA[前言朋友推荐了我这本书，我就仔细地读了。这本书虽然看似堆满了零散的观点，但这些观点发人深省，有些又很新奇，有些又充满经验。大致讲了黑客的特点，书呆子气等，与画家类似的创新设计模式，开发互联网软件的过程与经验，财富获得，黑客选择的语言，软件的设计哲学，还有各种夸 lisp（我也想学 lisp 了》_&lt;）。观点比较杂，我就整理我认同的一些观点与经验吧 作者介绍Paul Graham，他开发了第一个互联网应用软件 Viaweb，该程序被雅虎收购，成为 Yahoo！Store。他创办了创业孵化公司 Y conbinator。 观点与经验1. 黑客是怎样的黑客充满书呆子气，不愿参与社交。这是因为他们的心思都放在要解决的问题上了。在学生时代，就会显得不受欢迎。 黑客的学习进步可借鉴其他行业，比如画家，完成一个作品是要不断修改的，不要过早优化。作为创作者，要从原创出发，这里是对比科研人员是在已有成果上做改进，而不是原创。在技术上，应多从优秀代码学习。对待编程要有一丝不苟的认真态度。 2. 财富财富不等于金钱。获得财富的方法也有很多，但是最好的，最有效的是创造财富 — 创业或是加入创业公司。在创业公司的效率可以是大公司的数十倍（估计，数值不重要），（沟通需要成本），虽然在创业公司创造的财富是数十倍，总体回报也是差不多，但是对于个体是随机的，回报的中位数为 0。人与人创造财富的能力有差距，从而回报也有差距（若用金钱来衡量）比如一般 CEO 是常人的 100 倍，职业篮球运动员是常人的 128 倍… 技术的发展，是否加剧贫富分化？ 在收入上是拉大了差距，但是在其他方面可以说是减小了差距，比如 pc，手机人人都可以有，在以前是不可想象的。 3. 编程与软件开发编程主要在调试，所得有好的 debug 能力。编程的特点不是先把全部思路都想好了再写，可以便携程序边理解，其中可能有其他发现。由于这个特点，程序语言最好支持动态类型，以方便扩展。 人人都想变得聪明，或者让自己，别人觉得聪明。数学，是聪明的一种表现。所以，在编程时，存在诱惑：向数学方法上靠近，这时应该提醒自己：什么是你认为重要的东西。 编程语言，是程序员的思考模式。要选择好的编程语言，语言是有强弱之分的。只是大多数人满足现状：我目前使用的语言能解决问题，某些语言不过是有一些奇怪的特性罢了。这就是思维被语言同化。使用某种语言能做到的事是有极限的。虽然在图灵完备性上程序可以由任何一种语言写，但是代码长度，开发速度，工作量是不同的。他就设想了 100 年后 的编程语言：内核小（如同数学上的公理），eg 尽量少的基础类型，虽然可能速度较慢，但他认为硬件的提升可以忽略这个差异。有强大的函数库，简洁很重要 程序写出来是给人看的，附带能在机器上运行。 代码尽量要简洁，冗余的代码会产生更多的冗余的代码。对于软件开发，在竞争方向上，选择新兴领域会更有市场。如果能发布，就发布，即使还有 bug。开发的技术越困难，对手越难模仿。这就是‘进入壁垒’。提高进入壁垒的方法可以是申请专业，但是打官司是打不过大公司的。所以小的创业公司还是要让自己的产品不能被轻易复制。提高软件可靠性的关键在于开发时全神贯注，而不是降低速度。 4. 设计好的设计以永不过时为目标。有以下特点。 趣味 艰苦 模仿大自然 对称：重复性；递归性 再设计：反复修改，不断完善 启发性：在软件领域，是指一个产品要有基础夫人模块，供用户组合，就像搭积木。在科研领域，可以看一篇文章的引用送送次数。 5. 不能说的话他将不能说的话分成几类，以启发我们去寻找。不能说的话是对谁不能说，对谁可以说？这样刻意去做也是有意的。优秀作品往往来自其他人忽视的想法。而且自由思考比畅所欲言更重要。 真话。想想其他人说了，而陷入麻烦？ 异端想法。那些我们未经大脑审查而冒出的想法，才是我们的真实想法，让它出现，来好好剖析自己。 时空差异。时过境迁，地域文化差异。 口号禁令。想想一本正经的卫道者在捍卫着什么。 在别人想试探你的立场，观点时，要么保持沉默，要么注意分寸地回答。 “别想在我身上做石蕊试验’]]></content>
      <categories>
        <category>阅读与思考</category>
      </categories>
      <tags>
        <tag>common lisp</tag>
        <tag>读书笔记</tag>
        <tag>黑客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从化院到计院]]></title>
    <url>%2Ffrom-chem-to-cs.html</url>
    <content type="text"><![CDATA[摘要：这篇文章是为了回忆一下大一的生活，专业的变化，以及对科大的点点看法 &emsp;&emsp;上一篇&lt;&lt;从竹中到科大&gt;&gt;写了我考到科大的过程，也提到了我以前想当科学家的梦想。最后我被科大化院材料系录取。感谢科大转专业的自由，如今我已转入计院。现回顾这一年并记录下来。 &emsp;&emsp;来到科大，我干劲十足。上半学期，科气满满：只有学习，只看重gpa，极少参加社团活动。 因为做科研，最好要出国，出国得有个好的gpa，想要高的gpa,得整天刷题（我当时就是这样想的。）但我也知道，这样学得并不快乐，刷题并没有多大乐趣。 在有换专业的想法前，同大多数高中生一样，对专业一无所知，甚至会有错的认识。到了化院后，潜意识里不想改变（转专业要换新环境等挑战），然后又自我安慰，“欺骗自己”：化院也挺好的，我也挺喜欢化学的。 &emsp;&emsp;后来，在网上了解了很多信息，比如逛知乎(&gt;_&lt;)，接触了一些新东西，“伪化生”，“劝退”，“CS大法”…… 开始理性地思考自己要学的专业。当时我想转的其实是信院，因为当时觉得自己接触计算机很少，不适合计算机. 专业 优缺点 化材 1. 待遇差2. 化学实验对身体有害 3. 挺累的 信计 1. 找工作容易2. 有趣3. cool &emsp;&emsp;考虑到就业待遇，兴趣，家庭情况，我此时已有转专业的想法。后来认识了一个信转计的大神，他劝我转计，我就从了。诚实地说，在那时，我转专业的主要原因是考虑到就业待遇，虽然是计算机小白，但也有学好计算机的热情。正是有这种热情，在大一下学期，我缓修掉了4学分的化学课，有更多的时间来看计算机方面的书（毕竟我是计算机小白，不，大白，什么都不懂）。而且也不在乎gpa了，因为我并无很强的出国愿望。就这样，在得到正反馈的同时，而且这种反馈也很即时，我爱上了计算机专业。或许是干一行，爱一行吧，或许是要对她有足够了了解才行吧。 &emsp;&emsp;我是幸运的，因为我能缓修课程。而有的院，比如某空院就不行了。因为我也去帮某空的朋友向教学院长，学导，教秘求情过，总是以“本院有本院的规定，不能打乱教学计划”为由而拒绝。我去看了个性化学习的管理方法 各院系应充分了解学生重新选择专业的原因和心理状况，积极做好引导工作，防止盲目选择，原则上学生所在院系不得设置人为障碍阻拦学生的重新选择。 —-教字[2017]16号 中国科学技术大学 本科生个性化学习管理办法 总觉得某院不该这样做： 1. 对于某院的同学，是不公平的。当看到其他同学都能缓修，而他们不能。 2. 对于想转专业的同学，无论你怎样“挽留”，终究是徒劳的，为什么不让愿意留下的得到更多资源，愿意走的就心甘情愿让他们走？ 3. 这样只会加重同学们的负担，加重对某院的怨气。 现在是信息时代，我们得承认时代的潮流，得明白社会的供求。我当然不是说我们全部都转CS。有情怀，对基础学科感兴趣的同学愿意学，那是很好的。如果某位同学能在基础学科作出重大成果，我也会由衷地表示祝贺与敬佩。但是某些管理层不能打着统一的口号，对所有同学（尤其是对专业不是很了解的同学），统一地宣传，统一的思想教育。 &emsp;&emsp;咦，刚才说什么来着，哦，我对计算机专业产生强烈的兴趣。在对比了一下信院，计院的培养方案后，我发现我更喜欢计院的课程。所以我就决定转计院啦！ &emsp;&emsp;再来说说课程吧，比如计院的力热课。老师上课是真的在划水，基本上是在念大纲，时常讲个笑话。当然，我觉得这不是老师的错，他可能也觉得学力热真的对计院同学影响不大，所以不加重同学们的负担。所以错的就是这教学计划，培养方案了。科大是有多在意*数理基础扎实这个名号啊！一些这种强制的必修课水过，就如一次科普，但是这种形式浪费了太多时间，精力。 &emsp;&emsp;再说说老师吧。某些老师，为了学生重视他的课，次次点名，很想让这些学生得到应有的惩罚。他们认为（有的老师亲口说了的），学生不来上课，逃课就是不好，就是堕落的体现，就是学不好……要知道，一堂课是兼顾全班的，所以也就不能个性化地学习。有的学生是有能力安排自己的学习，他能评估这堂课对他自己的价值，对他自己的影响。当然，有的老师也很开明，对学生挺好的。 &emsp;&emsp;再说说科大风气吧。“中科大学风好”，很多学生慕名而来（招生老师这样宣传的）。可是，实际上，很多学风是不正的，比如，“膜”。见到这个膜，见到那个膜，甚至一些同学学得很苦，成绩不好，他们也膜。我是不想去揣度这是怎样的意图，如果没有，那就是不正的风气。某些大神是很厉害，你诚心地敬佩，当然可以。可是某些人的“膜大神”就不知是什么感情了。除了这点，还有就是同学们科气化，比如唯gpa是论：gpa-&gt;爱情？{:width=”250” height=”20i0”} &emsp;&emsp;再说说友谊吧。首先，感谢学长学姐，他们能热情无私地解答疑惑，指引道路，提供帮助。（如今我也成为学长了，我也尽可能地去帮助学弟学妹。） 对于同学，我认识了不少人，但是难有很多志趣相投的伙伴。或许也是因为我时而孤僻，不愿合群的性格吧。 &emsp;&emsp;再说说情感吧。唉，算了，说多了都是泪。 &emsp;&emsp;Life is Beautiful ! 时间匆匆流去，我会好好珍惜以后的时间。加油!]]></content>
      <categories>
        <category>生活</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>选择</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从竹中到科大]]></title>
    <url>%2Ffrom-zhuzhong-to-ustc.html</url>
    <content type="text"><![CDATA[&emsp; &emsp; 他是一个农村来的孩子，对外面的世界了解得很少。到了县城读高中，他就觉得县城是他见过最繁华的地方。但他还是知道一点外面的世界，或者说知道两个名词――北大，清华，大人们从小到大念叨的学校。从进入竹中起，他充满敬意，也不知天高地厚地把清北定为目标， 三年后的梦想大学。他听说他们那个地方每年也最多一个清北的， 然而他无所畏惧啊，他认为：为什么那个人不是我呢？ &emsp; &emsp; 到了竹中，首先经历了分班考试，他很幸运地进入了所谓的“火箭班”，全年级仅此一个。他很开心，觉得自己很厉害。可是在接下来的一个多学期，他的成绩并不怎么好。他不是没有努力，他也非常地有上进心，不怎么玩游戏。分析原因：1. 中学没养成良好的学习习惯 2. 平时作息没安排好，有时上课会睡着 3. 接触了很多新鲜事物， 有些分心&emsp;&emsp; 可是有上进心的他不甘于现状，找出了原因，并下定决心要把成绩提高起来（他知道得不多，只觉得提高成绩是唯一的目标）。提高成绩的方法很多，他限制了自己刷手机的时间，把更多时间用来“学习”――刷题，他时常向成绩好的同学请教。当然还有一个很错误的决定：不准自己谈恋爱。他那时也觉得很对：应该把时间用在学习上，只能谈恋爱而耽误学习呢？更可笑的是，在对女生产生了好感后，还自己抑制住感情；在有女生明显表露出爱慕之情后，竟避之淡之。&emsp;&emsp; 高一结束时，他对自己的成绩也些许满意，能排在年级前 15 左右了。在高二这一年，他开始享受学习的乐趣，他提前学习了课本上的数学物理知识，有时还能在同学前炫耀一番，颇为自豪呢。但这或许就是农村孩子的局限了吧，眼光太低， 视野太窄，资源太少，本来对数学，物理有极大的兴趣，然而却止步于课本，不知道，也不会从网络上获取资源；学习的正反馈居然是在别人前炫耀知识，而不是做出一些成果，更真诚地传递知识；学习的方法也是差到不行， 身边也很少有志同道合的朋友一起交流。更可悲的是，他，他们，只能拼命高考才能考到好的大学，才能获得高等教育的门票。因为他们没有能力，没有资源走竞赛道路，他们有的人甚至不愿意“浪费钱”去参加大学的一些夏令营等活动。他们只能通过高考，他们只在意分数。幸好，他是一个有点叛逆的人，幸好他对数学还是有些许热爱，他自己看了极小部分的数学竞赛内容（这在当时被老师，同学看做不误正业――高中学习，认为竞赛内容对他们很难，而且很可能没用），这在他后来参加科大的自强计划考试有了帮助。&emsp;&emsp; 生活就是这么美妙，富有挑战性啊！在高二结束前 2 个月，也就是 2015 年 5 月 1 日左右，正当他拼命学习得“不亦乐乎”时，一场大病突然降临，拖垮了他的身体健康。他被送往县里的大医院，住院了 16 天左右。在医院里，他非常伤心，甚至绝望，他懊悔因为作息，饮食等问题，以及感冒了不去治疗进而愈发严重，而患如此大病；他怜悯身边的病友因疾病被折磨得痛不欲生；他也开始思考人生的意义，世事的无常……当然，他还忘不了要继续学习，即使躺在病床上，也要为学习拼命啊！再后来他又到成都的一个大医院治疗，住院了 14 天。在这期间，他很感激同学们的帮助，他也忘不了爸妈守在病床前那疲惫的面容，关怀的眼神，心疼的表情。他下定决心要规律作息，健康饮食，珍惜身体健康。人啊，就是这样，你向他传授了千万经验，然而没有经历过，没有在认知上做出改变，他依然是不会改变的，这也是大多数人感叹，总是在失去后才懂得珍惜的原因。&emsp;&emsp;6 月初回到学校，由于在病床上学习了， 也很快接上了学习正轨。到了高三，所有人的神经都绷得紧紧地。他在外面租了房子，以便学习。一次次大考小考接踵而至，他麻木地，熟练地应付着，就如一台机器不停地处理着同样的任务。他有时会为考试的成绩波动而影响心情，可对身体健康的忧虑却从未停过。他有段时间很疯狂，早上 5 点 20 起床刷一套理综选择题，晚上刷题到 0 点左右才睡。他也知道，他不是一个人，比如隔壁房间的室友，比如全国各地的高中生。可是他是高中生啊，正值身体发育。他现在并不觉得高中生努力奋斗，一心学习，抛却杂念，不顾身体健康，废寝忘食，终于考上一流名校是多么美好的故事。到了这时，他也发现了自己和清北的差距，并了解到中科大，一所研究型学校， 正适合他。他的梦想是当一名科学家。&emsp;&emsp; 高考后几天，他参加了科大的自强计划招生考试。自强计划是针对农村学生的，所以他很感激高校的这种政策。至于为什么只参加科大的，因为他一心科研，觉得科大是做科研的最好的地方，清华只是一个工科学校。然后结果只有两个人得到优惠，他得到了科大的降一本录取， 四川还有一个同学得到降 20 分。最后打听到那个同学并没有来科大， 因为他也参加了清华的自强计划，得到了优惠，去了清华。高考成绩出来后，他的成绩差科大录取线 9 分，所以他能来到科大还是很幸运的。]]></content>
      <categories>
        <category>生活</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>USTC</tag>
      </tags>
  </entry>
</search>
